{
    "version": "https://jsonfeed.org/version/1",
    "title": "夜法之书 • All posts by \"gitlab\" category",
    "description": "~软件驱动世界~个人独立技术博客，关于Linux,开源，Nas，Docker，嵌入式，理财，健身等主题！",
    "home_page_url": "https://blog.17lai.site",
    "items": [
        {
            "id": "https://blog.17lai.site/posts/1879721e/",
            "url": "https://blog.17lai.site/posts/1879721e/",
            "title": "CI/CD与Git Flow与GitLab",
            "date_published": "2021-11-01T11:25:00.000Z",
            "content_html": "<blockquote>\n<p>CI/CD + Git Flow + GitLab 的整体工作流程记录。主要介绍一下 GitLab CI 相关功能，并通过 GitLab CI 实现自动化构建项目。项目中所用的示例项目已经上传到了 <a href=\"https://github.com/mritd/GitLabCI-TestProject\">GitHub</a></p>\n</blockquote>\n<h3 id=\"一、Git-Flow-简介\">一、Git Flow 简介</h3>\n<p>Git Flow 定义了一个围绕项目开发发布的严格 git 分支模型，用于管理多人协作的大型项目中实现高效的协作开发；Git Flow 分支模型最早起源于 <a href=\"http://nvie.com/about/\">Vincent Driessen</a> 的 <a href=\"http://nvie.com/posts/a-successful-git-branching-model/\">A successful Git branching model</a> 文章；随着时间发展，Git Flow 大致分为三种:</p>\n<ul>\n<li>Git Flow: 最原始的 Git Flow 分支模型</li>\n<li>Github Flow: Git Flow 的简化版，专门配合持续发布</li>\n<li>GitLab Flow: Git Flow 与 Github Flow 的结合版</li>\n</ul>\n<p>关于三种 Git Flow 区别详情可参考 <a href=\"https://www.ruanyifeng.com/blog/2015/12/git-workflow.html\">Git 工作流程</a></p>\n<h3 id=\"二、-Git-Flow-流程\">二、 Git Flow 流程</h3>\n<p>Github Flow 和 GitLab Flow 对于持续发布支持比较好，但是原始版本的 Git Flow 对于传统的按照版本发布更加友好一些，所以以下主要说明以下 Git Flow 的工作流程；Git Flow 主要分支模型如下</p>\n<p><img src=\"https://cimg1.17lai.site/data/2021/11/0120211101220215.jpg\" alt=\"git flow\"></p>\n<p>在整个分支模型中 <strong>存在两个长期分支: develop 和 master</strong>，其中 develop 分支为开发分支，master 为生产分支；<strong>master 代码始终保持随时可以部署到线上的状态；develop 分支用于合并最新提交的功能性代码</strong>；具体的分支定义如下</p>\n<ul>\n<li>master: 生产代码，始终保持可以直接部署生产的状态</li>\n<li>develop: 开发分支，每次合并最新功能代码到此分支</li>\n<li>feature: 新功能分支，所有新开发的功能将采用 <code>feature/xxxx</code> 形式命名分支</li>\n<li>hotfixes: 紧急修复补丁分支，当新功能部署到了线上出现了严重 bug 需要紧急修复时，则创建 <code>hotfixes/xxxx</code> 形式命名的分支</li>\n<li>release: 稳定版分支，当完成大版本变动后，应该创建 <code>release/xxxx</code> 分支</li>\n</ul>\n<p>在整个分支模型中，develop 分支为最上游分支，会不断有新的 feature 合并入 develop 分支，当功能开发达到完成所有版本需求时，则从 develop 分支创建 release 分支，release 后如没有发现其他问题，最终 release 会被合并到 master 分支以完成线上部署</p>\n<h3 id=\"三、Git-Flow-工具\">三、Git Flow 工具</h3>\n<p>针对于 Git Flow，其手动操作 git 命令可能过于繁琐，所以后来有了 git-flow 工具；git-flow 是一个 git 扩展集，按 Vincent Driessen 的分支模型提供高层次的库操作；使用 git-flow 工具可以以更加简单的命令完成对 Vincent Driessen 分支模型的实践；<br>\ngit-flow 安装以及使用具体请参考 <a href=\"https://danielkummer.github.io/git-flow-cheatsheet/index.zh_CN.html\">git-flow 备忘清单</a>，该文章详细描述了 git-flow 工具的使用方式</p>\n<p>还有另一个工具是 <a href=\"https://github.com/tj/git-extras\">git-extras</a>，该工具没有 git-flow 那么简单化，不过其提供更加强大的命令支持</p>\n<h3 id=\"四、Git-Commit-Message\">四、Git Commit Message</h3>\n<p>在整个 Git Flow 中，commit message 也是必不可少的一部分；一个良好且统一的 commit message 有助于代码审计以及 review 等；目前使用最广泛的写法是 <a href=\"https://docs.google.com/document/d/1QrDFcIiPjSLDn3EL15IJygNPiHORgU1_OOAqWjiDU5Y/edit#heading=h.greljkmo14y0\">Angular 社区规范</a>，该规范大中 commit message 格式大致如下:</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;\n&lt;BLANK LINE&gt;\n&lt;body&gt;\n&lt;BLANK LINE&gt;\n&lt;footer&gt;Copy</code></pre></div></figure>\n<p>总体格式大致分为 3 部分，首行主要 3 个组成部分:</p>\n<ul>\n<li>type: 本次提交类型</li>\n<li>scope: 本次提交影响范围，一般标明影响版本号或者具体的范围如 <code>$browser, $compile, $rootScope, ngHref, ngClick, ngView, etc...</code></li>\n<li>subject: 本次提交简短说明</li>\n</ul>\n<p>关于 type 提交类型，有如下几种值:</p>\n<ul>\n<li>feat：新功能(feature)</li>\n<li>fix：修补 bug</li>\n<li>docs：文档(documentation)</li>\n<li>style： 格式(不影响代码运行的变动)</li>\n<li>refactor：重构(即不是新增功能，也不是修改 bug 的代码变动)</li>\n<li>test：增加测试</li>\n<li>chore：构建过程或辅助工具的变动</li>\n</ul>\n<p>中间的 body 部分是对本次提交的详细描述信息，底部的 footer 部分一般分为两种情况:</p>\n<ul>\n<li>不兼容变动: 如果出现不兼容变动，则以 <code>BREAKING CHANGE:</code> 开头，后面跟上不兼容变动的具体描述和解决办法</li>\n<li>关闭 issue: 如果该 commit 针对某个 issue，并且可以将其关闭，则可以在其中指定关闭的 issue，如 <code>Close #9527,#9528</code></li>\n</ul>\n<p>不过 footer 部分也有特殊情况，如回滚某次提交，则以 <code>revert:</code> 开头，后面紧跟 commit 信息和具体描述；还有时某些 commit 只是解决了 某个 issue 的一部分问题，这是可以使用 <code>refs ISSUE</code> 的方式来引用该 issue</p>\n<h3 id=\"五、Git-Commit-Message-工具\">五、Git Commit Message 工具</h3>\n<p>针对 Git 的 commit message 目前已经有了成熟的生成工具，比较有名的为 <a href=\"https://github.com/commitizen/cz-cli\">commitizen-cli</a> 工具，其采用 node.js 编写，执行 <code>git cz</code> 命令能够自动生成符合 Angular 社区规范的 commit message；不过由于其使用 node.js 编写，所以安装前需要安装 node.js，因此可能不适合其他非 node.js 的项目使用；这里推荐一个基于 shell 编写的 <a href=\"https://cimhealth.github.io/git-toolkit\">Git-toolkit</a>，安装此工具后执行 <code>git ci</code> 命令进行提交将会产生交互式生成 Angular git commit message 格式的提交说明，截图如下:</p>\n<p><img src=\"https://cimg1.17lai.site/data/2021/11/0120211101220233.jpg\" alt=\"git ci\"></p>\n<h3 id=\"六、GitLab-整合\">六、GitLab 整合</h3>\n<p>以上 Git Flow 所有操作介绍的都是在本地操作，而正常我们在工作中都是基于 GitLab 搭建私有 Git 仓库来进行协同开发的，以下简述以下 Git Flow 配合 GitLab 的流程</p>\n<h4 id=\"6-1、开发-features\">6.1、开发 features</h4>\n<p>当开发一个新功能时流程如下:</p>\n<ul>\n<li>本地 <code>git flow feature start xxxx</code> 开启一个 feature 新分支</li>\n<li><code>git flow feature publish xxxx</code> 将此分支推送到远端以便他人获取</li>\n<li>完成开发后 GitLab 上向 <code>develop</code> 分支发起合并请求</li>\n<li>CI sonar 等质量检测工具扫描，其他用户 review 代码</li>\n<li>确认无误后 <code>master</code> 权限用户合并其到 <code>develop</code> 分支</li>\n<li>部署到测试环境以便测试组测试</li>\n<li>如果测试不通过，则继续基于此分支开发，直到该功能开发完成</li>\n</ul>\n<h4 id=\"6-2、创建-release\">6.2、创建 release</h4>\n<p>当一定量的 feature 开发完成并合并到 develop 后，如所有 feature 都测试通过并满足版本需求，则可以创建 release 版本分支；release 分支流程如下</p>\n<ul>\n<li>本地 <code>git flow release start xxxx</code> 开启 release 分支</li>\n<li><code>git flow release publish xxxx</code> 将其推送到远端以便他人获取</li>\n<li>继续进行完整性测试，出现问题继续修复，直到 release 完全稳定</li>\n<li>从 release 分支向 master、develop 分支分别发起合并请求</li>\n<li>master 合并后创建对应的 release 标签，并部署生产环境</li>\n<li>develop 合并 release 的后期修改</li>\n</ul>\n<h4 id=\"6-3、紧急修复\">6.3、紧急修复</h4>\n<p>当 master 某个 tag 部署到生产环境后，也可能出现不符合预期的问题出现；此时应该基于 master 创建 hotfix 分支进行修复，流程如下</p>\n<ul>\n<li>本地 <code>git flow hotfix start xxxx</code> 创建紧急修复分支</li>\n<li>修改代码后将其推送到远端，并像 master、develop 分支发起合并</li>\n<li>develop 合并紧急修复补丁，如果必要最好再做一下测试</li>\n<li>master 合并紧急修复补丁，创建紧急修复 tag，并部署生产环境</li>\n</ul>\n<h3 id=\"七、环境准备\">七、环境准备</h3>\n<p>首先需要有一台 GitLab 服务器，然后需要有个项目；这里示例项目以 Spring Boot 项目为例，然后最好有一台专门用来 Build 的机器，实际生产中如果 Build 任务不频繁可适当用一些业务机器进行 Build；本文示例所有组件将采用 Docker 启动， GitLab HA 等不在本文阐述范围内</p>\n<ul>\n<li>Docker Version : 1.13.1</li>\n<li>GitLab Version : 10.1.4-ce.0</li>\n<li>GitLab Runner Version : 10.1.0</li>\n<li>GitLab IP : 172.16.0.37</li>\n<li>GitLab Runner IP : 172.16.0.36</li>\n</ul>\n<h3 id=\"八、GitLab-CI-简介\">八、GitLab CI 简介</h3>\n<p>GitLab CI 是 GitLab 默认集成的 CI 功能，GitLab CI 通过在项目内 <code>.gitlab-ci.yaml</code> 配置文件读取 CI 任务并进行相应处理；GitLab CI 通过其称为 GitLab Runner 的 Agent 端进行 build 操作；Runner 本身可以使用多种方式安装，比如使用 Docker 镜像启动等；Runner 在进行 build 操作时也可以选择多种 build 环境提供者；比如直接在 Runner 所在宿主机 build、通过新创建虚拟机(vmware、virtualbox)进行 build等；同时 Runner 支持 Docker 作为 build 提供者，即每次 build 新启动容器进行 build；GitLab CI 其大致架构如下</p>\n<p><img src=\"https://cimg1.17lai.site/data/2021/11/0120211101220236.png\" alt=\"GitLab\"></p>\n<h3 id=\"九、搭建-GitLab-服务器\">九、搭建 GitLab 服务器</h3>\n<h4 id=\"9-1、GitLab-搭建\">9.1、GitLab 搭建</h4>\n<p>GitLab 搭建这里直接使用 docker compose 启动，compose 配置如下</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">version: '2'\nservices:\n  gitlab:\n    image: 'gitlab/gitlab-ce:10.1.4-ce.0'\n    restart: always\n    container_name: gitlab\n    hostname: 'git.mritd.me'\n    environment:\n      GITLAB_OMNIBUS_CONFIG: |\n        external_url 'http://git.mritd.me'\n        # Add any other gitlab.rb configuration here, each on its own line\n    ports:\n      - '80:80'\n      - '443:443'\n      - '8022:22'\n    volumes:\n      - './data/gitlab/config:/etc/gitlab'\n      - './data/gitlab/logs:/var/log/gitlab'\n      - './data/gitlab/data:/var/opt/gitlab'Copy</code></pre></div></figure>\n<p>直接启动后，首次登陆需要设置初始密码如下，默认用户为 <code>root</code></p>\n<p><img src=\"https://cimg1.17lai.site/data/2021/11/0120211101220240.png\" alt=\"gitkab init\"></p>\n<p>登陆成功后创建一个用户(该用户最好给予 Admin 权限，以后操作以该用户为例)，并且创建一个测试 Group 和 Project，如下所示</p>\n<p><img src=\"https://cimg1.17lai.site/data/2021/11/0120211101220427.png\" alt=\"Create User\"></p>\n<p><img src=\"https://cimg1.17lai.site/data/2021/11/0120211101220432.png\" alt=\"Test Project\"></p>\n<h4 id=\"9-2、增加示例项目\">9.2、增加示例项目</h4>\n<p>这里示例项目采用 Java 的 SpringBoot 项目，并采用 Gradle 构建，其他语言原理一样；<strong>如果不熟悉 Java 的没必要死磕此步配置，任意语言(最好 Java)整一个能用的 Web 项目就行，并不强求一定 Java 并且使用 Gradle 构建，以下只是一个样例项目</strong>；SpringBoot 可以采用 <a href=\"https://start.spring.io/\">Spring Initializr</a> 直接生成(依赖要加入 WEB)，如下所示</p>\n<p><img src=\"https://cimg1.17lai.site/data/2021/11/0120211101220246.png\" alt=\"Spring Initializr\"></p>\n<p>将项目导入 IDEA，然后创建一个 index 示例页面，主要修改如下</p>\n<ul>\n<li>build.gradle</li>\n</ul>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-jade\" data-language=\"jade\"><code class=\"language-jade\">buildscript {\n    ext {\n        springBootVersion = '1.5.8.RELEASE'\n    }\n    repositories {\n        mavenCentral()\n    }\n    dependencies {\n        classpath(\"org.springframework.boot:spring-boot-gradle-plugin:${springBootVersion}\")\n    }\n}\n\napply plugin: 'java'\napply plugin: 'eclipse'\napply plugin: 'idea'\napply plugin: 'org.springframework.boot'\n\ngroup = 'me.mritd'\nversion = '0.0.1-SNAPSHOT'\nsourceCompatibility = 1.8\n\nrepositories {\n    mavenCentral()\n}\n\n\ndependencies {\n    compile('org.springframework.boot:spring-boot-starter')\n    compile('org.springframework.boot:spring-boot-starter-web')\n    compile('org.springframework.boot:spring-boot-starter-thymeleaf')\n    testCompile('org.springframework.boot:spring-boot-starter-test')\n}Copy</code></pre></div></figure>\n<ul>\n<li>新建一个 HomeController</li>\n</ul>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-jade\" data-language=\"jade\"><code class=\"language-jade\">package me.mritd.TestProject;\n\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\n\n/*******************************************************************************\n * Copyright (c) 2005-2017 Mritd, Inc.\n * TestProject\n * me.mritd.TestProject\n * Created by mritd on 2017/11/24 下午12:23.\n * Description: \n *******************************************************************************/\n@Controller\npublic class HomeController {\n\n    @RequestMapping(\"/\")\n    public String home(){\n        return \"index\";\n    }\n}Copy</code></pre></div></figure>\n<ul>\n<li>templates 下新建 index.html</li>\n</ul>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"/&gt;\n    &lt;title&gt;Title&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;h1&gt;Test...&lt;/h1&gt;\n&lt;/body&gt;\n&lt;/html&gt;Copy</code></pre></div></figure>\n<p>最后项目整体结构如下</p>\n<p><img src=\"https://cimg1.17lai.site/data/2021/11/0120211101220249.png\" alt=\"TestProject\"></p>\n<p>执行 <code>assemble</code> Task 打包出可执行 jar 包，并运行 <code>java -jar TestProject-0.0.1-SNAPSHOT.jar</code> 测试下能启动访问页面即可</p>\n<p><img src=\"https://cimg1.17lai.site/data/2021/11/0120211101220251.png\" alt=\"TestProject assemble\"></p>\n<p>最后将项目提交到 GitLab 后如下</p>\n<p><img src=\"https://cimg1.17lai.site/data/2021/11/0120211101220304.png\" alt=\"init Project\"></p>\n<h3 id=\"十、GitLab-CI-配置\">十、GitLab CI 配置</h3>\n<blockquote>\n<p>针对这一章节创建基础镜像以及项目镜像，这里仅以 Java 项目为例；其他语言原理相通，按照其他语言对应的运行环境修改即可</p>\n</blockquote>\n<h4 id=\"10-1、增加-Runner\">10.1、增加 Runner</h4>\n<p>GitLab CI 在进行构建时会将任务下发给 Runner，让 Runner 去执行；所以先要添加一个 Runner，Runner 这里采用 Docker Compose 启动，build 方式也使用 Docker 方式 Build；compose 文件如下</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">version: '2'\nservices:\n  gitlab-runner:\n    container_name: gitlab-runner\n    image: gitlab/gitlab-runner:alpine-v10.1.0\n    restart: always\n    network_mode: \"host\"\n    volumes:\n      - /var/run/docker.sock:/var/run/docker.sock\n      - ./config.toml:/etc/gitlab-runner/config.toml\n    extra_hosts:\n      - \"git.mritd.me:172.16.0.37\"Copy</code></pre></div></figure>\n<p><strong>在启动前，我们需要先 touch 一下这个 config.toml 配置文件</strong>；该文件是 Runner 的运行配置，此后 Runner 所有配置都会写入这个文件(不 touch 出来 docker-compose 发现不存在会挂载一个目录进去，导致 Runner 启动失败)；启动 docker-compose 后，<strong>需要进入容器执行注册，让 Runner 主动去连接 GitLab 服务器</strong></p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"># 生成 Runner 配置文件\ntouch config.toml\n# 启动 Runner\ndocker-compose up -d\n# 激活 Runner\ndocker exec -it gitlab-runner gitlab-runner registerCopy</code></pre></div></figure>\n<p>在执行上一条激活命令后，会按照提示让你输入一些信息；<strong>首先输入 GitLab 地址，然后是 Runner Token，Runner Token 可以从 GitLab 设置中查看</strong>，如下所示</p>\n<p><img src=\"https://cimg1.17lai.site/data/2021/11/0120211101220624.png\" alt=\"Runner Token\"></p>\n<p>整体注册流程如下</p>\n<p><img src=\"https://cimg1.17lai.site/data/2021/11/0120211101220312.png\" alt=\"Runner registry\"></p>\n<p>注册完成后，在 GitLab Runner 设置中就可以看到刚刚注册的 Runner，如下所示</p>\n<p><img src=\"https://cimg1.17lai.site/data/2021/11/0120211101220628.png\" alt=\"Runner List\"></p>\n<p><strong>Runner 注册成功后会将配置写入到 config.toml 配置文件；由于两个测试宿主机都没有配置内网 DNS，所以为了保证 runner 在使用 docker build 时能正确的找到 GitLab 仓库地址，还需要增加一个 docker 的 host 映射( <code>extra_hosts</code> )；同时为了能调用 宿主机 Docker 和持久化 build 的一些缓存还挂载了一些文件和目录；完整的 配置如下(配置文件可以做一些更高级的配置，具体参考 <a href=\"https://docs.gitlab.com/runner/configuration/advanced-configuration.html\">官方文档</a> )</strong></p>\n<ul>\n<li>config.toml</li>\n</ul>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-toml\" data-language=\"toml\"><code class=\"language-toml\">concurrent = 1\ncheck_interval = 0\n\n[[runners]]\n  name = \"Test Runner\"\n  url = \"http://git.mritd.me\"\n  token = \"c279ec1ac08aec98c7141c7cf2d474\"\n  executor = \"docker\"\n  builds_dir = \"/gitlab/runner-builds\"\n  cache_dir = \"/gitlab/runner-cache\"\n  [runners.docker]\n    tls_verify = false\n    image = \"debian\"\n    privileged = false\n    disable_cache = false\n    shm_size = 0\n    volumes = [\"/data/gitlab-runner:/gitlab\",\"/var/run/docker.sock:/var/run/docker.sock\",\"/data/maven_repo:/data/repo\",\"/data/maven_repo:/data/maven\",\"/data/gradle:/data/gradle\",\"/data/sonar_cache:/root/.sonar\",\"/data/androidsdk:/usr/local/android\",\"/data/node_modules:/data/node_modules\"]\n    extra_hosts = [\"git.mritd.me:172.16.0.37\"]\n  [runners.cache]Copy</code></pre></div></figure>\n<p><strong>注意，这里声明的 Volumes 会在每个运行的容器中都生效；也就是说 build 时新开启的每个容器都会被挂载这些目录</strong>；修改完成后重启 runner 容器即可，由于 runner 中没啥可保存的东西，所以可以直接 <code>docker-compose down &amp;&amp; docker-compose up -d</code> 重启</p>\n<h4 id=\"10-2、创建基础镜像\">10.2、创建基础镜像</h4>\n<p>由于示例项目是一个 Java 项目，而且是采用 Spring Boot 的，所以该项目想要运行起来只需要一个 java 环境即可，中间件已经被打包到了 jar 包中；以下是一个作为基础运行环境的 openjdk 镜像的 Dockerfile</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-docker\" data-language=\"docker\"><code class=\"language-docker\">FROM alpine:edge \n\nLABEL maintainer=\"mritd &lt;mritd1234@gmail.com&gt;\"\n\nENV JAVA_HOME /usr/lib/jvm/java-1.8-openjdk\nENV PATH $PATH:/usr/lib/jvm/java-1.8-openjdk/jre/bin:/usr/lib/jvm/java-1.8-openjdk/bin\n\nRUN apk add --update bash curl tar wget ca-certificates unzip \\\n        openjdk8 font-adobe-100dpi ttf-dejavu fontconfig \\\n    &amp;&amp; rm -rf /var/cache/apk/* \\\n\nCMD [\"bash\"]Copy</code></pre></div></figure>\n<p><strong>这个 openjdk Dockerfile 升级到了 8.151 版本，并且集成了一些字体相关的软件，以解决在 Java 中某些验证码库无法运行问题，详见 <a href=\"https://mritd.me/2017/09/27/alpine-3.6-openjdk-8-bug/\">Alpine 3.6 OpenJDK 8 Bug</a></strong>；使用这个 Dockerfile，在当前目录执行 <code>docker build -t mritd/openjdk:8 .</code> build 一个 openjdk8 的基础镜像，然后将其推送到私服，或者 Docker Hub 即可</p>\n<h4 id=\"10-3、创建项目镜像\">10.3、创建项目镜像</h4>\n<p>有了基本的 openjdk 的 docker 镜像后，针对于项目每次 build 都应该生成一个包含发布物的 docker 镜像，所以对于项目来说还需要一个项目本身的 Dockerfile；<strong>项目的 Dockerfile 有两种使用方式；一种是动态生成 Dockerfile，然后每次使用新生成的 Dockerfile 去 build；还有一种是写一个通用的 Dockerfile，build 时利用 ARG 参数传入变量</strong>；这里采用第二种方式，以下为一个可以反复使用的 Dockerfile</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-docker\" data-language=\"docker\"><code class=\"language-docker\">FROM mritd/openjdk:8-144-01\n\nMAINTAINER mritd &lt;mritd1234@gmail.com&gt;\n\nARG PROJECT_BUILD_FINALNAME\n\nENV TZ 'Asia/Shanghai'\nENV PROJECT_BUILD_FINALNAME ${PROJECT_BUILD_FINALNAME}\n\n\nCOPY build/libs/${PROJECT_BUILD_FINALNAME}.jar /${PROJECT_BUILD_FINALNAME}.jar\n\nCMD [\"bash\",\"-c\",\"java -jar /${PROJECT_BUILD_FINALNAME}.jar\"]Copy</code></pre></div></figure>\n<p><strong>该 Dockerfile 通过声明一个 <code>PROJECT_BUILD_FINALNAME</code> 变量来表示项目的发布物名称；然后将其复制到根目录下，最终利用 java 执行这个 jar 包；所以每次 build 之前只要能拿到项目发布物的名称即可</strong></p>\n<h4 id=\"10-4、Gradle-修改\">10.4、Gradle 修改</h4>\n<p>上面已经创建了一个标准的通用型 Dockerfile，每次 build 镜像只要传入 <code>PROJECT_BUILD_FINALNAME</code> 这个最终发布物名称即可；对于发布物名称来说，最好不要固定死；当然不论是 Java 还是其他语言的项目我们都能将最终发布物变成一个固定名字，最不济可以写脚本重命名一下；但是不建议那么干，最好保留版本号信息，以便于异常情况下进入容器能够分辨；对于当前 Java 项目来说，想要拿到 <code>PROJECT_BUILD_FINALNAME</code> 很简单，我们只需要略微修改一下 Gradle 的 build 脚本，让其每次打包 jar 包时将项目的名称及版本号导出到文件中即可；同时这里也加入了镜像版本号的处理，Gradle 脚本修改如下</p>\n<ul>\n<li>build.gradle 最后面增加如下</li>\n</ul>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-jade\" data-language=\"jade\"><code class=\"language-jade\">bootRepackage {\n\n    mainClass = 'me.mritd.TestProject.TestProjectApplication'\n    executable = true\n\n    doLast {\n        File envFile = new File(\"build/tmp/PROJECT_ENV\")\n\n        println(\"Create ${archivesBaseName} ENV File ===&gt; \" + envFile.createNewFile())\n        println(\"Export ${archivesBaseName} Build Version ===&gt; ${version}\")\n        envFile.write(\"export PROJECT_BUILD_FINALNAME=${archivesBaseName}-${version}\\n\")\n\n        println(\"Generate Docker image tag...\")\n        envFile.append(\"export BUILD_DATE=`date +%Y%m%d%H%M%S`\\n\")\n        envFile.append(\"export IMAGE_NAME=mritd/test:`echo \\${CI_BUILD_REF_NAME} | tr '/' '-'`-`echo \\${CI_COMMIT_SHA} | cut -c1-8`-\\${BUILD_DATE}\\n\")\n        envFile.append(\"export LATEST_IMAGE_NAME=mritd/test:latest\\n\")\n    }\n}Copy</code></pre></div></figure>\n<p><strong>这一步操作实际上是修改了 <code>bootRepackage</code> 这个 Task(不了解 Gradle 或者不是 Java 项目的请忽略)，在其结束后创建了一个叫 <code>PROJECT_ENV</code> 的文件，里面实际上就是写入了一些 bash 环境变量声明，以方便后面 source 一下这个文件拿到一些变量，然后用户 build 镜像使用</strong>，<code>PROJECT_ENV</code> 最终生成如下</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">export PROJECT_BUILD_FINALNAME=TestProject-0.0.1-SNAPSHOT\nexport BUILD_DATE=`date +%Y%m%d%H%M%S`\nexport IMAGE_NAME=mritd/test:`echo ${CI_BUILD_REF_NAME} | tr '/' '-'`-`echo ${CI_COMMIT_SHA} | cut -c1-8`-${BUILD_DATE}\nexport LATEST_IMAGE_NAME=mritd/test:latestCopy</code></pre></div></figure>\n<p><img src=\"https://cimg1.17lai.site/data/2021/11/0120211101220738.png\" alt=\"PROJECT_ENV\"></p>\n<h4 id=\"10-5、创建-CI-配置文件\">10.5、创建 CI 配置文件</h4>\n<p>一切准备就绪以后，就可以编写 CI 脚本了；GitLab 依靠读取项目根目录下的 <code>.gitlab-ci.yml</code> 文件来执行相应的 CI 操作；以下为测试项目的 <code>.gitlab-ci.yml</code> 配置</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\"># 调试开启\n#before_script:\n#  - pwd\n#  - env\n\ncache:\n  key: $CI_PROJECT_NAME/$CI_COMMIT_REF_NAME-$CI_COMMIT_SHA\n  paths:\n    - build\n\nstages:\n  - build\n  - deploy\n\nauto-build:\n  image: mritd/build:2.1.1\n  stage: build\n  script:\n    - gradle --no-daemon clean assemble\n  tags:\n    - test\n\ndeploy:\n  image: mritd/docker-kubectl:v1.7.4\n  stage: deploy\n  script:\n    - source build/tmp/PROJECT_ENV\n    - echo \"Build Docker Image ==&gt; ${IMAGE_NAME}\"\n    - docker build -t ${IMAGE_NAME} --build-arg PROJECT_BUILD_FINALNAME=${PROJECT_BUILD_FINALNAME} .\n#    - docker push ${IMAGE_NAME}\n    - docker tag ${IMAGE_NAME} ${LATEST_IMAGE_NAME}\n#    - docker push ${LATEST_IMAGE_NAME}\n#    - docker rmi ${IMAGE_NAME} ${LATEST_IMAGE_NAME}\n#    - kubectl --kubeconfig ${KUBE_CONFIG} set image deployment/test test=$IMAGE_NAME\n  tags:\n    - test\n  only:\n    - master\n    - develop\n    - /^chore.*$/Copy</code></pre></div></figure>\n<ul>\n<li><strong>关于 CI 配置的一些简要说明如下</strong></li>\n</ul>\n<h5 id=\"stages\">stages</h5>\n<p>stages 字段定义了整个 CI 一共有哪些阶段流程，以上的 CI 配置中，定义了该项目的 CI 总共分为 <code>build</code>、<code>deploy</code> 两个阶段；GitLab CI 会根据其顺序执行对应阶段下的所有任务；<strong>在正常生产环境流程可以定义很多个，比如可以有 <code>test</code>、<code>publish</code>，甚至可能有代码扫描的 <code>sonar</code> 阶段等；这些阶段没有任何限制，完全是自定义的</strong>，上面的阶段定义好后在 CI 中表现如下图</p>\n<p><img src=\"https://cimg1.17lai.site/data/2021/11/0120211101220327.png\" alt=\"stages\"></p>\n<h5 id=\"task\">task</h5>\n<p>task 隶属于 stages 之下；也就是说一个阶段可以有多个任务，任务执行顺序默认不指定会并发执行；对于上面的 CI 配置来说 <code>auto-build</code> 和 <code>deploy</code> 都是 task，他们通过 <code>stage: xxxx</code> 这个标签来指定他们隶属于哪个 stage；当 Runner 使用 Docker 作为 build 提供者时，我们可以在 task 的 <code>image</code> 标签下声明该 task 要使用哪个镜像运行，不指定则默认为 Runner 注册时的镜像(这里是 debian)；<strong>同时 task 还有一个 <code>tags</code> 的标签，该标签指明了这个任务将可以在哪些 Runner 上运行；这个标签可以从 Runner 页面看到，实际上就是 Runner 注册时输入的哪个 tag；对于某些特殊的项目，比如 IOS 项目，则必须在特定机器上执行，所以此时指定 tags 标签很有用</strong>，当 task 运行后如下图所示</p>\n<p><img src=\"https://cimg1.17lai.site/data/2021/11/0120211101221014.png\" alt=\"Task\"></p>\n<p>除此之外 task 还能指定 <code>only</code> 标签用于限定那些分支才能触发这个 task，如果分支名字不满足则不会触发；<strong>默认情况下，这些 task 都是自动执行的，如果感觉某些任务太过危险，则可以通过增加 <code>when: manual</code> 改为手动执行；注意: 手动执行被 GitLab 认为是高权限的写操作，所以只有项目管理员才能手动运行一个 task，直白的说就是管理员才能点击</strong>；手动执行如下图所示</p>\n<p><img src=\"https://cimg1.17lai.site/data/2021/11/0120211101220759.png\" alt=\"manual task\"></p>\n<h5 id=\"cache\">cache</h5>\n<p>cache 这个参数用于定义全局那些文件将被 cache；<strong>在 GitLab CI 中，跨 stage 是不能保存东西的；也就是说在第一步 build 的操作生成的 jar 包，到第二部打包 docker image 时就会被删除；GitLab 会保证每个 stage 中任务在执行时都将工作目录(Docker 容器 中)还原到跟 GitLab 代码仓库中一模一样，多余文件及变更都会被删除</strong>；正常情况下，第一步 build 生成 jar 包应当立即推送到 nexus 私服；但是这里测试没有搭建，所以只能放到本地；但是放到本地下一个 task 就会删除它，所以利用 <code>cache</code> 这个参数将 <code>build</code> 目录 cache 住，保证其跨 stage 也能存在</p>\n<p><strong>关于 <code>.gitlab-ci.yml</code> 具体配置更完整的请参考 <a href=\"https://docs.gitlab.com/ee/ci/yaml/\">官方文档</a></strong></p>\n<h3 id=\"十一、其他相关\">十一、其他相关</h3>\n<h4 id=\"11-1、GitLab-内置环境变量\">11.1、GitLab 内置环境变量</h4>\n<p>上面已经基本搞定了一个项目的 CI，但是有些变量可能并未说清楚；比如在创建的 <code>PROJECT_ENV</code> 文件中引用了 <code>${CI_COMMIT_SHA}</code> 变量；这种变量其实是 GitLab CI 的内置隐藏变量，这些变量在每次 CI 调用 Runner 运行某个任务时都会传递到对应的 Runner 的执行环境中；<strong>也就是说这些变量在每次的任务容器 SHELL 环境中都会存在，可以直接引用</strong>，具体的完整环境变量列表可以从 <a href=\"https://docs.gitlab.com/ee/ci/variables/\">官方文档</a> 中获取；如果想知道环境变量具体的值，实际上可以通过在任务执行前用 <code>env</code> 指令打印出来，如下所示</p>\n<p><img src=\"https://cimg1.17lai.site/data/2021/11/0120211101220338.png\" alt=\"env\"></p>\n<p><img src=\"https://cimg1.17lai.site/data/2021/11/0120211101220800.png\" alt=\"env task\"></p>\n<h4 id=\"11-2、GitLab-自定义环境变量\">11.2、GitLab 自定义环境变量</h4>\n<p>在某些情况下，我们希望 CI 能自动的发布或者修改一些东西；比如将 jar 包上传到 nexus、将 docker 镜像 push 到私服；这些动作往往需要一个高权限或者说有可写入对应仓库权限的账户来支持，但是这些账户又不想写到项目的 CI 配置里；因为这样很不安全，谁都能看到；此时我们可以将这些敏感变量写入到 GitLab 自定义环境变量中，GitLab 会像对待内置变量一样将其传送到 Runner 端，以供我们使用；GitLab 中自定义的环境变量可以有两种，一种是项目级别的，只能够在当前项目使用，如下</p>\n<p><img src=\"https://cimg1.17lai.site/data/2021/11/0120211101220803.png\" alt=\"project env\"></p>\n<p>另一种是组级别的，可以在整个组内的所有项目中使用，如下</p>\n<p><img src=\"https://cimg1.17lai.site/data/2021/11/0120211101220805.png\" alt=\"group env\"></p>\n<p>这两种变量添加后都可以在 CI 的脚本中直接引用</p>\n<h4 id=\"11-3、Kubernetes-集成\">11.3、Kubernetes 集成</h4>\n<p>对于 Kubernetes 集成实际上有两种方案，一种是对接 Kubernetes 的 api，纯代码实现；另一种取巧的方案是调用 kubectl 工具，用 kubectl 工具来实现滚动升级；这里采用后一种取巧的方式，将 kubectl 二进制文件封装到镜像中，然后在 deploy 阶段使用这个镜像直接部署就可以</p>\n<p><img src=\"https://cimg1.17lai.site/data/2021/11/0120211101220345.png\" alt=\"kubectl\"></p>\n<p>其中 <code>mritd/docker-kubectl:v1.7.4</code> 这个镜像的 Dockerfile 如下</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-docker\" data-language=\"docker\"><code class=\"language-docker\">FROM docker:dind \n\nLABEL maintainer=\"mritd &lt;mritd1234@gmail.com&gt;\"\n\nARG TZ=\"Asia/Shanghai\"\n\nENV TZ ${TZ}\n\nENV KUBE_VERSION v1.8.0\n\nRUN apk upgrade --update \\\n    &amp;&amp; apk add bash tzdata wget ca-certificates \\\n    &amp;&amp; wget https://storage.googleapis.com/kubernetes-release/release/${KUBE_VERSION}/bin/linux/amd64/kubectl -O /usr/local/bin/kubectl \\\n    &amp;&amp; chmod +x /usr/local/bin/kubectl \\\n    &amp;&amp; ln -sf /usr/share/zoneinfo/${TZ} /etc/localtime \\\n    &amp;&amp; echo ${TZ} &gt; /etc/timezone \\\n    &amp;&amp; rm -rf /var/cache/apk/*\n\nCMD [\"/bin/bash\"]Copy</code></pre></div></figure>\n<p>这里面的 <code>${KUBE_CONFIG}</code> 是一个自定义的环境变量，对于测试环境我将配置文件直接挂载入了容器中，然后 <code>${KUBE_CONFIG}</code> 只是指定了一个配置文件位置，实际生产环境中可以选择将配置文件变成自定义环境变量使用</p>\n<h4 id=\"11-4、GitLab-CI-总结\">11.4、GitLab CI 总结</h4>\n<p>关于 GitLab CI 上面已经讲了很多，但是并不全面，也不算太细致；因为这东西说起来实际太多了，现在目测已经 1W 多字了；以下总结一下 GitLab CI 的总体思想，当思路清晰了以后，我想后面的只是查查文档自己试一试就行了</p>\n<ul>\n<li><strong>CS 架构</strong></li>\n</ul>\n<p>GitLab 作为 Server 端，控制 Runner 端执行一系列的 CI 任务；代码 clone 等无需关心，GitLab 会自动处理好一切；Runner 每次都会启动新的容器执行 CI 任务</p>\n<ul>\n<li><strong>容器即环境</strong></li>\n</ul>\n<p>在 Runner 使用 Docker build 的前提下；<strong>所有依赖切换、环境切换应当由切换不同镜像实现，即 build 那就使用 build 的镜像，deploy 就用带有 deploy 功能的镜像；通过不同镜像容器实现完整的环境隔离</strong></p>\n<ul>\n<li><strong>CI即脚本</strong></li>\n</ul>\n<p>不同的 CI 任务实际上就是在使用不同镜像的容器中执行 SHELL 命令，自动化 CI 就是执行预先写好的一些小脚本</p>\n<ul>\n<li><strong>敏感信息走环境变量</strong></li>\n</ul>\n<p>一切重要的敏感信息，如账户密码等，不要写到 CI 配置中，直接放到 GitLab 的环境变量中；GitLab 会保证将其推送到远端 Runner 的 SHELL 变量中</p>\n<p>转载整理From：</p>\n<ul>\n<li><a href=\"https://mritd.com/2017/09/05/git-flow-note/\">git-flow-note</a></li>\n<li><a href=\"https://mritd.com/2017/11/28/ci-cd-gitlab-ci/\">ci-cd-gitlab-ci</a></li>\n</ul>\n<h2 id=\"系列教程\"><strong>系列教程</strong></h2>\n<p><a href=\"/atom.xml\"><i class=\"fas fa-rss\"></i>全部文章RSS订阅</a></p>\n\n<h3 id=\"Gitlab-使用系列\"><strong>Gitlab 使用系列</strong></h3>\n<p><a href=\"/categories/gitlab/atom.xml\"><i class=\"fas fa-rss\"></i><strong>Gitlab RSS 分类订阅</strong></a></p>\n<ul>\n<li><a href=\"/posts/acc13b70/\"><strong>Gitlab的安装及使用教程完全版</strong></a></li>\n<li><a href=\"/posts/29a820b3/\">破解Gitlab EE</a></li>\n<li><a href=\"/posts/d08eb7b/\">Gitlab的安装及使用</a></li>\n<li><a href=\"/posts/1879721e/\">CI/CD与Git Flow与GitLab</a></li>\n</ul>\n\n<h3 id=\"Devops系列\"><strong>Devops系列</strong></h3>\n<p><a href=\"/categories/devops/atom.xml\"><i class=\"fas fa-rss\"></i><strong>Devops 分类 RSS 订阅</strong></a></p>\n<ul>\n<li><a href=\"/posts/ab63eb8f/\">自建全套开源Devops开发系统</a></li>\n<li><a href=\"/posts/d32a07a7/\">Git介绍以及分支模型图解</a></li>\n<li><a href=\"/posts/39563241/\">三万字无坑搭建基于Docker+K8S+GitLab/SVN+Jenkins+Harbor持续集成交付环境</a></li>\n<li><a href=\"/posts/3437994a/\">DevOps系列—【Jenkinsfile+Dockerfile+nginx+vue】</a></li>\n<li><a href=\"/posts/f4c3ad41/\">项目开发管理工具推荐</a></li>\n<li><a href=\"/posts/acc13b70/\">Gitlab的安装及使用教程完全版</a></li>\n<li><a href=\"/posts/d08eb7b/\">Gitlab的安装及使用</a></li>\n<li><a href=\"/posts/78c3371/\">那些有用的Github工具介绍！Action、app、workflow等</a></li>\n</ul>\n\n<h3 id=\"项目管理系列\"><strong>项目管理系列</strong></h3>\n<p><a href=\"/categories/ai/atom.xml\"><i class=\"fas fa-rss\"></i><strong>AI 分类 RSS 订阅</strong></a></p>\n<ul>\n<li><a href=\"/posts/d8b1e381/\">如何做一个完整的硬件项目的项目管理之简明教程</a></li>\n<li><a href=\"/posts/ca630feb/\">几种常用管理模型和方法</a></li>\n<li><a href=\"/posts/ac0df556/\">PMBOK指南（第6版）</a></li>\n<li><a href=\"/posts/99be6dfb/\">如何做好竞品分析</a></li>\n<li><a href=\"/posts/a6477052/\">一大堆寓意深刻的管理故事锦集</a></li>\n<li><a href=\"/posts/ec34b111/\">人格类型分类总结归纳</a></li>\n</ul>\n\n",
            "tags": [
                "gitlab",
                "git",
                "ci/cd"
            ]
        },
        {
            "id": "https://blog.17lai.site/posts/29a820b3/",
            "url": "https://blog.17lai.site/posts/29a820b3/",
            "title": "破解Gitlab EE",
            "date_published": "2021-07-09T07:25:00.000Z",
            "content_html": "<blockquote>\n<p>由于需要一些镜像等 gitlab 高级功能，所有破解gitlab ee版本。<br>\n你能信么？ 这些破解方法来自官方自己的文档！</p>\n</blockquote>\n<h2 id=\"安装ruby\">安装ruby</h2>\n<p>安装完gitlab ee之后</p>\n<p>安装ruby：yum install ruby</p>\n<p>ruby版本需要2.3或以上。</p>\n<h2 id=\"生成许可证\"><strong>生成许可证</strong></h2>\n<p>gem install gitlab-license</p>\n<h2 id=\"创建一个rb文件\">创建一个rb文件</h2>\n<p>license.rb</p>\n<hr>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-ruby\" data-language=\"ruby\"><code class=\"language-ruby\">require \"openssl\"\nrequire \"gitlab/license\"\n \nkey_pair = OpenSSL::PKey::RSA.generate(2048)\nFile.open(\"license_key\", \"w\") { |f| f.write(key_pair.to_pem) }\n \npublic_key = key_pair.public_key\nFile.open(\"license_key.pub\", \"w\") { |f| f.write(public_key.to_pem) }\n \nprivate_key = OpenSSL::PKey::RSA.new File.read(\"license_key\")\nGitlab::License.encryption_key = private_key\n \nlicense = Gitlab::License.new\nlicense.licensee = {\n  \"Name\" =&gt; \"none\",\n  \"Company\" =&gt; \"none\",\n  \"Email\" =&gt; \"example@test.com\",\n}\nlicense.starts_at = Date.new(2020, 1, 1) # 开始时间\nlicense.expires_at = Date.new(2050, 1, 1) # 结束时间\nlicense.notify_admins_at = Date.new(2049, 12, 1)\nlicense.notify_users_at = Date.new(2049, 12, 1)\nlicense.block_changes_at = Date.new(2050, 1, 1)\nlicense.restrictions = {\n  active_user_count: 10000,\n}\n \nputs \"License:\"\nputs license\n \ndata = license.export\nputs \"Exported license:\"\nputs data\nFile.open(\"GitLabBV.gitlab-license\", \"w\") { |f| f.write(data) }\n \npublic_key = OpenSSL::PKey::RSA.new File.read(\"license_key.pub\")\nGitlab::License.encryption_key = public_key\n \ndata = File.read(\"GitLabBV.gitlab-license\")\n$license = Gitlab::License.import(data)\n \nputs \"Imported license:\"\nputs $license\n \nunless $license\n  raise \"The license is invalid.\"\nend\n \nif $license.restricted?(:active_user_count)\n  active_user_count = 10000\n  if active_user_count &gt; $license.restrictions[:active_user_count]\n    raise \"The active user count exceeds the allowed amount!\"\n  end\nend\n \nif $license.notify_admins?\n  puts \"The license is due to expire on #{$license.expires_at}.\"\nend\n \nif $license.notify_users?\n  puts \"The license is due to expire on #{$license.expires_at}.\"\nend\n \nmodule Gitlab\n  class GitAccess\n    def check(cmd, changes = nil)\n      if $license.block_changes?\n        return build_status_object(false, \"License expired\")\n      end\n    end\n  end\nend\n \nputs \"This instance of GitLab Enterprise Edition is licensed to:\"\n$license.licensee.each do |key, value|\n  puts \"#{key}: #{value}\"\nend\n \nif $license.expired?\n  puts \"The license expired on #{$license.expires_at}\"\nelsif $license.will_expire?\n  puts \"The license will expire on #{$license.expires_at}\"\nelse\n  puts \"The license will never expire.\"\nend\n </code></pre></div></figure>\n<hr>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">ruby license.rb</code></pre></div></figure>\n<p>生成 <code>GitLabBV.gitlab-license</code> <code>license_key</code> <code>license_key.pub</code> 这三个文件。</p>\n<h2 id=\"使用许可证\"><strong>使用许可证</strong></h2>\n<p>用 <code>license_key.pub</code> 文件替换 <code>/opt/gitlab/embedded/service/gitlab-rails/.license_encryption_key.pub</code>。</p>\n<p><code>GitLabBV.gitlab-license</code> 即是许可证，填入 <code>${address}/admin/license</code> 地址并重启 <code>gitlab-ctl restart</code> 。</p>\n<h2 id=\"修改等级\"><strong>修改等级</strong></h2>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-diff-ruby\" data-language=\"diff-ruby\"><code class=\"language-diff-ruby\">--- /opt/gitlab/embedded/service/gitlab-rails/ee/app/models/license.rb\n+++ /opt/gitlab/embedded/service/gitlab-rails/ee/app/models/license.rb\n@@ -458,7 +458,7 @@\n  end\n \n  def plan\n-    restricted_attr(:plan).presence || STARTER_PLAN\n+    restricted_attr(:plan).presence || ULTIMATE_PLAN\n  end\n \n  def edition\n </code></pre></div></figure>\n<h2 id=\"Gitlab添加许可证\">Gitlab添加许可证</h2>\n<h3 id=\"14-x-Gitlab之前添加许可证位置\">14.x Gitlab之前添加许可证位置</h3>\n<blockquote>\n<p>菜单-&gt;管理员-&gt;订阅-&gt;许可证上传</p>\n</blockquote>\n<h3 id=\"新版Gitlab添加许可证的位置在\">新版Gitlab添加许可证的位置在</h3>\n<blockquote>\n<p>菜单-&gt;管理员-&gt;设置-&gt;通用-&gt;添加许可证处点击展开-&gt;点击上传</p>\n</blockquote>\n<p>修改完成后使用 <code>gitlab-ctl restart</code> 重新加载配置。</p>\n<blockquote>\n<p>菜单-&gt;管理员-&gt;订阅</p>\n<p>在这里可以看到激活状态，上面操作没问题的话，这里可以看到激活成功！</p>\n</blockquote>\n<h2 id=\"参考\"><strong>参考</strong></h2>\n<ul>\n<li><a href=\"https://www.rubydoc.info/gems/gitlab-license/1.0.0/file/README.md\">https://www.rubydoc.info/gems/gitlab-license/1.0.0/file/README.md</a></li>\n</ul>\n<blockquote>\n<p>现在你已经破解好了Gitlab ee， 可以使用其中的高级功能。</p>\n<p>更多的Gitlab ee详细教程，请参考下面的gitlab系列教程！ 👇︎</p>\n</blockquote>\n<h2 id=\"系列教程\"><strong>系列教程</strong></h2>\n<p><a href=\"/atom.xml\"><i class=\"fas fa-rss\"></i>全部文章RSS订阅</a></p>\n\n<h3 id=\"Gitlab-使用系列\"><strong>Gitlab 使用系列</strong></h3>\n<p><a href=\"/categories/gitlab/atom.xml\"><i class=\"fas fa-rss\"></i><strong>Gitlab RSS 分类订阅</strong></a></p>\n<ul>\n<li><a href=\"/posts/acc13b70/\"><strong>Gitlab的安装及使用教程完全版</strong></a></li>\n<li><a href=\"/posts/29a820b3/\">破解Gitlab EE</a></li>\n<li><a href=\"/posts/d08eb7b/\">Gitlab的安装及使用</a></li>\n<li><a href=\"/posts/1879721e/\">CI/CD与Git Flow与GitLab</a></li>\n</ul>\n\n<h3 id=\"Devops系列\"><strong>Devops系列</strong></h3>\n<p><a href=\"/categories/devops/atom.xml\"><i class=\"fas fa-rss\"></i><strong>Devops 分类 RSS 订阅</strong></a></p>\n<ul>\n<li><a href=\"/posts/ab63eb8f/\">自建全套开源Devops开发系统</a></li>\n<li><a href=\"/posts/d32a07a7/\">Git介绍以及分支模型图解</a></li>\n<li><a href=\"/posts/39563241/\">三万字无坑搭建基于Docker+K8S+GitLab/SVN+Jenkins+Harbor持续集成交付环境</a></li>\n<li><a href=\"/posts/3437994a/\">DevOps系列—【Jenkinsfile+Dockerfile+nginx+vue】</a></li>\n<li><a href=\"/posts/f4c3ad41/\">项目开发管理工具推荐</a></li>\n<li><a href=\"/posts/acc13b70/\">Gitlab的安装及使用教程完全版</a></li>\n<li><a href=\"/posts/d08eb7b/\">Gitlab的安装及使用</a></li>\n<li><a href=\"/posts/78c3371/\">那些有用的Github工具介绍！Action、app、workflow等</a></li>\n</ul>\n\n<h3 id=\"项目管理系列\"><strong>项目管理系列</strong></h3>\n<p><a href=\"/categories/ai/atom.xml\"><i class=\"fas fa-rss\"></i><strong>AI 分类 RSS 订阅</strong></a></p>\n<ul>\n<li><a href=\"/posts/d8b1e381/\">如何做一个完整的硬件项目的项目管理之简明教程</a></li>\n<li><a href=\"/posts/ca630feb/\">几种常用管理模型和方法</a></li>\n<li><a href=\"/posts/ac0df556/\">PMBOK指南（第6版）</a></li>\n<li><a href=\"/posts/99be6dfb/\">如何做好竞品分析</a></li>\n<li><a href=\"/posts/a6477052/\">一大堆寓意深刻的管理故事锦集</a></li>\n<li><a href=\"/posts/ec34b111/\">人格类型分类总结归纳</a></li>\n</ul>\n\n",
            "tags": [
                "gitlab",
                "git",
                "crack"
            ]
        }
    ]
}