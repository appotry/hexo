{
    "version": "https://jsonfeed.org/version/1",
    "title": "夜法之书 • All posts by \"web\" category",
    "description": "~软件驱动世界~个人独立技术博客，关于Linux,开源，Nas，Docker，嵌入式，理财，健身等主题！",
    "home_page_url": "https://blog.17lai.site",
    "items": [
        {
            "id": "https://blog.17lai.site/posts/80938cfe/",
            "url": "https://blog.17lai.site/posts/80938cfe/",
            "title": "emoji表情符号",
            "date_published": "2022-03-23T10:18:00.000Z",
            "content_html": "<blockquote>\n<p>emoji表情符号是非常流行的表情符号，几乎没有地方都会支持。这里列举出常用的emoji表情不好，方便大家使用与查阅。</p>\n</blockquote>\n<span id=\"more\"></span>\n<h2 id=\"常用符号\">常用符号</h2>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-none\"><code class=\"language-none\">❤❥웃유♋☮✌☏☢☠✔☑♚▲♪✈✞÷↑↓◆◇⊙■□△▽¿─│♥❣♂♀☿Ⓐ✍✉☣☤✘☒♛▼♫⌘☪≈←→◈◎☉★☆⊿※¡━┃♡ღ ツ\n\n☼☁❅♒✎©®™Σ✪✯☭➳ 卐 √↖↗●◐Θ◤◥︻〖〗┄┆℃℉°✿ϟ☃☂✄¢€£∞✫★½✡×↙↘○◑⊕◣◢︼【】┅┇☽☾✚〓\n\n▂▃▄▅▆▇█▉▊▋▌▍▎▏↔↕☽☾ の•▸◂▴▾┈┊①②③④⑤⑥⑦⑧⑨⑩ⅠⅡⅢⅣⅤⅥⅦⅧⅨⅩ ㍿ ▓♨♛❖♓☪✙\n\n┉┋☹☺☻ت ヅツッシ Üϡﭢ™℠℗©®♥❤❥❣❦❧♡۵웃유ღ♋♂♀☿☼☀☁☂☄☾☽❄☃☈⊙☉℃℉❅✺ϟ☇♤♧♡♢♠♣\n\n♥♦☜☞☝✍☚☛☟✌✽✾✿❁❃❋❀⚘☑✓✔√☐☒✗✘ ㄨ ✕✖✖⋆✢✣✤✥❋✦✧✩✰✪✫✬✭✮✯❂✡★✱✲✳✴✵✶✷✸✹✺✻✼❄❅❆❇❈❉❊†☨✞✝☥☦☓☩☯☧☬\n\n☸✡♁✙♆。，、＇：∶；?‘’“”〝〞ˆˇ﹕︰﹔﹖﹑•¨….¸;！´？！～—ˉ ｜‖＂〃｀@﹫¡¿﹏﹋﹌︴々﹟#\n\n﹩$﹠&amp;﹪%*﹡﹢﹦﹤‐￣ ¯―﹨ˆ˜﹍﹎+=&lt;＿*-\\ˇ~﹉﹊（）〈〉‹›﹛﹜『』〖〗［］《》〔〕{}「」【】︵︷︿︹︽*﹁﹃︻︶︸﹀︺︾ˉ﹂﹄︼☩☨☦✞✛✜✝✙✠✚†‡◉○◌◍◎●◐◑◒◓◔◕◖◗❂☢⊗⊙◘◙◍⅟½⅓⅕⅙⅛⅔⅖⅚⅜¾⅗⅝⅞⅘≂≃≄≅≆≇≈≉≊≋≌\n\n≍≎≏≐≑≒≓≔≕≖≗≘≙≚≛≜≝≞≟≠≡≢≣≤≥≦≧≨≩⊰⊱⋛⋚∫∬∭∮∯∰∱∲∳%℅‰‱㊣㊎㊍㊌㊋㊏㊐㊊㊚㊛㊤㊥\n\n㊦㊧㊨㊒㊞㊑㊒㊓㊔㊕㊖㊗㊘㊜㊝㊟㊠㊡㊢㊩㊪㊫㊬㊭㊮㊯㊰㊙ ㉿ 囍 ♔♕♖♗♘♙♚♛♜♝♞♟ℂℍℕℙℚℝℤℬℰℯℱℊℋℎℐℒℓℳℴ℘ℛℭ℮ℌℑℜℨ♪♫♩♬♭♮♯°øⒶ☮✌☪✡☭✯ 卐 ✐✎✏\n\n✑✒✍✉✁✂✃✄✆✉☎☏➟➡➢➣➤➥➦➧➨➚➘➙➛➜➝➞➸♐➲➳⏎➴➵➶➷➸➹➺➻➼➽←↑→↓↔↕↖↗↘↙↚↛↜↝\n\n↞↟↠↡↢↣↤↥↦↧↨➫➬➩➪➭➮➯➱↩↪↫↬↭↮↯↰↱↲↳↴↵↶↷↸↹↺↻↼↽↾↿⇀⇁⇂⇃⇄⇅⇆⇇⇈⇉⇊⇋⇌⇍⇎⇏⇐⇑⇒⇓⇔⇕\n\n⇖⇗⇘⇙⇚⇛⇜⇝⇞⇟⇠⇡⇢⇣⇤⇥⇦⇧⇨⇩⇪➀➁➂➃➄➅➆➇➈➉➊➋➌➍➎➏➐➑➒➓㊀㊁㊂㊃㊄㊅㊆㊇㊈㊉ⒶⒷⒸⒹⒺⒻⒼⒽⒾⒿⓀⓁⓂⓃⓄⓅⓆⓇⓈⓉⓊⓋⓌⓍⓎⓏⓐⓑⓒⓓⓔⓕⓖⓗⓘⓙⓚⓛⓜⓝⓞⓟⓠⓡ\n\nⓢⓣⓤⓥⓦⓧⓨⓩ⒜⒝⒞⒟⒠⒡⒢⒣⒤⒥⒦⒧⒨⒩⒪⒫⒬⒭⒮⒯⒰⒱⒲⒳⒴⒵ⅠⅡⅢⅣⅤ\n\nⅥⅦⅧⅨⅩⅪⅫⅬⅭⅮⅯⅰⅱⅲⅳⅴⅵⅶⅷⅸⅹⅺⅻⅼⅽⅾⅿ┌┍┎┏┐┑┒┓└┕┖┗┘┙┚┛├┝┞┟┠┡┢┣┤┥┦┧┨┩┪┫\n┬┭┮┯┰┱┲┳┴┵┶┷┸┹┺┻┼┽\n┾┿╀╁╂╃╄╅╆╇╈╉╊╋╌╍╎╏\n═║╒╓╔╕╖╗╘╙╚╛╜╝╞╟╠╡╢╣╤╥╦╧╨╩╪╫╬◤◥◄►▶◀◣◢▲\n\n▼◥▸◂▴▾△▽▷◁⊿▻◅▵▿▹◃❏❐❑❒▀▁▂▃▄▅▆▇▉▊▋█▌▍▎▏▐░▒▓▔▕■□▢▣▤▥▦▧\n\n▨▩▪▫▬▭▮▯ ㋀㋁㋂㋃㋄㋅㋆㋇㋈㋉㋊㋋㏠㏡㏢㏣㏤㏥㏦㏧㏨㏩㏪㏫㏬㏭㏮㏯㏰㏱㏲\n\n㏳㏴㏵㏶㏷㏸㏹㏺㏻㏼㏽㏾㍙㍚㍛㍜㍝㍞㍟㍠㍡㍢㍣㍤㍥㍦㍧㍨㍩㍪㍫㍬㍭㍮㍯㍰㍘\n\n☰☲☱☴☵☶☳☷☯</code></pre></div></figure>\n<h2 id=\"特殊符号\">特殊符号</h2>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-none\"><code class=\"language-none\">♠♣♧♡♥❤❥❣♂♀✲☀☼☾☽◐◑☺☻☎☏✿❀№↑↓←→√×÷★℃℉°◆◇⊙■□△▽¿½☯✡ ㍿卍卐 ♂♀✚〓㎡♪♫♩♬\n\n㊚㊛囍㊒㊖ Φ♀♂‖KaTeX parse error: Expected ‘EOF’, got ‘&amp;’ at position 3: @*&amp;̲#※卍卐 Ψ♫♬♭♩♪♯♮⌒¶∮…</code></pre></div></figure>\n<h2 id=\"编号序号\">编号序号</h2>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-none\"><code class=\"language-none\">①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮⑯⑰⑱⑲⑳⓪\n\n❶❷❸❹❺❻❼❽❾❿⓫⓬⓭⓮⓯⓰⓱⓲⓳⓴\n\n㊀㊁㊂㊃㊄㊅㊆㊇㊈㊉㈠㈡㈢㈣㈤㈥㈦㈧㈨㈩⑴⑵⑶⑷⑸⑹⑺⑻⑼⑽⑾⑿⒀⒁⒂⒃⒄⒅⒆⒇\n\n⒈⒉⒊⒋⒌⒍⒎⒏⒐⒑⒒⒓⒔⒕⒖⒗⒘⒙⒚⒛\n\nⅠⅡⅢⅣⅤⅥⅦⅧⅨⅩⅪⅫⅰⅱⅲⅳⅴⅵⅶⅷⅸⅹ\n\nⒶⒷⒸⒹⒺⒻⒼⒽⒾⒿⓀⓁⓂⓃⓄⓅⓆⓇⓈⓉⓊⓋⓌⓍⓎⓏⓐⓑⓒⓓⓔⓕⓖⓗⓘⓙⓚⓛⓜⓝⓞⓟⓠⓡⓢⓣⓤⓥⓦⓧⓨⓩ\n\n⒜⒝⒞⒟⒠⒡⒢⒣⒤⒥⒦⒧⒨⒩⒪⒫⒬⒭⒮⒯⒰⒱⒲⒳⒴⒵</code></pre></div></figure>\n<h2 id=\"数学符号\">数学符号</h2>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-none\"><code class=\"language-none\">﹢﹣×÷±/=≌∽≦≧≒ ﹤﹥ ≈≡≠=≤≥&lt;&gt;≮≯∷∶∫∮∝∞∧∨∑∏∪∩∈∵∴⊥∥∠⌒⊙√∟⊿㏒㏑%\n\n‰⅟½⅓⅕⅙⅛⅔⅖⅚⅜¾⅗⅝⅞⅘≂≃≄≅≆≇≈≉≊≋≌≍≎≏≐≑≒≓≔≕≖≗≘≙≚≛≜≝≞≟\n\n≠≡≢≣≤≥≦≧≨≩⊰⊱⋛⋚∫∬∭∮∯∰∱∲∳%℅‰‱øØπ</code></pre></div></figure>\n<h2 id=\"爱心符号\">爱心符号</h2>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-none\"><code class=\"language-none\">♥❣ღ♠♡♤❤❥</code></pre></div></figure>\n<h2 id=\"标点符号\">标点符号</h2>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-none\"><code class=\"language-none\">。，、＇：∶；?‘’“”〝〞ˆˇ﹕︰﹔﹖﹑•¨….¸;！´？！～—ˉ ｜‖＂〃｀@﹫¡¿﹏﹋﹌︴\n\n々﹟#﹩$﹠&amp;﹪%*﹡﹢﹦﹤‐￣ ¯―﹨ˆ˜﹍﹎+=&lt;＿*-\\ˇ~﹉﹊\n\n（）〈〉‹›﹛﹜『』〖〗［］《》〔〕{}「」【】\n\n︵︷︿︹︽*﹁﹃︻︶︸﹀︺︾ˉ﹂﹄︼❝❞</code></pre></div></figure>\n<h2 id=\"单位符号\">单位符号</h2>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-none\"><code class=\"language-none\">°′″＄￥〒￠￡％＠℃℉ ﹩﹪‰﹫㎡㏕㎜㎝㎞㏎m³㎎㎏㏄º○¤%$º¹²³</code></pre></div></figure>\n<h2 id=\"货币符号\">货币符号</h2>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-none\"><code class=\"language-none\">€£Ұ₴$₰¢₤¥₳₲₪₵ 元 ₣₱฿¤₡₮₭₩ރ 円 ₢₥₫₦zł﷼₠₧₯₨Kčर₹ƒ₸ ￠</code></pre></div></figure>\n<h2 id=\"箭头符号（含推导-转换符号）\">箭头符号（含推导&amp;转换符号）</h2>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-none\"><code class=\"language-none\">↑↓←→↖↗↘↙↔↕➻➼➽➸➳➺➻➴➵➶➷➹▶►▷◁◀◄«\n\n»➩➪➫➬➭➮➯➱⏎➲➾➔➘➙➚➛➜➝➞➟➠➡➢➣➤➥➦➧➨\n\n↚↛↜↝↞↟↠↠↡↢↣↤↤↥↦↧↨⇄⇅⇆⇇⇈⇉⇊⇋⇌⇍⇎⇏⇐⇑⇒⇓⇔⇖⇗⇘⇙\n\n⇜↩↪↫↬↭↮↯↰↱↲↳↴↵↶↷↸↹☇☈↼↽↾↿⇀⇁⇂⇃⇞⇟⇠⇡⇢⇣⇤⇥⇦⇧⇨⇩⇪↺↻⇚⇛♐</code></pre></div></figure>\n<h2 id=\"符号图案\">符号图案</h2>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-none\"><code class=\"language-none\">✐✎✏✑✒✍✉✁✂✃✄✆✉☎☏☑✓✔√☐☒✗✘ ㄨ ✕✖✖☢☠☣✈★☆✡ 囍㍿ ☯☰☲☱☴☵☶☳☷\n\n☜☞☝✍☚☛☟✌♤♧♡♢♠♣♥♦☀☁☂❄☃♨웃유❖☽☾☪✿♂♀✪✯☭➳ 卍卐 √×■◆●○◐◑✙☺☻\n\n❀⚘♔♕♖♗♘♙♚♛♜♝♞♟♧♡♂♀♠♣♥❤☜☞☎☏⊙◎☺☻☼▧▨♨◐◑↔↕▪▒◊◦▣▤▥▦▩◘◈◇\n\n♬♪♩♭♪ の ★☆→ あぃ￡ Ю〓§♤♥▶¤✲❈✿✲❈➹☀☂☁【】┱┲❣✚✪✣✤✥✦❉❥❦❧❃❂❁❀✄☪☣☢☠☭ღ▶▷◀◁\n\n☀☁☂☃☄★☆☇☈⊙☊☋☌☍ⓛⓞⓥⓔ╬『』∴☀♫♬♩♭♪☆∷﹌の ★◎▶☺☻►◄▧▨♨◐◑↔↕↘▀▄█▌\n\n◦☼♪ の ☆→♧ ぃ￡ ❤▒▬♦◊◦♠♣▣۰•❤•۰►◄▧▨♨◐◑↔↕▪▫☼♦⊙●○①⊕◎Θ⊙¤ ㊣ ★☆♀◆◇◣◢◥▲▼△▽⊿◤◥\n\n✐✌✍✡✓✔✕✖♂♀♥♡☜☞☎☏⊙◎☺☻►◄▧▨♨◐◑↔↕♥♡▪▫☼♦▀▄█▌▐░▒▬♦◊◘◙◦☼♠♣▣▤▥▦▩◘◙◈\n\n♫♬♪♩♭♪✄☪☣☢☠♯♩♪♫♬♭♮☎☏☪♈ºº₪¤큐«»™♂✿♥ 　 ◕‿-｡　｡◕‿◕｡</code></pre></div></figure>\n<h2 id=\"希腊字母\">希腊字母</h2>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-none\"><code class=\"language-none\">ΑΒΓΔΕΖΗΘΙΚΛΜΝΞΟΠΡΣΤΥΦΧΨΩ\n\nαβγδεζνξοπρσηθικλμτυφχψω</code></pre></div></figure>\n<h2 id=\"俄语字母\">俄语字母</h2>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-none\"><code class=\"language-none\">АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвг\n\nдеёжзийклмнопрстуфхцчшщъыьэюя</code></pre></div></figure>\n<h2 id=\"汉语拼音\">汉语拼音</h2>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-none\"><code class=\"language-none\">āáǎàōóǒòēéěèīíǐìūúǔùǖǘǚǜüêɑńňɡ ㄅㄆㄇㄈㄉ\n\nㄊㄋㄌㄍㄎㄏㄐㄑㄒㄓㄔㄕㄖㄗㄘㄙㄚㄛㄜㄝㄞ\n\nㄟㄠㄡㄢㄣㄤㄥㄦㄧㄨㄩ</code></pre></div></figure>\n<h2 id=\"中文字符\">中文字符</h2>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-none\"><code class=\"language-none\">零壹贰叁肆伍陆柒捌玖拾佰仟万亿吉太拍艾分厘毫微\n\n卍卐卄巜弍弎弐朤氺曱甴囍兀々〆のぁ〡〢〣〤〥〦〧〨〩\n\n㊎㊍㊌㊋㊏㊚㊛㊐㊊㊣㊤㊥㊦㊧㊨㊒㊫㊑㊓㊔㊕㊖㊗㊘㊜㊝㊞㊟㊠㊡㊢㊩㊪㊬㊭㊮㊯㊰\n\n㊀㊁㊂㊃㊄㊅㊆㊇㊈㊉</code></pre></div></figure>\n<h2 id=\"日文符号\">日文符号</h2>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-none\"><code class=\"language-none\">ぁあぃいぅうぇえぉおかがきぎくぐけげこごさざしじすずせぜそぞただちぢっつづてで\n\nとどなにぬねのはばぱひびぴふぶぷへべぺほぼぽまみむめもゃやゅゆょよらりるれろゎ\n\nわゐゑをんゔゕゖァアィイゥウェエォオカガキギクグケゲコゴサザシジスズセゼソゾタ\n\nダチヂッツヅテデトドナニヌネノハバパヒビピフブプヘベペホボポマミムメモャヤュユ\n\nョヨラリルレロヮワヰヱヲンヴヵヶヷヸヹヺ・ーヽヾヿ゠ㇰㇱㇲㇳㇴㇵㇶㇷㇸㇹㇺㇻㇼㇽㇾㇿ</code></pre></div></figure>\n<h2 id=\"制表符号\">制表符号</h2>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-none\"><code class=\"language-none\">─ ━│┃╌╍╎╏┄ ┅┆┇┈ ┉┊┋┌┍┎┏┐┑┒┓└ ┕┖┗ ┘┙┚┛├┝┞┟┠┡┢┣ ┤┥┦┧┨┩┪┫┬ ┭ ┮ ┯ ┰ ┱ ┲ ┳\n\n┴ ┵ ┶ ┷ ┸ ┹ ┺ ┻┼ ┽ ┾ ┿ ╀ ╁ ╂ ╃ ╄ ╅ ╆ ╇ ╈ ╉ ╊ ╋ ╪ ╫ ╬═║╒╓╔ ╕╖╗╘╙╚ ╛╜╝╞╟╠ ╡╢╣\n\n╤ ╥ ╦ ╧ ╨ ╩ ╳╔ ╗╝╚ ╬ ═ ╓ ╩ ┠ ┨┯ ┷┏ ┓┗ ┛┳ ⊥ ﹃ ﹄┌ ╮ ╭ ╯╰</code></pre></div></figure>\n<h2 id=\"皇冠符号\">皇冠符号</h2>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-none\"><code class=\"language-none\">♚ 　 ♛ 　 ♝ 　 ♞ 　 ♜ 　 ♟ 　 ♔ 　 ♕ 　 ♗ 　 ♘ 　 ♖ 　 ♟</code></pre></div></figure>\n<h2 id=\"彩色表情符号\">彩色表情符号</h2>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-none\"><code class=\"language-none\">🌹🍀🍎💰📱🌙🍁🍂🍃🌷💎🔪🔫🏀⚽⚡👄👍🔥</code></pre></div></figure>\n<h2 id=\"常用-emoji-符号\">常用 emoji 符号</h2>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-none\"><code class=\"language-none\">😀😁😂😃😄😅😆😉😊😋😎😍😘😗😙😚☺😇😐😑😶😏😣😥😮😯😪😫😴😌😛😜😝😒😓😔😕😲😷😖😞😟😤😢😭😦😧😨😬😰😱😳😵😡😠😈👿👹👺💀👻👽👦👧👨👩👴👵👶👱👮👲👳👷👸💂🎅👰👼💆💇🙍🙎🙅🙆💁🙋🙇🙌🙏👤👥🚶🏃👯💃👫👬👭💏💑👪💪👈👉☝👆👇✌✋👌👍👎✊👊👋👏👐✍👣👀👂👃👅👄💋👓👔👕👖👗👘👙👚👛👜👝🎒💼👞👟👠👡👢👑👒🎩🎓💄💅💍🌂🙈🙉🙊🐵🐒🐶🐕🐩🐺🐱😺😸😹😻😼😽🙀😿😾🐈🐯🐅🐆🐴🐎🐮🐂🐃🐄🐷🐖🐗🐽🐏🐑🐐🐪🐫🐘🐭🐁🐀🐹🐰🐇🐻🐨🐼🐾🐔🐓🐣🐤🐥🐦🐧🐸🐊🐢🐍🐲🐉🐳🐋🐬🐟🐠🐡🐙🐚🐌🐛🐜🐝🐞🦋💐🌸💮🌹🌺🌻🌼🌷🌱🌲🌳🌴🌵🌾🌿🍀🍁🍂🍃🌍🌎🌏🌐🌑🌒🌓🌔🌕🌖🌗🌘🌙🌚🌛🌜☀🌝🌞⭐🌟🌠☁⛅☔⚡❄🔥💧🌊💩🍇🍈🍉🍊🍋🍌🍍🍎🍏🍐🍑🍒🍓🍅🍆🌽🍄🌰🍞🍖🍗🍔🍟🍕🍳🍲🍱🍘🍙🍚🍛🍜🍝🍠🍢🍣🍤🍥🍡🍦🍧🍨🍩🍪🎂🍰🍫🍬🍭🍮🍯🍼☕🍵🍶🍷🍸🍹🍺🍻🍴🎪🎭🎨🎰🚣🛀🎫🏆⚽⚾🏀🏈🏉🎾🎱🎳⛳🎣🎽🎿🏂🏄🏇🏊🚴🚵🎯🎮🎲🎷🎸🎺🎻🎬👾🌋🗻🏠🏡🏢🏣🏤🏥🏦🏨🏩🏪🏫🏬🏭🏯🏰💒🗼🗽⛪⛲🌁🌃🌆🌇🌉🌌🎠🎡🎢🚂🚃🚄🚅🚆🚇🚈🚉🚊🚝🚞🚋🚌🚍🚎🚏🚐🚑🚒🚓🚔🚕🚖🚗🚘🚚🚛🚜🚲⛽🚨🚥🚦🚧⚓⛵🚤🚢✈💺🚁🚟🚠🚡🚀🎑🗿🛂🛃🛄🛅💌💎🔪💈🚪🚽🚿🛁⌛⏳⌚⏰🎈🎉🎊🎎🎏🎐🎀🎁📯📻📱📲☎📞📟📠🔋🔌💻💽💾💿📀🎥📺📷📹📼🔍🔎🔬🔭📡💡🔦🏮📔📕📖📗📘📙📚📓📃📜📄📰📑🔖💰💴💵💶💷💸💳✉📧📨📩📤📥📦📫📪📬📭📮✏✒📝📁📂📅📆📇📈📉📊📋📌📍📎📏📐✂🔒🔓🔏🔐🔑🔨🔫🔧🔩🔗💉💊🚬🔮🚩🎌💦💨💣☠♠♥♦♣🀄🎴🔇🔈🔉🔊📢📣💤💢💬💭♨🌀🔔🔕✡✝🔯📛🔰🔱⭕✅☑✔✖❌❎➕➖➗➰➿〽✳✴❇‼⁉❓❔❕❗©®™🎦🔅🔆💯🔠🔡🔢🔣🔤🅰🆎🅱🆑🆒🆓ℹ🆔Ⓜ🆕🆖🅾🆗🅿🆘🆙🆚🈁🈂🈷🈶🈯 🉐 🈹🈚🈲 🉑 🈸🈴🈳 ㊗㊙ 🈺🈵▪▫◻◼◽◾⬛⬜🔶🔷🔸🔹🔺🔻💠🔲🔳⚪⚫🔴🔵♈♉♊♋♌♍♎♏♐♑♒♓⛎💘❤💓💔💕💖💗💙💚💛💜💝💞💟❣🌿🚧💒☎📟💽⬆↗➡↘⬇↙⬅↖↕↔↩↪⤴⤵🔃🔄🔙🔚🔛🔜🔝🔀🔁🔂▶⏩◀⏪🔼⏫🔽⏬📱📶📳📴♻🏧🚮🚰♿🚹🚺🚻🚼🚾⚠🚸⛔🚫🚳🚭🚯🚱🚷🔞</code></pre></div></figure>\n",
            "tags": [
                "web",
                "emoji"
            ]
        },
        {
            "id": "https://blog.17lai.site/posts/68d3867d/",
            "url": "https://blog.17lai.site/posts/68d3867d/",
            "title": "node 项目从构建到使用 jenkins + docker + nginx + mysql + redis 自动化部署",
            "date_published": "2022-03-16T10:04:02.000Z",
            "content_html": "<h1>概述</h1>\n<p>这都2019年末了，你还不会 docker吗？ 你 low 爆了，我们作为一枚前端，不能说是要精通使用 docker 完成各种事情，但我觉得必须要学会使用 docker 干下面几件事：</p>\n<ol>\n<li>部署前端应用</li>\n<li>部署nginx</li>\n<li>使用docker-compose部署</li>\n<li>在容器之间建立联系</li>\n</ol>\n<p>Docker 可理解为跑在宿主机上的非常精简、小巧、高度浓缩的虚拟机。 它可以将容器里的进程安稳的在宿主机上运行，之前我也有写过一些关于docker的文章，在这我就不做过多的介绍了，如有需要请自行查看我之前的文章即可，接下来我们通过项目来了解并使用 docker</p>\n<h1>Egg.js ？</h1>\n<p>在这里我使用 <code>egg.js</code> 来为大家实操一下项目的部署流程。有人会问 <code>egg.js</code> 是什么？ 我只能回答这是一款专业级的 <code>node</code> 框架。作为一个有梦想的前端，我们有必要去学习一种后端语言，而作为前端 <code>node</code> 的学习成本相对来说比较低的。 <code>egg.js</code> 这个框架在 node 现有框架中也是比较优秀的，如有需要，大家可以自行学习，我们今天的学习主要还是项目的部署流程，在这我就不给大家做过多的介绍。如有需要，请查阅 <a href=\"https://eggjs.org/zh-cn/intro/index.html\" title=\"https://eggjs.org/zh-cn/intro/index.html\">官方文档</a></p>\n<h1>开始前的准备</h1>\n<blockquote>\n<p>docker 与 docker-compose 的安装我就不给大家介绍了。在之前的文章中是有的，也比较详细，作为一位开发人员，我认为这点事情难不倒大家</p>\n</blockquote>\n<h2 id=\"初始化项目\">初始化项目</h2>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-none\"><code class=\"language-none\">$ mkdir egg-example &amp;&amp; cd egg-example\n$ npm init egg --type=simple\n$ npm i\n复制代码</code></pre></div></figure>\n<h2 id=\"创建需要的文件\">创建需要的文件</h2>\n<p>我们需要在项目根目录创建我们所需要的文件</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-none\"><code class=\"language-none\">$ touch Dockerfile\n$ touch docker-compose.yml\n$ setup.sh\n复制代码</code></pre></div></figure>\n<h2 id=\"目录结构\">目录结构</h2>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-none\"><code class=\"language-none\">egg-project\n├── package.json\n├── setup.sh (新建)\n├── Dockerfile (新建)\n├── docker-compose.yml (新建)\n├── app\n|   ├── router.js\n│   ├── controller\n│   |   └── home.js\n│   ├── service (可选)\n│   |   └── user.js\n│   ├── middleware (可选)\n│   |   └── response_time.js\n│   ├── schedule (可选)\n│   |   └── my_task.js\n\n...\n\n复制代码</code></pre></div></figure>\n<h2 id=\"常用指令\">常用指令</h2>\n<p>在开始之前我们要学习下常用的一些指令，看下方：</p>\n<p><img src=\"https://cimg1.17lai.fun/data/2022/03/1120220311110127.webp\" alt=\"\"></p>\n<h1>了解流程</h1>\n<p><img src=\"https://cimg1.17lai.fun/data/2022/03/1120220311110133.webp\" alt=\"\"></p>\n<h1>安装 jenkins</h1>\n<p>在安装jenkins我选择了使用docker-compose<br>\ndocker-compose 是一个用来把 docker 自动化的东西<br>\n有了 docker-compose 你可以把所有繁复的 docker 操作全都一条命令，自动化的完成。</p>\n<h2 id=\"首先我们需要在服务器上创建一个目录机构-具体结构个人自行创建\">首先我们需要在服务器上创建一个目录机构 (具体结构个人自行创建)</h2>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-none\"><code class=\"language-none\">/home/jenkins\n     - docker-compose.yml\n     - jenkins-home\n复制代码</code></pre></div></figure>\n<h2 id=\"接下来我们来编写-docker-compose-yml-安装jenkins\">接下来我们来编写 docker-compose.yml 安装jenkins</h2>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-none\"><code class=\"language-none\">version: '3'                                    # 指定 docker-compose.yml 文件的写法格式\nservices:                                       # 多个容器集合\n  docker_jenkins: \n    user: root                                  # 为了避免一些权限问题 在这我使用了root\n    restart: always                             # 重启方式\n    image: jenkins/jenkins:lts                  # 指定服务所使用的镜像 在这里我选择了 LTS (长期支持)\n    container_name: jenkins                     # 容器名称\n    ports:                                      # 对外暴露的端口定义\n      - '8080:8080'\n      - '50000:50000'\n    volumes:                                    # 卷挂载路径\n      - /home/jenkins/jenkins_home/:/var/jenkins_home   # 这是我们一开始创建的目录挂载到容器内的jenkins_home目录\n      - /var/run/docker.sock:/var/run/docker.sock\n      - /usr/bin/docker:/usr/bin/docker                 # 这是为了我们可以在容器内使用docker命令\n      - /usr/local/bin/docker-compose:/usr/local/bin/docker-compose     # 同样的这是为了使用docker-compose命令\n复制代码</code></pre></div></figure>\n<p>我们需要进入到 jenkins 目录下执行：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-none\"><code class=\"language-none\">$ docker-compose up -d\n复制代码</code></pre></div></figure>\n<h2 id=\"配置\">配置</h2>\n<p>不出意外你现在可以打开你的服务器地址 <a href=\"http://xxxxxxx\" title=\"http://xxxxxxx\">http://xxxxxxx</a>:端口号 就能看到这个界面：</p>\n<p><img src=\"https://cimg1.17lai.fun/data/2022/03/1120220311110139.webp\" alt=\"\"></p>\n<p>打开你所创建的jenkins目录进入到jenkins-home<br>\n/home/jenkins/jenkins-home</p>\n<p><img src=\"https://cimg1.17lai.fun/data/2022/03/1120220311110148.webp\" alt=\"\"></p>\n<p>进入 secrets 目录</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-none\"><code class=\"language-none\">$ cat initialAdminPassword\n复制代码</code></pre></div></figure>\n<p><img src=\"https://cimg1.17lai.fun/data/2022/03/1120220311110209.webp\" alt=\"\"></p>\n<p>然后把里面的文本复制出来填到管理员密码中</p>\n<p><img src=\"https://cimg1.17lai.fun/data/2022/03/1120220311110327.webp\" alt=\"\"></p>\n<p><img src=\"https://cimg1.17lai.fun/data/2022/03/1120220311110215.webp\" alt=\"\"></p>\n<p>接下来需要安装两个插件</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-none\"><code class=\"language-none\">NodeJS Plugin\nPublish Over SSH\n复制代码</code></pre></div></figure>\n<p><img src=\"https://cimg1.17lai.fun/data/2022/03/1120220311110334.webp\" alt=\"\"></p>\n<p><img src=\"https://cimg1.17lai.fun/data/2022/03/1120220311110221.webp\" alt=\"\"></p>\n<p>然后我们滑到最下方</p>\n<p><img src=\"https://cimg1.17lai.fun/data/2022/03/1120220311110228.webp\" alt=\"\"></p>\n<p><img src=\"https://cimg1.17lai.fun/data/2022/03/1120220311110341.webp\" alt=\"\"></p>\n<p><img src=\"https://cimg1.17lai.fun/data/2022/03/1120220311110347.webp\" alt=\"\"></p>\n<p><img src=\"https://cimg1.17lai.fun/data/2022/03/1120220311110235.webp\" alt=\"\"></p>\n<h1>开始我们的操作</h1>\n<h2 id=\"Dockerfile\">Dockerfile</h2>\n<p>我们在开始阶段的时候学过一些常用指令，大家应该一眼就可以看得懂这些命令。 加油！！</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-none\"><code class=\"language-none\">FROM node:10.0-alpine             # 镜像版本\n\n# 设置时区\nRUN apk --update add tzdata \\\n    &amp;&amp; cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime \\\n    &amp;&amp; echo \"Asia/Shanghai\" &gt; /etc/timezone \\\n    &amp;&amp; apk del tzdata\n\n# 创建app目录\nRUN mkdir -p /usr/src/node-app/egg-santak\n\n# 设置工作目录\nWORKDIR /usr/src/node-app/egg-santak\n\n# 拷贝package.json文件到工作目录\n# !!重要：package.json需要单独添加。\n# Docker在构建镜像的时候，是一层一层构建的，仅当这一层有变化时，重新构建对应的层。\n# 如果package.json和源代码一起添加到镜像，则每次修改源码都需要重新安装npm模块，这样木有必要。\n# 所以，正确的顺序是: 添加package.json；安装npm模块；添加源代码。\nCOPY package.json /usr/src/node-app/egg-santak/package.json\n\n# 安装npm依赖(使用淘宝的镜像源)\n# 如果使用的境外服务器，无需使用淘宝的镜像源，即改为`RUN npm i`。\nRUN npm i --registry=https://registry.npm.taobao.org\n\n# 拷贝所有源代码到工作目录\nCOPY . /usr/src/node-app/egg-santak\n\n# 暴露容器端口\nEXPOSE 7001\n\n# 启动node应用\nCMD npm start\n复制代码</code></pre></div></figure>\n<h2 id=\"在服务器中创建我们所需要挂载的数据卷\">在服务器中创建我们所需要挂载的数据卷</h2>\n<p><img src=\"https://cimg1.17lai.fun/data/2022/03/1120220311110241.webp\" alt=\"\"></p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-none\"><code class=\"language-none\"># nginx\n$ mkdir -p nginx/conf.d nginx/logs\n\n# mysql\n$ mkdir mysql\n\n# redis\n$ mkdir redis\n复制代码</code></pre></div></figure>\n<p>然后进入 <code>nginx/conf.d</code> 文件夹中 创建一个后缀为 <code>conf</code> 的文件</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-none\"><code class=\"language-none\">$ cd nginx/conf.d\n$ touch default.conf\n$ vim default.conf\n复制代码</code></pre></div></figure>\n<p>写入以下内容：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-none\"><code class=\"language-none\">server {\n  listen 80;\n  listen [::]:80;\n  server_tokens off;\n\n  root /var/www/html;\n  index index.html index.htm;\n\n  # 修改为自己的域名\n  server_name api.lovelp.xin;\n\n  # 访问 / 路径时执行反向代理\n  location / {\n    # 这里 nodejs 是 node 容器名\n    proxy_pass http://nodejs:7001;\n    proxy_set_header X-Real-IP $remote_addr;\n    proxy_set_header Host $host;\n    # 后端的Web服务器可以通过 X-Forwarded-For 获取用户真实 IP\n    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n    # 允许客户端请求的最大单文件字节数\n    client_max_body_size 15M;\n    # 缓冲区代理缓冲用户端请求的最大字节数\n    client_body_buffer_size 128k;\n  }\n}\n复制代码</code></pre></div></figure>\n<h2 id=\"docker-compose-yml\">docker-compose.yml</h2>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-none\"><code class=\"language-none\">version: '3'\n\nservices:\n  santak_redis:\n    image: redis:3                  # 指定服务镜像\n    container_name: santak_redis    # 容器名称\n    restart: always                 # 重启方式\n    hostname: redis\n    command: redis-server /usr/local/etc/redis/redis.conf --requirepass 123456  --appendonly yes\n    volumes:                        # 挂载数据卷\n      - /root/redis/redis.conf:/usr/local/etc/redis/redis.conf\n    ports:                          # 映射端口\n      - \"6379:6379\"     \n    networks:                       # 加入指定网络\n      - app-network\n\n  santak_nginx:\n    image: nginx:stable-alpine      # 指定服务镜像\n    container_name: santak_nginx    # 容器名称\n    restart: always                 # 重启方式\n    ports:                          # 映射端口\n      - \"80:80\"\n    volumes:                        # 挂载数据卷\n      - /etc/localtime:/etc/localtime\n      - /root/nginx/conf.d:/etc/nginx/conf.d\n      - /root/nginx/logs:/var/log/nginx\n    depends_on:                     # 启动顺序\n      - nodejs\n    networks:                       # 加入指定网络\n      - app-network\n\n  santak_mysql:\n    image: mysql:5.7\n    container_name: santak_mysql\n    restart: always\n    ports:                          # 映射端口\n      - \"3306:3306\"\n    environment:\n      - MYSQL_ROOT_PASSWORD=root\n      - MYSQL_USER=lovelp           # 创建lovelp用户\n      - MYSQL_PASSWORD=mm123321     # 设置lovelp用户的密码\n      - MYSQL_DATABASE=santak       # 创建初始数据库\n      - TZ=Asia/Shanghai            # 设置时区\n    volumes:                        # 挂载数据卷\n      - /root/mysql:/var/lib/mysql  # 为了数据持久化\n    command: --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci\n    networks:                       # 加入指定网络\n      - app-network \n\n  nodejs:\n    build:                          # 这里指的是我们刚刚撸的 Dockerfile 文件\n      context: .                    \n      dockerfile: Dockerfile\n    image: nodejs                   # 镜像名称\n    container_name: nodejs          # 容器名称\n    restart: always                 # 重启方式\n    depends_on:                     # 启动顺序\n      - santak_redis\n      - santak_mysql\n    links:                          # 容器连接\n      - santak_redis:santak_redis\n      - santak_mysql:santak_mysql\n    networks:                       # 加入指定网络\n      - app-network\n\nvolumes:\n  certbot-etc:\n  certbot-var:\n\nnetworks:  # 实现通信\n  app-network:\n    driver: bridge\n复制代码</code></pre></div></figure>\n<h2 id=\"在项目中的使用\">在项目中的使用</h2>\n<p><img src=\"https://cimg1.17lai.fun/data/2022/03/1120220311110359.webp\" alt=\"\"></p>\n<h2 id=\"setup-sh\"><a href=\"http://setup.sh\">setup.sh</a></h2>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-none\"><code class=\"language-none\">#!/usr/bin/env bash\n#image_version=`date +%Y%m%d%H%M`;\n\n# 关闭容器\ndocker-compose stop || true;\n# 删除容器\ndocker-compose down || true;\n# 构建镜像\ndocker-compose build;\n# 启动并后台运行\ndocker-compose up -d;\n# 查看日志\ndocker logs nodejs;\n# 对空间进行自动清理\ndocker system prune -a -f\n\n复制代码</code></pre></div></figure>\n<h1>jenkins 创建项目</h1>\n<p><img src=\"https://cimg1.17lai.fun/data/2022/03/1120220311110247.webp\" alt=\"\"></p>\n<p><img src=\"https://cimg1.17lai.fun/data/2022/03/1120220311110248.webp\" alt=\"\"></p>\n<p><img src=\"https://cimg1.17lai.fun/data/2022/03/1120220311110254.webp\" alt=\"\"></p>\n<p><img src=\"https://cimg1.17lai.fun/data/2022/03/1120220311110409.webp\" alt=\"\"></p>\n<p>最后我们就可以愉快的 <code>Build Now</code> 了</p>\n<p><img src=\"https://cimg1.17lai.fun/data/2022/03/1120220311110415.webp\" alt=\"\"></p>\n<p>在这里我选择的是手动构建。其实jenkins有很多可配置项，比如自动化构建啥的，兴趣使然，大家自行摸索，谢谢大家</p>\n<h2 id=\"整理转载\">整理转载:</h2>\n<ul>\n<li><a href=\"https://juejin.cn/post/6844904006184091662\">掘金</a></li>\n</ul>\n",
            "tags": [
                "docker",
                "web",
                "ci/cd",
                "node",
                "jenkins"
            ]
        },
        {
            "id": "https://blog.17lai.site/posts/80906b88/",
            "url": "https://blog.17lai.site/posts/80906b88/",
            "title": "http 错误代码表",
            "date_published": "2021-10-06T11:25:00.000Z",
            "content_html": "<p>所有 HTTP 状态代码及其定义。<br>\n　代码&nbsp;&nbsp;指示&nbsp;&nbsp;<br>\n2xx&nbsp;&nbsp;成功&nbsp;&nbsp;<br>\n200&nbsp;&nbsp;正常；请求已完成。&nbsp;&nbsp;<br>\n201&nbsp;&nbsp;正常；紧接 POST 命令。&nbsp;&nbsp;<br>\n202&nbsp;&nbsp;正常；已接受用于处理，但处理尚未完成。&nbsp;&nbsp;<br>\n203&nbsp;&nbsp;正常；部分信息 — 返回的信息只是一部分。&nbsp;&nbsp;<br>\n204&nbsp;&nbsp;正常；无响应 — 已接收请求，但不存在要回送的信息。&nbsp;&nbsp;<br>\n3xx&nbsp;&nbsp;重定向&nbsp;&nbsp;<br>\n301&nbsp;&nbsp;已移动 — 请求的数据具有新的位置且更改是永久的。&nbsp;&nbsp;<br>\n302&nbsp;&nbsp;已找到 — 请求的数据临时具有不同 URI。&nbsp;&nbsp;<br>\n303&nbsp;&nbsp;请参阅其它 — 可在另一 URI 下找到对请求的响应，且应使用 GET 方法检索此响应。&nbsp;&nbsp;<br>\n304&nbsp;&nbsp;未修改 — 未按预期修改文档。&nbsp;&nbsp;<br>\n305&nbsp;&nbsp;使用代理 — 必须通过位置字段中提供的代理来访问请求的资源。&nbsp;&nbsp;<br>\n306&nbsp;&nbsp;未使用 — 不再使用；保留此代码以便将来使用。&nbsp;&nbsp;<br>\n4xx&nbsp;&nbsp;客户机中出现的错误&nbsp;&nbsp;<br>\n400&nbsp;&nbsp;错误请求 — 请求中有语法问题，或不能满足请求。&nbsp;&nbsp;<br>\n401&nbsp;&nbsp;未授权 — 未授权客户机访问数据。&nbsp;&nbsp;<br>\n402&nbsp;&nbsp;需要付款 — 表示计费系统已有效。&nbsp;&nbsp;<br>\n403&nbsp;&nbsp;禁止 — 即使有授权也不需要访问。&nbsp;&nbsp;<br>\n404&nbsp;&nbsp;找不到 — 服务器找不到给定的资源；文档不存在。&nbsp;&nbsp;<br>\n407&nbsp;&nbsp;代理认证请求 — 客户机首先必须使用代理认证自身。&nbsp;&nbsp;<br>\n415&nbsp;&nbsp;介质类型不受支持 — 服务器拒绝服务请求，因为不支持请求实体的格式。&nbsp;&nbsp;<br>\n5xx&nbsp;&nbsp;服务器中出现的错误&nbsp;&nbsp;<br>\n500&nbsp;&nbsp;内部错误 — 因为意外情况，服务器不能完成请求。&nbsp;&nbsp;<br>\n501&nbsp;&nbsp;未执行 — 服务器不支持请求的工具。&nbsp;&nbsp;<br>\n502&nbsp;&nbsp;错误网关 — 服务器接收到来自上游服务器的无效响应。&nbsp;&nbsp;<br>\n503&nbsp;&nbsp;无法获得服务 — 由于临时过载或维护，服务器无法处理请求。</p>\n<hr>\n<p>HTTP&nbsp;400&nbsp;-&nbsp;请求无效&nbsp;<br>\nHTTP&nbsp;401.1&nbsp;-&nbsp;未授权：登录失败&nbsp;<br>\nHTTP&nbsp;401.2&nbsp;-&nbsp;未授权：服务器配置问题导致登录失败&nbsp;<br>\nHTTP&nbsp;401.3&nbsp;-&nbsp;ACL&nbsp;禁止访问资源&nbsp;<br>\nHTTP&nbsp;401.4&nbsp;-&nbsp;未授权：授权被筛选器拒绝&nbsp;<br>\nHTTP&nbsp;401.5&nbsp;-&nbsp;未授权：ISAPI&nbsp;或&nbsp;CGI&nbsp;授权失败&nbsp;&nbsp;<br>\nHTTP&nbsp;403&nbsp;-&nbsp;禁止访问&nbsp;<br>\nHTTP&nbsp;403&nbsp;-&nbsp;对&nbsp;Internet&nbsp;服务管理器&nbsp;(HTML)&nbsp;的访问仅限于&nbsp;Localhost&nbsp;<br>\nHTTP&nbsp;403.1&nbsp;禁止访问：禁止可执行访问&nbsp;<br>\nHTTP&nbsp;403.2&nbsp;-&nbsp;禁止访问：禁止读访问&nbsp;<br>\nHTTP&nbsp;403.3&nbsp;-&nbsp;禁止访问：禁止写访问&nbsp;<br>\nHTTP&nbsp;403.4&nbsp;-&nbsp;禁止访问：要求&nbsp;SSL&nbsp;<br>\nHTTP&nbsp;403.5&nbsp;-&nbsp;禁止访问：要求&nbsp;SSL&nbsp;128&nbsp;<br>\nHTTP&nbsp;403.6&nbsp;-&nbsp;禁止访问：IP&nbsp;地址被拒绝&nbsp;<br>\nHTTP&nbsp;403.7&nbsp;-&nbsp;禁止访问：要求客户证书&nbsp;<br>\nHTTP&nbsp;403.8&nbsp;-&nbsp;禁止访问：禁止站点访问&nbsp;<br>\nHTTP&nbsp;403.9&nbsp;-&nbsp;禁止访问：连接的用户过多&nbsp;<br>\nHTTP&nbsp;403.10&nbsp;-&nbsp;禁止访问：配置无效&nbsp;<br>\nHTTP&nbsp;403.11&nbsp;-&nbsp;禁止访问：密码更改&nbsp;<br>\nHTTP&nbsp;403.12&nbsp;-&nbsp;禁止访问：映射器拒绝访问&nbsp;<br>\nHTTP&nbsp;403.13&nbsp;-&nbsp;禁止访问：客户证书已被吊销&nbsp;<br>\nHTTP&nbsp;403.15&nbsp;-&nbsp;禁止访问：客户访问许可过多&nbsp;<br>\nHTTP&nbsp;403.16&nbsp;-&nbsp;禁止访问：客户证书不可信或者无效&nbsp;<br>\nHTTP&nbsp;403.17&nbsp;-&nbsp;禁止访问：客户证书已经到期或者尚未生效&nbsp;<br>\nHTTP&nbsp;404.1&nbsp;-&nbsp;无法找到&nbsp;Web&nbsp;站点&nbsp;<br>\nHTTP&nbsp;404&nbsp;-&nbsp;无法找到文件&nbsp;<br>\nHTTP&nbsp;405&nbsp;-&nbsp;资源被禁止&nbsp;<br>\nHTTP&nbsp;406&nbsp;-&nbsp;无法接受&nbsp;<br>\nHTTP&nbsp;407&nbsp;-&nbsp;要求代理身份验证&nbsp;<br>\nHTTP&nbsp;410&nbsp;-&nbsp;永远不可用&nbsp;<br>\nHTTP&nbsp;412&nbsp;-&nbsp;先决条件失败&nbsp;<br>\nHTTP&nbsp;414&nbsp;-&nbsp;请求&nbsp;-&nbsp;URI&nbsp;太长&nbsp;<br>\nHTTP&nbsp;500&nbsp;-&nbsp;内部服务器错误&nbsp;<br>\nHTTP&nbsp;500.100&nbsp;-&nbsp;内部服务器错误&nbsp;-&nbsp;ASP&nbsp;错误&nbsp;<br>\nHTTP&nbsp;500-11&nbsp;服务器关闭&nbsp;<br>\nHTTP&nbsp;500-12&nbsp;应用程序重新启动&nbsp;<br>\nHTTP&nbsp;500-13&nbsp;-&nbsp;服务器太忙&nbsp;<br>\nHTTP&nbsp;500-14&nbsp;-&nbsp;应用程序无效&nbsp;<br>\nHTTP&nbsp;500-15&nbsp;-&nbsp;不允许请求&nbsp;global.asa&nbsp;<br>\nError&nbsp;501&nbsp;-&nbsp;未实现&nbsp;<br>\nHTTP&nbsp;502&nbsp;-&nbsp;网关错误</p>\n",
            "tags": [
                "web",
                "http"
            ]
        },
        {
            "id": "https://blog.17lai.site/posts/448f849b/",
            "url": "https://blog.17lai.site/posts/448f849b/",
            "title": "1.5 万字 CSS 基础拾遗（核心知识、常见需求）",
            "date_published": "2021-09-15T11:25:00.000Z",
            "content_html": "<h2 id=\"1-5-万字-CSS-基础拾遗（核心知识、常见需求）\">1.5 万字 CSS 基础拾遗（核心知识、常见需求）</h2>\n<p>本篇文章围绕了 CSS 的核心知识点和项目中常见的需求来展开。虽然行文偏长，但偏基础，适合初级中级前端阅读，阅读的时候请适当跳过已经掌握的部分。</p>\n<p>这篇文章断断续续写了比较久，也参考了许多优秀的文章，但或许文章里还是存在不好或不对的地方，请多多指教，可以评论里直接提出来哈。</p>\n<p>小tip：后续内容更精彩哦。</p>\n<p><img src=\"https://cimg1.17lai.fun/data/2021/09/1220210912192327.png\" alt=\"\"></p>\n<h2 id=\"核心概念和知识点\">核心概念和知识点</h2>\n<h3 id=\"语法\">语法</h3>\n<p>CSS 的核心功能是将 CSS 属性设定为特定的值。一个属性与值的键值对被称为<strong>声明</strong>（declaration）。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-css\" data-language=\"css\"><code class=\"language-css\">color: red;  </code></pre></div></figure>\n<p>而如果将一个或者多个声明用 <code>{}</code> 包裹起来后，那就组成了一个<strong>声明块</strong>（declaration block）。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-css\" data-language=\"css\"><code class=\"language-css\">{  \n    color: red;  \n    text-align: center;  \n}  </code></pre></div></figure>\n<p>声明块如果需要作用到对应的 HTML 元素，那还需要加上<strong>选择器</strong>。选择器和声明块组成了<strong>CSS 规则集</strong>（CSS ruleset），常简称为 CSS 规则。</p>\n<p><img src=\"https://cimg1.17lai.fun/data/2021/09/1420210914005346.png\" alt=\"\"></p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-css\" data-language=\"css\"><code class=\"language-css\">span {  \n    color: red;  \n    text-align: center;  \n}  </code></pre></div></figure>\n<blockquote>\n<p>“</p>\n<p>规则集中最后一条声明可以省略分号，但是并不建议这么做，因为容易出错。</p>\n</blockquote>\n<p>CSS 中的<strong>注释</strong>：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-css\" data-language=\"css\"><code class=\"language-css\">/* 单行注释 */\n\n/*  \n    多行  \n    注释  \n*/</code></pre></div></figure>\n<p>在 CSS 文件中，除了注释、CSS 规则集以及 @规则 外，定义的一些别的东西都将被浏览器忽略。</p>\n<h3 id=\"规则\">@规则</h3>\n<p>CSS 规则是样式表的主体，通常样式表会包括大量的规则列表。但有时候也需要在样式表中包括其他的一些信息，比如字符集，导入其它的外部样式表，字体等，这些需要专门的语句表示。</p>\n<p>而 @规则 就是这样的语句。CSS 里包含了以下 @规则：</p>\n<ul>\n<li>\n<p>@namespace 告诉 CSS 引擎必须考虑XML命名空间。</p>\n</li>\n<li>\n<p>@media, 如果满足媒体查询的条件则条件规则组里的规则生效。</p>\n</li>\n<li>\n<p>@page, 描述打印文档时布局的变化.</p>\n</li>\n<li>\n<p>@font-face, 描述将下载的外部的字体。</p>\n</li>\n<li>\n<p>@keyframes, 描述 CSS 动画的关键帧。</p>\n</li>\n<li>\n<p>@document, 如果文档样式表满足给定条件则条件规则组里的规则生效。 (推延至 CSS Level 4 规范)</p>\n</li>\n</ul>\n<p>除了以上这几个之外，下面还将对几个比较生涩的 @规则 进行介绍。</p>\n<h4 id=\"charset\">@charset</h4>\n<p>@charset[1] 用于定义样式表使用的字符集。它必须是样式表中的第一个元素。如果有多个 <code>@charset</code> 被声明，只有第一个会被使用，而且不能在HTML元素或HTML页面的 <code>&lt;style&gt;</code> 元素内使用。</p>\n<p>注意：值必须是双引号包裹，且和</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-css\" data-language=\"css\"><code class=\"language-css\">@charset \"UTF-8\";  </code></pre></div></figure>\n<p>平时写样式文件都没写 @charset 规则，那这个 CSS 文件到底是用的什么字符编码的呢？</p>\n<p>某个样式表文件到底用的是什么字符编码，浏览器有一套识别顺序（优先级由高到低）：</p>\n<ul>\n<li>\n<p>文件开头的 Byte order mark[2] 字符值，不过一般编辑器并不能看到文件头里的 BOM 值；</p>\n</li>\n<li>\n<p>HTTP 响应头里的 <code>content-type</code> 字段包含的 <code>charset</code> 所指定的值，比如：</p>\n<p><code>Content-Type: text/css; charset=utf-8  </code><br>\n`</p>\n</li>\n<li>\n<p>CSS 文件头里定义的 @charset 规则里指定的字符编码；</p>\n</li>\n<li>\n<p><code>&lt;link&gt;</code> 标签里的 charset 属性，该条已在 HTML5 中废除；</p>\n</li>\n<li>\n<p>默认是 <code>UTF-8</code>。</p>\n</li>\n</ul>\n<h4 id=\"import\">@import</h4>\n<p>@import[3] 用于告诉 CSS 引擎引入一个外部样式表。</p>\n<p>link 和 @import 都能导入一个样式文件，它们有什么区别嘛？</p>\n<ul>\n<li>\n<p>link 是 HTML 标签，除了能导入 CSS 外，还能导入别的资源，比如图片、脚本和字体等；而 @import 是 CSS 的语法，只能用来导入 CSS；</p>\n</li>\n<li>\n<p>link 导入的样式会在页面加载时同时加载，@import 导入的样式需等页面加载完成后再加载；</p>\n</li>\n<li>\n<p>link 没有兼容性问题，@import 不兼容 ie5 以下；</p>\n</li>\n<li>\n<p>link 可以通过 JS 操作 DOM 动态引入样式表改变样式，而@import不可以。</p>\n</li>\n</ul>\n<h4 id=\"supports\">@supports</h4>\n<p>@supports[4] 用于查询特定的 CSS 是否生效，可以结合 not、and 和 or 操作符进行后续的操作。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-css\" data-language=\"css\"><code class=\"language-css\">/* 如果支持自定义属性，则把 body 颜色设置为变量 varName 指定的颜色 */  \n@supports (--foo: green) {  \n    body {  \n        color: var(--varName);  \n    }  \n}  </code></pre></div></figure>\n<h3 id=\"层叠性\">层叠性</h3>\n<p>层叠样式表，这里的层叠怎么理解呢？其实它是 CSS 中的核心特性之一，用于合并来自多个源的属性值的算法。比如说针对某个 HTML 标签，有许多的 CSS 声明都能作用到的时候，那最后谁应该起作用呢？层叠性说的大概就是这个。</p>\n<p>针对不同源的样式，将按照如下的顺序进行层叠，越往下优先级越高：</p>\n<ul>\n<li>\n<p>用户代理样式表中的声明(例如，浏览器的默认样式，在没有设置其他样式时使用)。</p>\n</li>\n<li>\n<p>用户样式表中的常规声明(由用户设置的自定义样式。由于 Chrome 在很早的时候就放弃了用户样式表的功能，所以这里将不再考虑它的排序。)。</p>\n</li>\n<li>\n<p>作者样式表中的常规声明(这些是我们 Web 开发人员设置的样式)。</p>\n</li>\n<li>\n<p>作者样式表中的 !important 声明。</p>\n</li>\n<li>\n<p>用户样式表中的 !important 声明S。</p>\n</li>\n</ul>\n<p>理解层叠性的时候需要结合 CSS 选择器的优先级以及继承性来理解。比如针对同一个选择器，定义在后面的声明会覆盖前面的；作者定义的样式会比默认继承的样式优先级更高。</p>\n<h3 id=\"选择器\">选择器</h3>\n<p>CSS 选择器无疑是其核心之一，对于基础选择器以及一些常用伪类必须掌握。下面列出了常用的选择器。 想要获取更多选择器的用法可以看 MDN CSS Selectors[5]。</p>\n<h4 id=\"基础选择器\">基础选择器</h4>\n<ul>\n<li>\n<p>标签选择器：<code>h1</code></p>\n</li>\n<li>\n<p>类选择器：<code>.checked</code></p>\n</li>\n<li>\n<p>ID 选择器：<code>#picker</code></p>\n</li>\n<li>\n<p>通配选择器：<code>*</code></p>\n</li>\n</ul>\n<p><strong>属性选择器</strong></p>\n<ul>\n<li>\n<p><code>[attr]</code>：指定属性的元素；</p>\n</li>\n<li>\n<p><code>[attr=val]</code>：属性等于指定值的元素；</p>\n</li>\n<li>\n<p><code>[attr*=val]</code>：属性包含指定值的元素；</p>\n</li>\n<li>\n<p><code>[attr^=val]</code> ：属性以指定值开头的元素；</p>\n</li>\n<li>\n<p><code>[attr$=val]</code>：属性以指定值结尾的元素；</p>\n</li>\n<li>\n<p><code>[attr~=val]</code>：属性包含指定值(完整单词)的元素(不推荐使用)；</p>\n</li>\n<li>\n<p><code>[attr|=val]</code>：属性以指定值(完整单词)开头的元素(不推荐使用)；</p>\n</li>\n</ul>\n<h4 id=\"组合选择器\">组合选择器</h4>\n<ul>\n<li>\n<p>相邻兄弟选择器：<code>A + B</code></p>\n</li>\n<li>\n<p>普通兄弟选择器：<code>A ~ B</code></p>\n</li>\n<li>\n<p>子选择器：<code>A &gt; B</code></p>\n</li>\n<li>\n<p>后代选择器：<code>A B</code></p>\n</li>\n</ul>\n<h4 id=\"伪类\">伪类</h4>\n<p><strong>条件伪类</strong></p>\n<ul>\n<li>\n<p><code>:lang()</code>：基于元素语言来匹配页面元素；</p>\n</li>\n<li>\n<p><code>:dir()</code>：匹配特定文字书写方向的元素；</p>\n</li>\n<li>\n<p><code>:has()</code>：匹配包含指定元素的元素；</p>\n</li>\n<li>\n<p><code>:is()</code>：匹配指定选择器列表里的元素；</p>\n</li>\n<li>\n<p><code>:not()</code>：用来匹配不符合一组选择器的元素；</p>\n</li>\n</ul>\n<p><strong>行为伪类</strong></p>\n<ul>\n<li>\n<p><code>:active</code>：鼠标激活的元素；</p>\n</li>\n<li>\n<p><code>:hover</code>： 鼠标悬浮的元素；</p>\n</li>\n<li>\n<p><code>::selection</code>：鼠标选中的元素；</p>\n</li>\n</ul>\n<p><strong>状态伪类</strong></p>\n<ul>\n<li>\n<p><code>:target</code>：当前锚点的元素；</p>\n</li>\n<li>\n<p><code>:link</code>：未访问的链接元素；</p>\n</li>\n<li>\n<p><code>:visited</code>：已访问的链接元素；</p>\n</li>\n<li>\n<p><code>:focus</code>：输入聚焦的表单元素；</p>\n</li>\n<li>\n<p><code>:required</code>：输入必填的表单元素；</p>\n</li>\n<li>\n<p><code>:valid</code>：输入合法的表单元素；</p>\n</li>\n<li>\n<p><code>:invalid</code>：输入非法的表单元素；</p>\n</li>\n<li>\n<p><code>:in-range</code>：输入范围以内的表单元素；</p>\n</li>\n<li>\n<p><code>:out-of-range</code>：输入范围以外的表单元素；</p>\n</li>\n<li>\n<p><code>:checked</code>：选项选中的表单元素；</p>\n</li>\n<li>\n<p><code>:optional</code>：选项可选的表单元素；</p>\n</li>\n<li>\n<p><code>:enabled</code>：事件启用的表单元素；</p>\n</li>\n<li>\n<p><code>:disabled</code>：事件禁用的表单元素；</p>\n</li>\n<li>\n<p><code>:read-only</code>：只读的表单元素；</p>\n</li>\n<li>\n<p><code>:read-write</code>：可读可写的表单元素；</p>\n</li>\n<li>\n<p><code>:blank</code>：输入为空的表单元素；</p>\n</li>\n<li>\n<p><code>:current()</code>：浏览中的元素；</p>\n</li>\n<li>\n<p><code>:past()</code>：已浏览的元素；</p>\n</li>\n<li>\n<p><code>:future()</code>：未浏览的元素；</p>\n</li>\n</ul>\n<p><strong>结构伪类</strong></p>\n<ul>\n<li>\n<p><code>:root</code>：文档的根元素；</p>\n</li>\n<li>\n<p><code>:empty</code>：无子元素的元素；</p>\n</li>\n<li>\n<p><code>:first-letter</code>：元素的首字母；</p>\n</li>\n<li>\n<p><code>:first-line</code>：元素的首行；</p>\n</li>\n<li>\n<p><code>:nth-child(n)</code>：元素中指定顺序索引的元素；</p>\n</li>\n<li>\n<p><code>:nth-last-child(n)</code>：元素中指定逆序索引的元素；；</p>\n</li>\n<li>\n<p><code>:first-child</code>：元素中为首的元素；</p>\n</li>\n<li>\n<p><code>:last-child</code> ：元素中为尾的元素；</p>\n</li>\n<li>\n<p><code>:only-child</code>：父元素仅有该元素的元素；</p>\n</li>\n<li>\n<p><code>:nth-of-type(n)</code>：标签中指定顺序索引的标签；</p>\n</li>\n<li>\n<p><code>:nth-last-of-type(n)</code>：标签中指定逆序索引的标签；</p>\n</li>\n<li>\n<p><code>:first-of-type</code> ：标签中为首的标签；</p>\n</li>\n<li>\n<p><code>:last-of-type</code>：标签中为尾标签；</p>\n</li>\n<li>\n<p><code>:only-of-type</code>：父元素仅有该标签的标签；</p>\n</li>\n</ul>\n<h4 id=\"伪元素\">伪元素</h4>\n<ul>\n<li>\n<p><code>::before</code>：在元素前插入内容；</p>\n</li>\n<li>\n<p><code>::after</code>：在元素后插入内容；</p>\n</li>\n</ul>\n<h3 id=\"优先级\">优先级</h3>\n<p><img src=\"https://cimg1.17lai.fun/data/2021/09/1220210912192225.png\" alt=\"\"></p>\n<p>优先级就是分配给指定的 CSS 声明的一个权重，它由匹配的选择器中的每一种选择器类型的数值决定。为了记忆，可以把权重分成如下几个等级，数值越大的权重越高：</p>\n<ul>\n<li>\n<p>10000：!important；</p>\n</li>\n<li>\n<p>01000：内联样式；</p>\n</li>\n<li>\n<p>00100：ID 选择器；</p>\n</li>\n<li>\n<p>00010：类选择器、伪类选择器、属性选择器；</p>\n</li>\n<li>\n<p>00001：元素选择器、伪元素选择器；</p>\n</li>\n<li>\n<p>00000：通配选择器、后代选择器、兄弟选择器；</p>\n</li>\n</ul>\n<p>可以看到内联样式（通过元素中 style 属性定义的样式）的优先级大于任何选择器；而给属性值加上 <code>!important</code> 又可以把优先级提至最高，就是因为它的优先级最高，所以需要谨慎使用它，以下有些使用注意事项：</p>\n<ul>\n<li>\n<p>一定要优先考虑使用样式规则的优先级来解决问题而不是 !important；</p>\n</li>\n<li>\n<p>只有在需要覆盖全站或外部 CSS 的特定页面中使用 !important；</p>\n</li>\n<li>\n<p>永远不要在你的插件中使用 !important；</p>\n</li>\n<li>\n<p>永远不要在全站范围的 CSS 代码中使用 !important；</p>\n</li>\n</ul>\n<h3 id=\"继承性\">继承性</h3>\n<p><img src=\"https://cimg1.17lai.fun/data/2021/09/1220210912192218.jpeg\" alt=\"\"></p>\n<p>在 CSS 中有一个很重要的特性就是子元素会继承父元素对应属性计算后的值。比如页面根元素 html 的文本颜色默认是黑色的，页面中的所有其他元素都将继承这个颜色，当申明了如下样式后，H1 文本将变成橙色。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-css\" data-language=\"css\"><code class=\"language-css\">body {  \n    color: orange;  \n}  \nh1 {  \n    color: inherit;  \n}  </code></pre></div></figure>\n<p>设想一下，如果 CSS 中不存在继承性，那么我们就需要为不同文本的标签都设置一下 color，这样一来的后果就是 CSS 的文件大小就会无限增大。</p>\n<p>CSS 属性很多，但并不是所有的属性默认都是能继承父元素对应属性的，那哪些属性存在默认继承的行为呢？一定是那些不会影响到页面布局的属性，可以分为如下几类：</p>\n<ul>\n<li>\n<p>字体相关：<code>font-family</code>、<code>font-style</code>、<code>font-size</code>、<code>font-weight</code> 等；</p>\n</li>\n<li>\n<p>文本相关：<code>text-align</code>、<code>text-indent</code>、<code>text-decoration</code>、<code>text-shadow</code>、<code>letter-spacing</code>、<code>word-spacing</code>、<code>white-space</code>、<code>line-height</code>、<code>color</code> 等；</p>\n</li>\n<li>\n<p>列表相关：<code>list-style</code>、<code>list-style-image</code>、<code>list-style-type</code>、<code>list-style-position</code> 等；</p>\n</li>\n<li>\n<p>其他属性：<code>visibility</code>、<code>cursor</code> 等；</p>\n</li>\n</ul>\n<p>对于其他默认不继承的属性也可以通过以下几个属性值来控制继承行为：</p>\n<ul>\n<li>\n<p><code>inherit</code>：继承父元素对应属性的计算值；</p>\n</li>\n<li>\n<p><code>initial</code>：应用该属性的默认值，比如 color 的默认值是 <code>#000</code>；</p>\n</li>\n<li>\n<p><code>unset</code>：如果属性是默认可以继承的，则取 <code>inherit</code> 的效果，否则同 <code>initial</code>；</p>\n</li>\n<li>\n<p><code>revert</code>：效果等同于 <code>unset</code>，兼容性差。</p>\n</li>\n</ul>\n<h3 id=\"文档流\">文档流</h3>\n<p>在 CSS 的世界中，会把内容按照从左到右、从上到下的顺序进行排列显示。正常情况下会把页面分割成一行一行的显示，而每行又可能由多列组成，所以从视觉上看起来就是从上到下从左到右，而这就是 CSS 中的流式布局，又叫文档流。文档流就像水一样，能够自适应所在的容器，一般它有如下几个特性：</p>\n<ul>\n<li>\n<p>块级元素默认会占满整行，所以多个块级盒子之间是从上到下排列的；</p>\n</li>\n<li>\n<p>内联元素默认会在一行里一列一列的排布，当一行放不下的时候，会自动切换到下一行继续按照列排布；</p>\n</li>\n</ul>\n<p><strong>如何脱离文档流呢？</strong></p>\n<p>脱流文档流指节点脱流正常文档流后，在正常文档流中的其他节点将忽略该节点并填补其原先空间。文档一旦脱流，计算其父节点高度时不会将其高度纳入，脱流节点不占据空间。有两种方式可以让元素脱离文档流：浮动和定位。</p>\n<ul>\n<li>\n<p>使用浮动（float）会将元素脱离文档流，移动到容器左/右侧边界或者是另一个浮动元素旁边，该浮动元素之前占用的空间将被别的元素填补，另外浮动之后所占用的区域不会和别的元素之间发生重叠；</p>\n</li>\n<li>\n<p>使用绝对定位（<code>position: absolute;</code>）或者固定定位（<code>position: fixed;</code>）也会使得元素脱离文档流，且空出来的位置将自动被后续节点填补。</p>\n</li>\n</ul>\n<h3 id=\"盒模型\">盒模型</h3>\n<p>在 CSS 中任何元素都可以看成是一个盒子，而一个盒子是由 4 部分组成的：内容（content）、内边距（padding）、边框（border）和外边距（margin）。</p>\n<p>盒模型有 2 种：标准盒模型和 IE 盒模型，本别是由 W3C 和 IExplore 制定的标准。</p>\n<p>如果给某个元素设置如下样式：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-css\" data-language=\"css\"><code class=\"language-css\">.box {  \n    width: 200px;  \n    height: 200px;  \n    padding: 10px;  \n    border: 1px solid #eee;  \n    margin: 10px;  \n}  </code></pre></div></figure>\n<p>标准盒模型认为：盒子的实际尺寸 = 内容（设置的宽/高） + 内边距 + 边框</p>\n<p><img src=\"https://cimg1.17lai.fun/data/2021/09/1220210912192143.png\" alt=\"\"></p>\n<p>所以 <code>.box</code> 元素内容的宽度就为 <code>200px</code>，而实际的宽度则是 <code>width</code> + <code>padding-left</code> + <code>padding-right</code> + <code>border-left-width</code> + <code>border-right-width</code> = 200 + 10 + 10 + 1 + 1 = 222。</p>\n<p>IE 盒模型认为：盒子的实际尺寸 = 设置的宽/高 = 内容 + 内边距 + 边框</p>\n<p><img src=\"https://cimg1.17lai.fun/data/2021/09/1220210912192137.png\" alt=\"\"></p>\n<p><code>.box</code> 元素所占用的实际宽度为 <code>200px</code>，而内容的真实宽度则是 <code>width</code> - <code>padding-left</code> - <code>padding-right</code> - <code>border-left-width</code> - <code>border-right-width</code> = 200 - 10 - 10 - 1 - 1 = 178。</p>\n<p>现在高版本的浏览器基本上默认都是使用标准盒模型，而像 IE6 这种老古董才是默认使用 IE 盒模型的。</p>\n<p>在  CSS3 中新增了一个属性 <code>box-sizing</code>，允许开发者来指定盒子使用什么标准，它有 2 个值：</p>\n<ul>\n<li>\n<p><code>content-box</code>：标准盒模型；</p>\n</li>\n<li>\n<p><code>border-box</code>：IE 盒模型；</p>\n</li>\n</ul>\n<h3 id=\"视觉格式化模型\">视觉格式化模型</h3>\n<p>视觉格式化模型（Visual formatting model）是用来处理和在视觉媒体上显示文档时使用的计算规则。CSS 中一切皆盒子，而视觉格式化模型简单来理解就是规定这些盒子应该怎么样放置到页面中去，这个模型在计算的时候会依赖到很多的因素，比如：盒子尺寸、盒子类型、定位方案（是浮动还是定位）、兄弟元素或者子元素以及一些别的因素。</p>\n<p><img src=\"https://cimg1.17lai.fun/data/2021/09/1220210912192137.jpeg\" alt=\"\"></p>\n<p>Visual formatting model</p>\n<p>从上图中可以看到视觉格式化模型涉及到的内容很多，有兴趣深入研究的可以结合上图看这个 W3C 的文档 Visual formatting model[6]。所以这里就简单介绍下盒子类型。</p>\n<p><img src=\"https://cimg1.17lai.fun/data/2021/09/1220210912192129.png\" alt=\"\"></p>\n<p>盒子类型由 display 决定，同时给一个元素设置 display 后，将会决定这个盒子的 2 个显示类型（display type）：</p>\n<ul>\n<li>\n<p>outer display type（对外显示）：决定了该元素本身是如何布局的，即参与何种格式化上下文；</p>\n</li>\n<li>\n<p>inner display type（对内显示）：其实就相当于把该元素当成了容器，规定了其内部子元素是如何布局的，参与何种格式化上下文；</p>\n</li>\n</ul>\n<h4 id=\"outer-display-type\">outer display type</h4>\n<p>对外显示方面，盒子类型可以分成 2 类：block-level box（块级盒子） 和 inline-level box（行内级盒子）。</p>\n<p>依据上图可以列出都有哪些块级和行内级盒子：</p>\n<ul>\n<li>\n<p>块级盒子：display 为 block、list-item、table、flex、grid、flow-root 等；</p>\n</li>\n<li>\n<p>行内级盒子：display 为 inline、inline-block、inline-table 等；</p>\n</li>\n</ul>\n<p>所有块级盒子都会参与 BFC，呈现垂直排列；而所有行内级盒子都参会 IFC，呈现水平排列。</p>\n<p>除此之外，block、inline 和 inline-block 还有什么更具体的区别呢？</p>\n<p><strong>block</strong></p>\n<ul>\n<li>\n<p>占满一行，默认继承父元素的宽度；多个块元素将从上到下进行排列；</p>\n</li>\n<li>\n<p>设置 width/height 将会生效；</p>\n</li>\n<li>\n<p>设置 padding 和 margin 将会生效；</p>\n</li>\n</ul>\n<p><strong>inline</strong></p>\n<ul>\n<li>\n<p>不会占满一行，宽度随着内容而变化；多个 inline 元素将按照从左到右的顺序在一行里排列显示，如果一行显示不下，则自动换行；</p>\n</li>\n<li>\n<p>设置 width/height 将不会生效；</p>\n</li>\n<li>\n<p>设置竖直方向上的 padding 和 margin 将不会生效；</p>\n</li>\n</ul>\n<p><strong>inline-block</strong></p>\n<ul>\n<li>\n<p>是行内块元素，不单独占满一行，可以看成是能够在一行里进行左右排列的块元素；</p>\n</li>\n<li>\n<p>设置 width/height 将会生效；</p>\n</li>\n<li>\n<p>设置 padding 和 margin 将会生效；</p>\n</li>\n</ul>\n<h4 id=\"inner-display-type\">inner display type</h4>\n<p>对内方面，其实就是把元素当成了容器，里面包裹着文本或者其他子元素。container box 的类型依据 display 的值不同，分为 4 种：</p>\n<ul>\n<li>\n<p>block container：建立 BFC 或者 IFC；</p>\n</li>\n<li>\n<p>flex container：建立 FFC；</p>\n</li>\n<li>\n<p>grid container：建立 GFC;</p>\n</li>\n<li>\n<p>ruby container：接触不多，不做介绍。</p>\n</li>\n</ul>\n<p>值得一提的是如果把 img 这种替换元素（replaced element）申明为 block 是不会产生 container box 的，因为替换元素比如 img 设计的初衷就仅仅是通过 src 把内容替换成图片，完全没考虑过会把它当成容器。</p>\n<p>参考：</p>\n<ul>\n<li>\n<p>CSS 原理 - 你所不知道的 display[7]</p>\n</li>\n<li>\n<p>格式化上下文[8]</p>\n</li>\n</ul>\n<h3 id=\"格式化上下文\">格式化上下文</h3>\n<p>格式化上下文（Formatting Context）是 CSS2.1 规范中的一个概念，大概说的是页面中的一块渲染区域，规定了渲染区域内部的子元素是如何排版以及相互作用的。</p>\n<p>不同类型的盒子有不同格式化上下文，大概有这 4 类：</p>\n<ul>\n<li>\n<p>BFC (Block Formatting Context) 块级格式化上下文；</p>\n</li>\n<li>\n<p>IFC (Inline Formatting Context) 行内格式化上下文；</p>\n</li>\n<li>\n<p>FFC (Flex Formatting Context) 弹性格式化上下文；</p>\n</li>\n<li>\n<p>GFC (Grid Formatting Context) 格栅格式化上下文；</p>\n</li>\n</ul>\n<p>其中 BFC 和 IFC 在 CSS 中扮演着非常重要的角色，因为它们直接影响了网页布局，所以需要深入理解其原理。</p>\n<h4 id=\"BFC\">BFC</h4>\n<p>块格式化上下文，它是一个独立的渲染区域，只有块级盒子参与，它规定了内部的块级盒子如何布局，并且与这个区域外部毫不相干。</p>\n<p><img src=\"https://cimg1.17lai.fun/data/2021/09/1220210912192122.png\" alt=\"\"></p>\n<p>图来源于 yachen168</p>\n<p><strong>BFC 渲染规则</strong></p>\n<ul>\n<li>\n<p>内部的盒子会在垂直方向，一个接一个地放置；</p>\n</li>\n<li>\n<p>盒子垂直方向的距离由 margin 决定，属于同一个 BFC 的两个相邻盒子的 margin 会发生重叠；</p>\n</li>\n<li>\n<p>每个元素的 margin 的左边，与包含块 border 的左边相接触(对于从左往右的格式化，否则相反)，即使存在浮动也是如此；</p>\n</li>\n<li>\n<p>BFC 的区域不会与 float 盒子重叠；</p>\n</li>\n<li>\n<p>BFC 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。</p>\n</li>\n<li>\n<p>计算 BFC 的高度时，浮动元素也参与计算。</p>\n</li>\n</ul>\n<p><strong>如何创建 BFC？</strong></p>\n<ul>\n<li>\n<p>根元素：html</p>\n</li>\n<li>\n<p>非溢出的可见元素：overflow 不为 visible</p>\n</li>\n<li>\n<p>设置浮动：float 属性不为 none</p>\n</li>\n<li>\n<p>设置定位：position 为 absolute 或 fixed</p>\n</li>\n<li>\n<p>定义成块级的非块级元素：display: inline-block/table-cell/table-caption/flex/inline-flex/grid/inline-grid</p>\n</li>\n</ul>\n<p><strong>BFC 应用场景</strong></p>\n<p>1、 自适应两栏布局</p>\n<p>应用原理：BFC 的区域不会和浮动区域重叠，所以就可以把侧边栏固定宽度且左浮动，而对右侧内容触发 BFC，使得它的宽度自适应该行剩余宽度。</p>\n<p><img src=\"https://cimg1.17lai.fun/data/2021/09/1220210912192107.gif\" alt=\"\"></p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-css\" data-language=\"css\"><code class=\"language-css\">&lt;div class=\"layout\"&gt;  \n    &lt;div class=\"aside\"&gt;aside&lt;/div&gt;  \n    &lt;div class=\"main\"&gt;main&lt;/div&gt;  \n&lt;/div&gt;  </code></pre></div></figure>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-css\" data-language=\"css\"><code class=\"language-css\">.aside {  \n    float: left;  \n    width: 100px;  \n}  \n.main {  \n    &lt;!-- 触发 BFC --&gt;  \n    overflow: auto;  \n}  </code></pre></div></figure>\n<p>2、清除内部浮动</p>\n<p>浮动造成的问题就是父元素高度坍塌，所以清除浮动需要解决的问题就是让父元素的高度恢复正常。而用     BFC 清除浮动的原理就是：计算 BFC 的高度时，浮动元素也参与计算。只要触发父元素的 BFC 即可。</p>\n<p><img src=\"https://cimg1.17lai.fun/data/2021/09/1220210912192102.png\" alt=\"\"></p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-css\" data-language=\"css\"><code class=\"language-css\">.parent {\n    overflow: hidden;\n}</code></pre></div></figure>\n<p>3、 防止垂直 margin 合并</p>\n<p>BFC 渲染原理之一：同一个 BFC 下的垂直 margin 会发生合并。所以如果让 2 个元素不在同一个 BFC 中即可阻止垂直 margin 合并。那如何让 2 个相邻的兄弟元素不在同一个 BFC 中呢？可以给其中一个元素外面包裹一层，然后触发其包裹层的 BFC，这样一来 2 个元素就不会在同一个 BFC 中了。</p>\n<p><img src=\"https://cimg1.17lai.fun/data/2021/09/1220210912192012.png\" alt=\"\"></p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-css\" data-language=\"css\"><code class=\"language-css\">&lt;div class=\"layout\"&gt;  \n\t&lt;div class=\"a\"&gt;a&lt;/div&gt;  \n    &lt;div class=\"contain-b\"&gt;  \n        &lt;div class=\"b\"&gt;b&lt;/div&gt;  \n    &lt;/div&gt;  \n&lt;/div&gt;  </code></pre></div></figure>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-css\" data-language=\"css\"><code class=\"language-css\">.demo3 .a,  \n.demo3 .b {  \n    border: 1px solid #999;  \n    margin: 10px;  \n}  \n.contain-b {  \n    overflow: hidden;  \n}  </code></pre></div></figure>\n<p>针对以上 3 个 示例 ，可以结合这个 BFC 应用示例 配合观看更佳。</p>\n<p>参考：CSS 原理 - Formatting Context[9]</p>\n<h4 id=\"IFC\">IFC</h4>\n<p>IFC 的形成条件非常简单，块级元素中仅包含内联级别元素，需要注意的是当IFC中有块级元素插入时，会产生两个匿名块将父元素分割开来，产生两个 IFC。</p>\n<p><img src=\"https://cimg1.17lai.fun/data/2021/09/1220210912160820.png\" alt=\"\"></p>\n<p><strong>IFC 渲染规则</strong></p>\n<ul>\n<li>\n<p>子元素在水平方向上一个接一个排列，在垂直方向上将以容器顶部开始向下排列；</p>\n</li>\n<li>\n<p>节点无法声明宽高，其中 margin 和 padding 在水平方向有效在垂直方向无效；</p>\n</li>\n<li>\n<p>节点在垂直方向上以不同形式对齐；</p>\n</li>\n<li>\n<p>能把在一行上的框都完全包含进去的一个矩形区域，被称为该行的线盒（line box）。线盒的宽度是由包含块（containing box）和与其中的浮动来决定；</p>\n</li>\n<li>\n<p>IFC 中的 line box 一般左右边贴紧其包含块，但 float 元素会优先排列。</p>\n</li>\n<li>\n<p>IFC 中的 line box 高度由 line-height 计算规则来确定，同个 IFC 下的多个 line box 高度可能会不同；</p>\n</li>\n<li>\n<p>当内联级盒子的总宽度少于包含它们的 line box 时，其水平渲染规则由 text-align 属性值来决定；</p>\n</li>\n<li>\n<p>当一个内联盒子超过父元素的宽度时，它会被分割成多盒子，这些盒子分布在多个 line box 中。如果子元素未设置强制换行的情况下，inline box 将不可被分割，将会溢出父元素。</p>\n</li>\n</ul>\n<p>针对如上的 IFC 渲染规则，你是不是可以分析下下面这段代码的 IFC 环境是怎么样的呢？</p>\n<p><code>&lt;p&gt;It can get &lt;strong&gt;very complicated&lt;/storng&gt; once you start looking into it.&lt;/p&gt;   </code></p>\n<p><img src=\"https://cimg1.17lai.fun/data/2021/09/1220210912160815.jpeg\" alt=\"\"></p>\n<p>对应上面这样一串 HTML 分析如下：</p>\n<ul>\n<li>\n<p>p 标签是一个 block container，对内将产生一个 IFC；</p>\n</li>\n<li>\n<p>由于一行没办法显示完全，所以产生了 2 个线盒（line box）；线盒的宽度就继承了 p 的宽度；高度是由里面的内联盒子的 line-height 决定；</p>\n</li>\n<li>\n<p>It can get：匿名的内联盒子；</p>\n</li>\n<li>\n<p>very complicated：strong 标签产生的内联盒子；</p>\n</li>\n<li>\n<p>once you start：匿名的内联盒子；</p>\n</li>\n<li>\n<p>looking into it.：匿名的内联盒子。</p>\n</li>\n</ul>\n<p>参考：Inline formatting contexts[10]</p>\n<p><strong>IFC 应用场景</strong></p>\n<ul>\n<li>\n<p>水平居中：当一个块要在环境中水平居中时，设置其为 inline-block 则会在外层产生 IFC，通过 text-align 则可以使其水平居中。</p>\n</li>\n<li>\n<p>垂直居中：创建一个 IFC，用其中一个元素撑开父元素的高度，然后设置其 vertical-align: middle，其他行内元素则可以在此父元素下垂直居中。</p>\n</li>\n</ul>\n<p>偷个懒，demo 和图我就不做了。</p>\n<h3 id=\"层叠上下文\">层叠上下文</h3>\n<p>在电脑显示屏幕上的显示的页面其实是一个三维的空间，水平方向是 X 轴，竖直方向是 Y 轴，而屏幕到眼睛的方向可以看成是 Z 轴。众 HTML 元素依据自己定义的属性的优先级在 Z 轴上按照一定的顺序排开，而这其实就是层叠上下文所要描述的东西。</p>\n<p><img src=\"https://cimg1.17lai.fun/data/2021/09/1220210912160813.png\" alt=\"\"></p>\n<p>-w566</p>\n<p>我们对层叠上下文的第一印象可能要来源于 z-index，认为它的值越大，距离屏幕观察者就越近，那么层叠等级就越高，事实确实是这样的，但层叠上下文的内容远非仅仅如此：</p>\n<ul>\n<li>\n<p>z-index 能够在层叠上下文中对元素的堆叠顺序其作用是必须配合定位才可以；</p>\n</li>\n<li>\n<p>除了 z-index 之外，一个元素在 Z 轴上的显示顺序还受层叠等级和层叠顺序影响；</p>\n</li>\n</ul>\n<p>在看层叠等级和层叠顺序之前，我们先来看下如何产生一个层叠上下文，特定的 HTML 元素或者 CSS 属性产生层叠上下文，MDN 中给出了这么一个列表，符合以下任一条件的元素都会产生层叠上下文：</p>\n<ul>\n<li>\n<p>html 文档根元素</p>\n</li>\n<li>\n<p>声明 position: absolute/relative 且 z-index 值不为 auto 的元素；</p>\n</li>\n<li>\n<p>声明 position: fixed/sticky 的元素；</p>\n</li>\n<li>\n<p>flex 容器的子元素，且 z-index 值不为 auto；</p>\n</li>\n<li>\n<p>grid 容器的子元素，且 z-index 值不为 auto；</p>\n</li>\n<li>\n<p>opacity 属性值小于 1 的元素；</p>\n</li>\n<li>\n<p>mix-blend-mode 属性值不为 normal 的元素；</p>\n</li>\n<li>\n<p>以下任意属性值不为 none 的元素：</p>\n</li>\n<li>\n<p>transform</p>\n</li>\n<li>\n<p>filter</p>\n</li>\n<li>\n<p>perspective</p>\n</li>\n<li>\n<p>clip-path</p>\n</li>\n<li>\n<p>mask / mask-image / mask-border</p>\n</li>\n<li>\n<p>isolation 属性值为 isolate 的元素；</p>\n</li>\n<li>\n<p>-webkit-overflow-scrolling 属性值为 touch 的元素；</p>\n</li>\n<li>\n<p>will-change 值设定了任一属性而该属性在 non-initial 值时会创建层叠上下文的元素；</p>\n</li>\n<li>\n<p>contain 属性值为 layout、paint 或包含它们其中之一的合成值（比如 contain: strict、contain: content）的元素。</p>\n</li>\n</ul>\n<p><strong>层叠等级</strong></p>\n<p>层叠等级指节点在三维空间 Z 轴上的上下顺序。它分两种情况：</p>\n<ul>\n<li>\n<p>在同一个层叠上下文中，它描述定义的是该层叠上下文中的层叠上下文元素在 Z 轴上的上下顺序；</p>\n</li>\n<li>\n<p>在其他普通元素中，它描述定义的是这些普通元素在 Z 轴上的上下顺序；</p>\n</li>\n</ul>\n<p>普通节点的层叠等级优先由其所在的层叠上下文决定，层叠等级的比较只有在当前层叠上下文中才有意义，脱离当前层叠上下文的比较就变得无意义了。</p>\n<p><strong>层叠顺序</strong></p>\n<p>在同一个层叠上下文中如果有多个元素，那么他们之间的层叠顺序是怎么样的呢？</p>\n<p><img src=\"https://cimg1.17lai.fun/data/2021/09/1220210912160807.png\" alt=\"\"></p>\n<p>以下这个列表越往下层叠优先级越高，视觉上的效果就是越容易被用户看到（不会被其他元素覆盖）：</p>\n<ul>\n<li>\n<p>层叠上下文的 border 和 background</p>\n</li>\n<li>\n<p>z-index &lt; 0 的子节点</p>\n</li>\n<li>\n<p>标准流内块级非定位的子节点</p>\n</li>\n<li>\n<p>浮动非定位的子节点</p>\n</li>\n<li>\n<p>标准流内行内非定位的子节点</p>\n</li>\n<li>\n<p>z-index: auto/0 的子节点</p>\n</li>\n<li>\n<p>z-index &gt; 0的子节点</p>\n</li>\n</ul>\n<p><strong>如何比较两个元素的层叠等级？</strong></p>\n<ul>\n<li>\n<p>在同一个层叠上下文中，比较两个元素就是按照上图的介绍的层叠顺序进行比较。</p>\n</li>\n<li>\n<p>如果不在同一个层叠上下文中的时候，那就需要比较两个元素分别所处的层叠上下文的等级。</p>\n</li>\n<li>\n<p>如果两个元素都在同一个层叠上下文，且层叠顺序相同，则在 HTML 中定义越后面的层叠等级越高。</p>\n</li>\n</ul>\n<p>参考：彻底搞懂CSS层叠上下文、层叠等级、层叠顺序、z-index[11]</p>\n<h3 id=\"值和单位\">值和单位</h3>\n<p>CSS 的声明是由属性和值组成的，而值的类型有许多种：</p>\n<ul>\n<li>\n<p>数值：长度值 ，用于指定例如元素 width、border-width、font-size 等属性的值；</p>\n</li>\n<li>\n<p>百分比：可以用于指定尺寸或长度，例如取决于父容器的 width、height 或默认的 font-size；</p>\n</li>\n<li>\n<p>颜色：用于指定 background-color、color 等；</p>\n</li>\n<li>\n<p>坐标位置：以屏幕的左上角为坐标原点定位元素的位置，比如常见的 background-position、top、right、bottom 和 left 等属性；</p>\n</li>\n<li>\n<p>函数：用于指定资源路径或背景图片的渐变，比如 url()、linear-gradient() 等；</p>\n</li>\n</ul>\n<p>而还有些值是需要带单位的，比如 width: 100px，这里的 px 就是表示长度的单位，长度单位除了 px 外，比较常用的还有 em、rem、vw/vh 等。那他们有什么区别呢？又应该在什么时候使用它们呢？</p>\n<h4 id=\"px\">px</h4>\n<p>屏幕分辨率是指在屏幕的横纵方向上的像素点数量，比如分辨率 1920×1080 意味着水平方向含有 1920 个像素数，垂直方向含有 1080 个像素数。</p>\n<p><img src=\"https://cimg1.17lai.fun/data/2021/09/1220210912160800.png\" alt=\"\"></p>\n<p>而 px 表示的是 CSS 中的像素，在 CSS 中它是绝对的长度单位，也是最基础的单位，其他长度单位会自动被浏览器换算成 px。但是对于设备而言，它其实又是相对的长度单位，比如宽高都为 2px，在正常的屏幕下，其实就是 4 个像素点，而在设备像素比(devicePixelRatio) 为 2 的 Retina 屏幕下，它就有 16 个像素点。所以屏幕尺寸一致的情况下，屏幕分辨率越高，显示效果就越细腻。</p>\n<p>讲到这里，还有一些相关的概念需要理清下：</p>\n<p><strong>设备像素（Device pixels）</strong></p>\n<p>设备屏幕的物理像素，表示的是屏幕的横纵有多少像素点；和屏幕分辨率是差不多的意思。</p>\n<p><strong>设备像素比（DPR）</strong></p>\n<p>设备像素比表示 1 个 CSS 像素等于几个物理像素。</p>\n<p>计算公式：DPR = 物理像素数 / 逻辑像素数；</p>\n<p>在浏览器中可以通过 window.devicePixelRatio 来获取当前屏幕的 DPR。</p>\n<p><strong>像素密度（DPI/PPI）</strong></p>\n<p>像素密度也叫显示密度或者屏幕密度，缩写为 DPI(Dots Per Inch) 或者 PPI(Pixel Per Inch)。从技术角度说，PPI 只存在于计算机显示领域，而 DPI 只出现于打印或印刷领域。</p>\n<p>计算公式：像素密度 = 屏幕对角线的像素尺寸 / 物理尺寸</p>\n<p>比如，对于分辨率为 750 * 1334 的 iPhone 6 来说，它的像素密度为：</p>\n<p><code>Math.sqrt(750 * 750 + 1334 * 1334) / 4.7 = 326ppi   </code></p>\n<p><strong>设备独立像素（DIP）</strong></p>\n<p>DIP 是特别针对 Android设备而衍生出来的，原因是安卓屏幕的尺寸繁多，因此为了显示能尽量和设备无关，而提出的这个概念。它是基于屏幕密度而计算的，认为当屏幕密度是 160 的时候，px = DIP。</p>\n<p>计算公式：dip = px * 160 / dpi</p>\n<h4 id=\"em\">em</h4>\n<p>em 是 CSS 中的相对长度单位中的一个。居然是相对的，那它到底是相对的谁呢？它有 2 层意思：</p>\n<ul>\n<li>\n<p>在 font-size 中使用是相对于<strong>父元素</strong>的 font-size 大小，比如父元素 font-size: 16px，当给子元素指定 font-size: 2em 的时候，经过计算后它的字体大小会是 32px；</p>\n</li>\n<li>\n<p>在其他属性中使用是相对于自身的字体大小，如 width/height/padding/margin 等；</p>\n</li>\n</ul>\n<p>我们都知道每个浏览器都会给 HTML 根元素 html 设置一个默认的 font-size，而这个值通常是 16px。这也就是为什么 1em = 16px 的原因所在了。</p>\n<p>em 在计算的时候是会层层计算的，比如：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-css\" data-language=\"css\"><code class=\"language-css\">&lt;div&gt;  \n    &lt;p&gt;&lt;/p&gt;  \n&lt;/div&gt;  </code></pre></div></figure>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-css\" data-language=\"css\"><code class=\"language-css\">div { font-size: 2em; }  \np { font-size: 2em; }  </code></pre></div></figure>\n<p>对于如上一个结构的 HTML，由于根元素 html 的字体大小是 16px，所以 p 标签最终计算出来后的字体大小会是 16 * 2 * 2 = 64px</p>\n<h4 id=\"rem\">rem</h4>\n<p>rem(root em) 和 em 一样，也是一个相对长度单位，不过 rem 相对的是 HTML 的根元素 html。</p>\n<p>rem 由于是基于 html 的 font-size 来计算，所以通常用于自适应网站或者 H5 中。</p>\n<p>比如在做 H5 的时候，前端通常会让 UI 给 750px 宽的设计图，而在开发的时候可以基于 iPhone X 的尺寸 375px * 812px 来写页面，这样一来的话，就可以用下面的 JS 依据当前页面的视口宽度自动计算出根元素 html 的基准 font-size 是多少。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-css\" data-language=\"css\"><code class=\"language-css\">(function (doc, win) {  \n    var docEl = doc.documentElement,  \n        resizeEvt = 'orientationchange' in window ? 'orientationchange' : 'resize',  \n        psdWidth = 750,  // 设计图宽度  \n        recalc = function () {  \n            var clientWidth = docEl.clientWidth;  \n            if ( !clientWidth ) return;  \n            if ( clientWidth &gt;= 640 ) {  \n                docEl.style.fontSize = 200 * ( 640 / psdWidth ) + 'px';  \n            } else {  \n                docEl.style.fontSize = 200 * ( clientWidth / psdWidth ) + 'px';  \n            }  \n        };\n\n    if ( !doc.addEventListener ) return;  \n    // 绑定事件的时候最好配合防抖函数  \n    win.addEventListener( resizeEvt, debounce(recalc, 1000), false );  \n    doc.addEventListener( 'DOMContentLoaded', recalc, false );\n\n        function debounce(func, wait) {  \n        var timeout;  \n        return function () {  \n            var context = this;  \n            var args = arguments;  \n            clearTimeout(timeout)  \n            timeout = setTimeout(function(){  \n                func.apply(context, args)  \n            }, wait);  \n        }  \n    }  \n})(document, window);\n</code></pre></div></figure>\n<p>比如当视口是 375px 的时候，经过计算 html 的 font-size 会是 100px，这样有什么好处呢？好处就是方便写样式，比如从设计图量出来的 header 高度是 50px 的，那我们写样式的时候就可以直接写：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-css\" data-language=\"css\"><code class=\"language-css\">header {  \n    height: 0.5rem;  \n}  </code></pre></div></figure>\n<p><img src=\"https://cimg1.17lai.fun/data/2021/09/1220210912160740.png\" alt=\"\"></p>\n<p>每个从设计图量出来的尺寸只要除于 100 即可得到当前元素的 rem 值，都不用经过计算，非常方便。偷偷告诉你，如果你把上面那串计算 html 标签 font-size 的 JS 代码中的 200 替换成 2，那在计算 rem 的时候就不需要除于 100 了，从设计图量出多大 px，就直接写多少个 rem。</p>\n<h4 id=\"vw-vh\">vw/vh</h4>\n<p>vw 和 vh 分别是相对于屏幕视口宽度和高度而言的长度单位：</p>\n<ul>\n<li>\n<p>1vw = 视口宽度均分成 100 份中 1 份的长度；</p>\n</li>\n<li>\n<p>1vh = 视口高度均分成 100 份中 1 份的长度；</p>\n</li>\n</ul>\n<p>在 JS 中 100vw = window.innerWidth，100vh = window.innerHeight。</p>\n<p><img src=\"https://cimg1.17lai.fun/data/2021/09/1220210912160734.jpeg\" alt=\"\"></p>\n<p>vw/vh 的出现使得多了一种写自适应布局的方案，开发者不再局限于 rem 了。</p>\n<p>相对视口的单位，除了 vw/vh 外，还有 vmin 和 vmax：</p>\n<ul>\n<li>\n<p>vmin：取 vw 和 vh 中值较小的；</p>\n</li>\n<li>\n<p>vmax：取 vw 和 vh 中值较大的；</p>\n</li>\n</ul>\n<h3 id=\"颜色体系\">颜色体系</h3>\n<p>CSS 中用于表示颜色的值种类繁多，足够构成一个体系，所以这里就专门拿出一个小节来讲解它。</p>\n<p>根据 CSS 颜色草案[12] 中提到的颜色值类型，大概可以把它们分为这几类：</p>\n<ul>\n<li>\n<p>颜色关键字</p>\n</li>\n<li>\n<p>transparent 关键字</p>\n</li>\n<li>\n<p>currentColor 关键字</p>\n</li>\n<li>\n<p>RGB 颜色</p>\n</li>\n<li>\n<p>HSL 颜色</p>\n</li>\n</ul>\n<h4 id=\"颜色关键字\">颜色关键字</h4>\n<p>颜色关键字（color keywords）是不区分大小写的标识符，它表示一个具体的颜色，比如 white（白），黑（black）等；</p>\n<p>可接受的关键字列表在CSS的演变过程中发生了改变：</p>\n<ul>\n<li>\n<p>CSS 标准 1 只接受 16 个基本颜色，称为 VGA 颜色，因为它们来源于 VGA 显卡所显示的颜色集合而被称为 VGA colors （视频图形阵列色彩）。</p>\n</li>\n<li>\n<p>CSS 标准 2 增加了 orange 关键字。</p>\n</li>\n<li>\n<p>从一开始，浏览器接受其它的颜色，由于一些早期浏览器是 X11 应用程序，这些颜色大多数是 X11 命名的颜色列表，虽然有一点不同。SVG 1.0 是首个正式定义这些关键字的标准；CSS 色彩标准 3 也正式定义了这些关键字。它们经常被称作扩展的颜色关键字， X11 颜色或 SVG 颜色 。</p>\n</li>\n<li>\n<p>CSS 颜色标准 4 添加可 rebeccapurple 关键字来纪念 web 先锋 Eric Meyer。</p>\n</li>\n</ul>\n<p>如下这张图是 16 个基础色，又叫 VGA 颜色。截止到目前为止 CSS 颜色关键字总共有 146 个，这里可以查看 完整的色彩关键字列表[13]。</p>\n<p><img src=\"https://cimg1.17lai.fun/data/2021/09/1220210912160733.png\" alt=\"\"></p>\n<p>VGA 颜色</p>\n<p>需要注意的是如果声明的时候的颜色关键字是错误的，浏览器会忽略它。</p>\n<h4 id=\"transparent-关键字\">transparent 关键字</h4>\n<p>transparent 关键字表示一个完全透明的颜色，即该颜色看上去将是背景色。从技术上说，它是带有 alpha 通道为最小值的黑色，是 rgba(0,0,0,0) 的简写。</p>\n<p>透明关键字有什么应用场景呢？</p>\n<p><strong>实现三角形</strong></p>\n<p>下面这个图是用 4 条边框填充的正方形，看懂了它你大概就知道该如何用 CSS 写三角形了。</p>\n<p><img src=\"https://cimg1.17lai.fun/data/2021/09/1220210912160726.png\" alt=\"\"></p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-css\" data-language=\"css\"><code class=\"language-css\">div {  \n    border-top-color: #ffc107;  \n    border-right-color: #00bcd4;  \n    border-bottom-color: #e26b6b;  \n    border-left-color: #cc7cda;  \n    border-width: 50px;  \n    border-style: solid;  \n}  </code></pre></div></figure>\n<p>用 transparent 实现三角形的原理：</p>\n<ul>\n<li>\n<p>首先宽高必须是 0px，通过边框的粗细来填充内容；</p>\n</li>\n<li>\n<p>那条边需要就要加上颜色，而不需要的边则用 transparent；</p>\n</li>\n<li>\n<p>想要什么样姿势的三角形，完全由上下左右 4 条边的中有颜色的边和透明的边的位置决定；</p>\n</li>\n<li>\n<p>等腰三角形：设置一条边有颜色，然后紧挨着的 2 边是透明，且宽度是有颜色边的一半；直角三角形：设置一条边有颜色，然后紧挨着的任何一边透明即可。</p>\n</li>\n</ul>\n<p>看下示例：</p>\n<p><img src=\"https://cimg1.17lai.fun/data/2021/09/1220210912160719.png\" alt=\"\"></p>\n<p><strong>增大点击区域</strong></p>\n<p>常常在移动端的时候点击的按钮的区域特别小，但是由于现实效果又不太好把它做大，所以常用的一个手段就是通过透明的边框来增大按钮的点击区域：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-css\" data-language=\"css\"><code class=\"language-css\">.btn {  \n    border: 5px solid transparent;  \n}  </code></pre></div></figure>\n<h4 id=\"currentColor-关键字\">currentColor 关键字</h4>\n<p>currentColor 会取当前元素继承父级元素的文本颜色值或声明的文本颜色值，即 computed 后的 color 值。</p>\n<p>比如，对于如下 CSS，该元素的边框颜色会是 red：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-css\" data-language=\"css\"><code class=\"language-css\">.btn {  \n    color: red;  \n    border: 1px solid currentColor;  \n}  </code></pre></div></figure>\n<h4 id=\"RGB-A-颜色\">RGB[A] 颜色</h4>\n<p>RGB[A] 颜色是由 R(red)-G(green)-B(blue)-A(alpha) 组成的色彩空间。</p>\n<p><img src=\"https://cimg1.17lai.fun/data/2021/09/1220210912160707.png\" alt=\"\"></p>\n<p>在 CSS 中，它有两种表示形式：</p>\n<ul>\n<li>\n<p>十六进制符号；</p>\n</li>\n<li>\n<p>函数符；</p>\n</li>\n</ul>\n<p><strong>十六进制符号</strong></p>\n<p>RGB 中的每种颜色的值范围是 00~ff，值越大表示颜色越深。所以一个颜色正常是 6 个十六进制字符加上 # 组成，比如红色就是 #ff0000。</p>\n<p>如果 RGB 颜色需要加上不透明度，那就需要加上 alpha 通道的值，它的范围也是 00~ff，比如一个带不透明度为 67% 的红色可以这样写 #ff0000aa。</p>\n<p>使用十六进制符号表示颜色的时候，都是用 2 个十六进制表示一个颜色，如果这 2 个字符相同，还可以缩减成只写 1 个，比如，红色 #f00；带 67% 不透明度的红色 #f00a。</p>\n<p><strong>函数符</strong></p>\n<p>当 RGB 用函数表示的时候，每个值的范围是 0~255 或者 0%~100%，所以红色是 rgb(255, 0, 0)， 或者 rgb(100%, 0, 0)。</p>\n<p>如果需要使用函数来表示带不透明度的颜色值，值的范围是 0~1 及其之间的小数或者 0%~100%，比如带 67% 不透明度的红色是 rgba(255, 0, 0, 0.67) 或者 rgba(100%, 0%, 0%, 67%)</p>\n<blockquote>\n<p>“</p>\n<p>需要注意的是 RGB 这 3 个颜色值需要保持一致的写法，要嘛用数字要嘛用百分比，而不透明度的值的可以不用和 RGB 保持一致写法。比如 rgb(100%, 0, 0) 这个写法是无效的；而 rgb(100%, 0%, 0%, 0.67) 是有效的。</p>\n</blockquote>\n<p>在第 4 代 CSS 颜色标准中，新增了一种新的函数写法，即可以把 RGB 中值的分隔逗号改成空格，而把 RGB 和 alpha 中的逗号改成 /，比如带 67% 不透明度的红色可以这样写 rgba(255 0 0 / 0.67)。另外还把 rgba 的写法合并到 rgb 函数中了，即 rgb 可以直接写带不透明度的颜色。</p>\n<h4 id=\"HSL-A-颜色\">HSL[A] 颜色</h4>\n<p>HSL[A] 颜色是由色相(hue)-饱和度(saturation)-亮度(lightness)-不透明度组成的颜色体系。</p>\n<p><img src=\"https://cimg1.17lai.fun/data/2021/09/1220210912160701.png\" alt=\"\"></p>\n<ul>\n<li>\n<p>色相（H）是色彩的基本属性，值范围是 0~360 或者 0deg~360deg， 0 (或 360) 为红色, 120 为绿色, 240 为蓝色；</p>\n</li>\n<li>\n<p>饱和度（S）是指色彩的纯度，越高色彩越纯，低则逐渐变灰，取 0~100% 的数值；0% 为灰色， 100% 全色；</p>\n</li>\n<li>\n<p>亮度（L），取 0~100%，0% 为暗，100% 为白；</p>\n</li>\n<li>\n<p>不透明度（A），取 0<sub>100%，或者0</sub>1及之间的小数；</p>\n</li>\n</ul>\n<p>写法上可以参考 RGB 的写法，只是参数的值不一样。</p>\n<p>给一个按钮设置不透明度为 67% 的红色的 color 的写法，以下全部写法效果一致：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-css\" data-language=\"css\"><code class=\"language-css\">button {  \n    color: #ff0000aa;  \n    color: #f00a;  \n    color: rgba(255, 0, 0, 0.67);  \n    color: rgb(100% 0% 0% / 67%);  \n    color: hsla(0, 100%, 50%, 67%);  \n    color: hsl(0deg 100% 50% / 67%);  \n}  </code></pre></div></figure>\n<p>小提示：在 Chrome DevTools 中可以按住 shift + 鼠标左键可以切换颜色的表示方式。</p>\n<p><img src=\"https://cimg1.17lai.fun/data/2021/09/1220210912160642.gif\" alt=\"\"></p>\n<h3 id=\"媒体查询\">媒体查询</h3>\n<p>媒体查询是指针对不同的设备、特定的设备特征或者参数进行定制化的修改网站的样式。</p>\n<p>你可以通过给 <code>&lt;link&gt;</code> 加上 media 属性来指定该样式文件只能对什么设备生效，不指定的话默认是 all，即对所有设备都生效：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-css\" data-language=\"css\"><code class=\"language-css\">&lt;link rel=\"stylesheet\" src=\"styles.css\" media=\"screen\" /&gt;  \n&lt;link rel=\"stylesheet\" src=\"styles.css\" media=\"print\" /&gt;  </code></pre></div></figure>\n<p>都支持哪些设备类型？</p>\n<ul>\n<li>\n<p>all：适用于所有设备；</p>\n</li>\n<li>\n<p>print：适用于在打印预览模式下在屏幕上查看的分页材料和文档；</p>\n</li>\n<li>\n<p>screen：主要用于屏幕；</p>\n</li>\n<li>\n<p>speech：主要用于语音合成器。</p>\n</li>\n</ul>\n<blockquote>\n<p>需要注意的是：通过 media 指定的  资源尽管不匹配它的设备类型，但是浏览器依然会加载它。</p>\n</blockquote>\n<p><img src=\"https://cimg1.17lai.fun/data/2021/09/1220210912155838.png\" alt=\"\"></p>\n<p>除了通过 <code>&lt;link&gt;</code> 让指定设备生效外，还可以通过 <code>@media</code> 让 CSS 规则在特定的条件下才能生效。响应式页面就是使用了 @media 才让一个页面能够同时适配 PC、Pad 和手机端。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-css\" data-language=\"css\"><code class=\"language-css\">@media (min-width: 1000px) {}  </code></pre></div></figure>\n<p>媒体查询支持逻辑操作符：</p>\n<ul>\n<li>\n<p>and：查询条件都满足的时候才生效；</p>\n</li>\n<li>\n<p>not：查询条件取反；</p>\n</li>\n<li>\n<p>only：整个查询匹配的时候才生效，常用语兼容旧浏览器，使用时候必须指定媒体类型；</p>\n</li>\n<li>\n<p>逗号或者 or：查询条件满足一项即可匹配；</p>\n</li>\n</ul>\n<p>媒体查询还支持众多的媒体特性[14]，使得它可以写出很复杂的查询条件：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-css\" data-language=\"css\"><code class=\"language-css\">/* 用户设备的最小高度为680px或为纵向模式的屏幕设备 */  \n@media (min-height: 680px), screen and (orientation: portrait) {}  </code></pre></div></figure>\n<h2 id=\"常见需求\">常见需求</h2>\n<h3 id=\"自定义属性\">自定义属性</h3>\n<p>之前我们通常是在预处理器里才可以使用变量，而现在 CSS 里也支持了变量的用法。通过自定义属性就可以在想要使用的地方引用它。</p>\n<p>自定义属性也和普通属性一样具有级联性，申明在 :root 下的时候，在全文档范围内可用，而如果是在某个元素下申明自定义属性，则只能在它及它的子元素下才可以使用。</p>\n<p>自定义属性必须通过 <code>--x</code> 的格式申明，比如：–theme-color: red; 使用自定义属性的时候，需要用 var 函数。比如：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-css\" data-language=\"css\"><code class=\"language-css\">&lt;!-- 定义自定义属性 --&gt;  \n:root {  \n    --theme-color: red;  \n}\n\n&lt;!-- 使用变量 --&gt;  \nh1 {  \n    color: var(--theme-color);  \n}\n</code></pre></div></figure>\n<p><img src=\"https://cimg1.17lai.fun/data/2021/09/1220210912155818.png\" alt=\"\"></p>\n<p>上图这个是使用 CSS 自定义属性配合 JS 实现的动态调整元素的 box-shadow，具体可以看这个 codepen demo。</p>\n<h3 id=\"1px-边框解决方案\">1px 边框解决方案</h3>\n<p>Retina 显示屏比普通的屏幕有着更高的分辨率，所以在移动端的 1px 边框就会看起来比较粗，为了美观通常需要把这个线条细化处理。这里有篇文章列举了 7 中方案可以参考一下：7种方法解决移动端Retina屏幕1px边框问题[15]</p>\n<p>而这里附上最后一种通过伪类和 transform 实现的相对完美的解决方案：</p>\n<p>只设置单条底部边框：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-css\" data-language=\"css\"><code class=\"language-css\">.scale-1px-bottom {  \n    position: relative;  \n    border:none;  \n}  \n.scale-1px-bottom::after {  \n    content: '';  \n    position: absolute;  \n    left: 0;  \n    bottom: 0;  \n    background: #000;  \n    width: 100%;  \n    height: 1px;  \n    -webkit-transform: scaleY(0.5);  \n    transform: scaleY(0.5);  \n    -webkit-transform-origin: 0 0;  \n    transform-origin: 0 0;  \n}  </code></pre></div></figure>\n<p>同时设置 4 条边框：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-css\" data-language=\"css\"><code class=\"language-css\">.scale-1px {  \n    position: relative;  \n    margin-bottom: 20px;  \n    border:none;  \n}  \n.scale-1px::after {  \n    content: '';  \n    position: absolute;  \n    top: 0;  \n    left: 0;  \n    border: 1px solid #000;  \n    -webkit-box-sizing: border-box;  \n    box-sizing: border-box;  \n    width: 200%;  \n    height: 200%;  \n    -webkit-transform: scale(0.5);  \n    transform: scale(0.5);  \n    -webkit-transform-origin: left top;  \n    transform-origin: left top;  \n}  </code></pre></div></figure>\n<h3 id=\"清除浮动\">清除浮动</h3>\n<p>什么是浮动：浮动元素会脱离文档流并向左/向右浮动，直到碰到父元素或者另一个浮动元素。</p>\n<p>为什么要清楚浮动，它造成了什么问题？</p>\n<p>因为浮动元素会脱离正常的文档流，并不会占据文档流的位置，所以如果一个父元素下面都是浮动元素，那么这个父元素就无法被浮动元素所撑开，这样一来父元素就丢失了高度，这就是所谓的浮动造成的父元素高度坍塌问题。</p>\n<p>父元素高度一旦坍塌将对后面的元素布局造成影响，为了解决这个问题，所以需要清除浮动，让父元素恢复高度，那该如何做呢？</p>\n<p>这里介绍两种方法：通过 BFC 来清除、通过 clear 来清除。</p>\n<h4 id=\"BFC-清除浮动\">BFC 清除浮动</h4>\n<p>前面介绍 BFC 的时候提到过，计算 BFC 高度的时候浮动子元素的高度也将计算在内，利用这条规则就可以清楚浮动。</p>\n<p>假设一个父元素 parent 内部只有 2 个子元素 child，且它们都是左浮动的，这个时候 parent 如果没有设置高度的话，因为浮动造成了高度坍塌，所以 parent 的高度会是 0，此时只要给 parent 创造一个 BFC，那它的高度就能恢复了。</p>\n<p>而产生 BFC 的方式很多，我们可以给父元素设置overflow: auto 来简单的实现 BFC 清除浮动，但是为了兼容 IE 最好用 overflow: hidden。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-none\"><code class=\"language-none\">.parent {  \n    overflow: hidden;  \n}  </code></pre></div></figure>\n<p>通过 overflow: hidden 来清除浮动并不完美，当元素有阴影或存在下拉菜单的时候会被截断，所以该方法使用比较局限。</p>\n<h4 id=\"通过-clear-清除浮动\">通过 clear 清除浮动</h4>\n<p>我先把结论贴出来：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-none\"><code class=\"language-none\">.clearfix {  \n    zoom: 1;  \n}  \n.clearfix::after {  \n    content: \"\";  \n    display: block;  \n    clear: both;  \n}  </code></pre></div></figure>\n<p>这种写法的核心原理就是通过 ::after 伪元素为在父元素的最后一个子元素后面生成一个内容为空的块级元素，然后通过 clear 将这个伪元素移动到所有它之前的浮动元素的后面，画个图来理解一下。</p>\n<p><img src=\"https://cimg1.17lai.fun/data/2021/09/1220210912155806.png\" alt=\"\"></p>\n<p>可以结合这个 codepen demo 一起理解上图的 clear 清楚浮动原理。</p>\n<p>上面这个 demo 或者图里为了展示需要所以给伪元素的内容设置为了 ::after，实际使用的时候需要设置为空字符串，让它的高度为 0，从而父元素的高度都是由实际的子元素撑开。</p>\n<p>该方式基本上是现在人人都在用的清除浮动的方案，非常通用。</p>\n<p>参考：CSS中的浮动和清除浮动，梳理一下[16]</p>\n<h3 id=\"消除浏览器默认样式\">消除浏览器默认样式</h3>\n<p>针对同一个类型的 HTML 标签，不同的浏览器往往有不同的表现，所以在网站制作的时候，开发者通常都是需要将这些浏览器的默认样式清除，让网页在不同的浏览器上能够保持一致。</p>\n<p>针对清除浏览器默认样式这件事，在很早之前 CSS 大师 Eric A. Meyer 就干过。它就是写一堆通用的样式用来重置浏览器默认样式，这些样式通常会放到一个命名为 reset.css 文件中。比如大师的 reset.css[17] 是这么写的：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-css\" data-language=\"css\"><code class=\"language-css\">html, body, div, span, applet, object, iframe,  \nh1, h2, h3, h4, h5, h6, p, blockquote, pre,  \na, abbr, acronym, address, big, cite, code,  \ndel, dfn, em, img, ins, kbd, q, s, samp,  \nsmall, strike, strong, sub, sup, tt, var,  \nb, u, i, center,  \ndl, dt, dd, ol, ul, li,  \nfieldset, form, label, legend,  \ntable, caption, tbody, tfoot, thead, tr, th, td,  \narticle, aside, canvas, details, embed,   \nfigure, figcaption, footer, header, hgroup,   \nmenu, nav, output, ruby, section, summary,  \ntime, mark, audio, video {  \n    margin: 0;  \n    padding: 0;  \n    border: 0;  \n    font-size: 100%;  \n    font: inherit;  \n    vertical-align: baseline;  \n}  \n/* HTML5 display-role reset for older browsers */  \narticle, aside, details, figcaption, figure,   \nfooter, header, hgroup, menu, nav, section {  \n    display: block;  \n}  \nbody {  \n    line-height: 1;  \n}  \nol, ul {  \n    list-style: none;  \n}  \nblockquote, q {  \n    quotes: none;  \n}  \nblockquote:before, blockquote:after,  \nq:before, q:after {  \n    content: '';  \n    content: none;  \n}  \ntable {  \n    border-collapse: collapse;  \n    border-spacing: 0;  \n}  </code></pre></div></figure>\n<p>他的这份 reset.css 据说是被使用最广泛的重设样式的方案了。</p>\n<p>除了 reset.css 外，后来又出现了 Normalize.css[18] 。关于 Normalize.css, 其作者 necolas 专门写了一篇文章介绍了它，并谈到了它和 reset.css 的区别。这个是他写那篇文章的翻译版：让我们谈一谈 Normalize.css[19]。</p>\n<p>文章介绍到：Normalize.css 只是一个很小的CSS文件，但它在默认的 HTML 元素样式上提供了跨浏览器的高度一致性。相比于传统的 CSS reset，Normalize.css 是一种现代的、为 HTML5 准备的优质替代方案，现在已经有很多知名的框架和网站在使用它了。</p>\n<p>Normalize.css 的具体样式可以看这里 Normalize.css</p>\n<p>区别于 reset.css，Normalize.css 有如下特点：</p>\n<ul>\n<li>\n<p>reset.css 几乎为所有标签都设置了默认样式，而 Normalize.css 则是有选择性的保护了部分有价值的默认值；</p>\n</li>\n<li>\n<p>修复了很多浏览器的 bug，而这是 reset.css 没做到的；</p>\n</li>\n<li>\n<p>不会让你的调试工具变的杂乱，相反 reset.css 由于设置了很多默认值，所以在浏览器调试工具中往往会看到一大堆的继承样式，显得很杂乱；</p>\n</li>\n<li>\n<p>Normalize.css 是模块化的，所以可以选择性的去掉永远不会用到的部分，比如表单的一般化；</p>\n</li>\n<li>\n<p>Normalize.css 有详细的说明文档；</p>\n</li>\n</ul>\n<h3 id=\"长文本处理\">长文本处理</h3>\n<p><strong>默认：字符太长溢出了容器</strong></p>\n<p><img src=\"https://cimg1.17lai.fun/data/2021/09/1220210912155744.png\" alt=\"\"></p>\n<p><strong>字符超出部分换行</strong></p>\n<p><img src=\"https://cimg1.17lai.fun/data/2021/09/1420210914005529.png\" alt=\"\"></p>\n<p><strong>字符超出位置使用连字符</strong></p>\n<p><img src=\"https://cimg1.17lai.fun/data/2021/09/1220210912155738.png\" alt=\"\"></p>\n<p><strong>单行文本超出省略</strong></p>\n<p><img src=\"https://cimg1.17lai.fun/data/2021/09/1420210914005537.png\" alt=\"\"></p>\n<p><strong>多行文本超出省略</strong></p>\n<p><img src=\"https://cimg1.17lai.fun/data/2021/09/1420210914005552.png\" alt=\"\"></p>\n<p>查看以上这些方案的示例： codepen demo</p>\n<p>有意思的是刚好前两天看到 chokcoco 针对文本溢出也写了一篇文章，主要突出的是对整块的文本溢出处理。啥叫整块文本？比如，下面这种技术标签就是属于整块文本：</p>\n<p><img src=\"https://cimg1.17lai.fun/data/2021/09/1220210912155731.png\" alt=\"\"></p>\n<p>另外他还对 iOS/Safari 做了兼容处理，感兴趣的可以去阅读下：CSS 整块文本溢出省略特性探究[20]。</p>\n<h3 id=\"水平垂直居中\">水平垂直居中</h3>\n<p>让元素在父元素中呈现出水平垂直居中的形态，无非就 2 种情况：</p>\n<ul>\n<li>\n<p>单行的文本、inline 或者 inline-block 元素；</p>\n</li>\n<li>\n<p>固定宽高的块级盒子；</p>\n</li>\n<li>\n<p>不固定宽高的块级盒子；</p>\n</li>\n</ul>\n<p>以下列到的所有水平垂直居中方案这里写了个 codepen demo，配合示例阅读效果更佳。</p>\n<h4 id=\"单行的文本、inline-或-inline-block-元素\">单行的文本、inline 或 inline-block 元素</h4>\n<p><strong>水平居中</strong></p>\n<p>此类元素需要水平居中，则父级元素必须是块级元素(<code>block level</code>)，且父级元素上需要这样设置样式：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-none\"><code class=\"language-none\">.parent {  \n    text-align: center;  \n}  </code></pre></div></figure>\n<p><strong>垂直居中</strong></p>\n<p>方法一：通过设置上下内间距一致达到垂直居中的效果：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-none\"><code class=\"language-none\">.single-line {  \n    padding-top: 10px;  \n    padding-bottom: 10px;  \n}  </code></pre></div></figure>\n<p>方法二：通过设置 <code>height</code> 和 <code>line-height</code> 一致达到垂直居中：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-none\"><code class=\"language-none\">.single-line {  \n    height: 100px;  \n    line-height: 100px;  \n}  </code></pre></div></figure>\n<h4 id=\"固定宽高的块级盒子\">固定宽高的块级盒子</h4>\n<p><strong>方法一：absolute + 负 margin</strong></p>\n<p><img src=\"https://cimg1.17lai.fun/data/2021/09/1420210914005614.png\" alt=\"\"></p>\n<p><strong>方法二：absolute + margin auto</strong></p>\n<p><img src=\"https://cimg1.17lai.fun/data/2021/09/1220210912155724.png\" alt=\"\"></p>\n<p><strong>方法三：absolute + calc</strong></p>\n<p><img src=\"https://cimg1.17lai.fun/data/2021/09/1420210914005620.png\" alt=\"\"></p>\n<h4 id=\"不固定宽高的块级盒子\">不固定宽高的块级盒子</h4>\n<p>这里列了 6 种方法，参考了颜海镜 写的文章 ，其中的两种 line-height 和 writing-mode 方案看后让我惊呼：还有这种操作？学到了学到了。</p>\n<p><strong>方法一：absolute + transform</strong></p>\n<p><img src=\"https://cimg1.17lai.fun/data/2021/09/1220210912155717.png\" alt=\"\"></p>\n<p><strong>方法二：line-height + vertical-align</strong></p>\n<p><img src=\"https://cimg1.17lai.fun/data/2021/09/1420210914005627.png\" alt=\"\"></p>\n<p><strong>方法三：writing-mode</strong></p>\n<p><img src=\"https://cimg1.17lai.fun/data/2021/09/1420210914005633.png\" alt=\"\"></p>\n<p><strong>方法四：table-cell</strong></p>\n<p><img src=\"https://cimg1.17lai.fun/data/2021/09/1420210914005634.png\" alt=\"\"></p>\n<p><strong>方法五：flex</strong></p>\n<p><img src=\"https://cimg1.17lai.fun/data/2021/09/1220210912155710.png\" alt=\"\"></p>\n<p><strong>方法六：grid</strong></p>\n<p><img src=\"https://cimg1.17lai.fun/data/2021/09/1220210912155704.png\" alt=\"\"></p>\n<h3 id=\"常用布局\">常用布局</h3>\n<h4 id=\"两栏布局（边栏定宽主栏自适应）\">两栏布局（边栏定宽主栏自适应）</h4>\n<p>针对以下这些方案写了几个示例： codepen demo</p>\n<p><strong>方法一：float + overflow（BFC 原理）</strong></p>\n<p><img src=\"https://cimg1.17lai.fun/data/2021/09/1420210914005646.png\" alt=\"\"></p>\n<p><strong>方法二：float + margin</strong></p>\n<p><img src=\"https://cimg1.17lai.fun/data/2021/09/1220210912155657.png\" alt=\"\"></p>\n<p><strong>方法三：flex</strong></p>\n<p><img src=\"https://cimg1.17lai.fun/data/2021/09/1420210914005701.png\" alt=\"\"></p>\n<p><strong>方法四：grid</strong></p>\n<p><img src=\"https://cimg1.17lai.fun/data/2021/09/1220210912155650.png\" alt=\"\"></p>\n<h4 id=\"三栏布局（两侧栏定宽主栏自适应）\">三栏布局（两侧栏定宽主栏自适应）</h4>\n<p>针对以下这些方案写了几个示例： codepen demo</p>\n<p><strong>方法一：圣杯布局</strong></p>\n<p><img src=\"https://cimg1.17lai.fun/data/2021/09/1220210912155616.png\" alt=\"\"></p>\n<p><strong>方法二：双飞翼布局</strong></p>\n<p><img src=\"https://cimg1.17lai.fun/data/2021/09/1220210912155643.png\" alt=\"\"></p>\n<p><strong>方法三：float + overflow（BFC 原理）</strong></p>\n<p><img src=\"https://cimg1.17lai.fun/data/2021/09/1220210912155556.png\" alt=\"\"></p>\n<p><strong>方法四：flex</strong></p>\n<p><img src=\"https://cimg1.17lai.fun/data/2021/09/1220210912155633.png\" alt=\"\"></p>\n<p><strong>方法五：grid</strong></p>\n<p><img src=\"https://cimg1.17lai.fun/data/2021/09/1220210912155549.png\" alt=\"\"></p>\n<h4 id=\"多列等高布局\">多列等高布局</h4>\n<p>结合示例阅读更佳：codepen demo</p>\n<p><strong>方法一：padding + 负margin</strong></p>\n<p><img src=\"https://cimg1.17lai.fun/data/2021/09/1420210914005719.png\" alt=\"\"></p>\n<p><strong>方法二：设置父级背景图片</strong></p>\n<p><img src=\"https://cimg1.17lai.fun/data/2021/09/1220210912155542.png\" alt=\"\"></p>\n<h4 id=\"三行布局（头尾定高主栏自适应）\">三行布局（头尾定高主栏自适应）</h4>\n<p>列了 4 种方法，都是基于如下的 HTML 和 CSS 的，结合示例阅读效果更佳：codepen demo</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-css\" data-language=\"css\"><code class=\"language-css\">&lt;div class=\"layout\"&gt;  \n    &lt;header&gt;&lt;/header&gt;  \n    &lt;main&gt;  \n        &lt;div class=\"inner\"&gt;&lt;/div&gt;  \n    &lt;/main&gt;  \n    &lt;footer&gt;&lt;/footer&gt;  \n&lt;/div&gt;  </code></pre></div></figure>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-css\" data-language=\"css\"><code class=\"language-css\">html,  \nbody,  \n.layout {  \n    height: 100%;  \n}  \nbody {  \n    margin: 0;  \n}  \nheader,   \nfooter {  \n    height: 50px;  \n}  \nmain {  \n    overflow-y: auto;  \n}  </code></pre></div></figure>\n<p><strong>方法一：calc</strong></p>\n<p><img src=\"https://cimg1.17lai.fun/data/2021/09/1220210912155519.png\" alt=\"\"></p>\n<p><strong>方法二：absolute</strong></p>\n<p><img src=\"https://cimg1.17lai.fun/data/2021/09/1220210912155509.png\" alt=\"\"></p>\n<p><strong>方法三：flex</strong></p>\n<p><img src=\"https://cimg1.17lai.fun/data/2021/09/1220210912155502.png\" alt=\"\"></p>\n<p><strong>方法四：grid</strong></p>\n<p><img src=\"https://cimg1.17lai.fun/data/2021/09/1220210912155500.png\" alt=\"\"></p>\n<h2 id=\"结了个尾\">结了个尾</h2>\n<p>这是我断断续续写了 2 周完成的文章，算是自己对 CSS 的一个总结，虽然写得很长，但不足以覆盖所有 CSS 的知识，比如动画和一些 CSS3 的新特性就完全没涉及，因为这要写下来估计得有大几万字（其实就是懒 😝 ）。</p>\n<p>码字作图不易，如果喜欢或者对你有丝毫帮助的话，帮忙点个👍 哈，点赞就是我的动力。同时也希望自己能坚持认真的写下去，因为在总结提升自己的同时如果也能帮助更多的前端er，那将会让我感觉很开心。</p>\n<h3 id=\"参考资料\">参考资料</h3>\n<ul>\n<li>\n<p>[1] <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/@charset\">@charset: </a></p>\n</li>\n<li>\n<p>[2] <a href=\"https://en.wikipedia.org/wiki/Byte_order_mark\">Byte order mark: </a></p>\n</li>\n<li>\n<p>[3] <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/@import\">@import: </a></p>\n</li>\n<li>\n<p>[4] <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/@supports\">@supports: </a></p>\n</li>\n<li>\n<p>[5] <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Selectors\">MDN CSS Selectors: </a></p>\n</li>\n<li>\n<p>[6] <a href=\"https://www.w3.org/TR/CSS2/visuren.html\">Visual formatting model: </a></p>\n</li>\n<li>\n<p>[7] <a href=\"https://yachen168.github.io/article/display.html\">CSS 原理 - 你所不知道的 display: </a></p>\n</li>\n<li>\n<p>[8] <a href=\"https://ithelp.ithome.com.tw/articles/10223896?sc=pt\">格式化上下文: </a></p>\n</li>\n<li>\n<p>[9] <a href=\"https://yachen168.github.io/article/Formatting-context.html\">CSS 原理 - Formatting Context: </a></p>\n</li>\n<li>\n<p>[10] <a href=\"https://www.w3.org/TR/CSS2/visuren.html#inline-formatting\">Inline formatting contexts: </a></p>\n</li>\n<li>\n<p>[11] <a href=\"https://juejin.cn/post/6844903667175260174\">彻底搞懂CSS层叠上下文、层叠等级、层叠顺序、z-index: </a></p>\n</li>\n<li>\n<p>[12] <a href=\"https://drafts.csswg.org/css-color-3/\">CSS 颜色草案: </a></p>\n</li>\n<li>\n<p>[13] <a href=\"https://codepen.io/bulandent/pen/gOLovwL\">完整的色彩关键字列表: </a></p>\n</li>\n<li>\n<p>[14] <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Media_queries#%E5%AA%92%E4%BD%93%E7%89%B9%E6%80%A7\">众多的媒体特性: </a></p>\n</li>\n<li>\n<p>[15] <a href=\"https://www.jianshu.com/p/7e63f5a32636\">7种方法解决移动端Retina屏幕1px边框问题: </a></p>\n</li>\n<li>\n<p>[16] <a href=\"https://www.jianshu.com/p/09bd5873bed4\">CSS中的浮动和清除浮动，梳理一下: </a></p>\n</li>\n<li>\n<p>[17] <a href=\"https://meyerweb.com/eric/tools/css/reset/\">reset.css: </a></p>\n</li>\n<li>\n<p>[18] <a href=\"https://github.com/necolas/normalize.css\">Normalize.css: </a></p>\n</li>\n<li>\n<p>[19] <a href=\"https://jerryzou.com/posts/aboutNormalizeCss/\">让我们谈一谈 Normalize.css: </a></p>\n</li>\n<li>\n<p>[20] <a href=\"https://juejin.cn/post/6938583040469762055\">CSS 整块文本溢出省略特性探究: </a></p>\n</li>\n</ul>\n<p>编辑整理From <a href=\"https://mp.weixin.qq.com/s/UtYENocSsl0R10h8fww7Iw\">https://mp.weixin.qq.com/s/UtYENocSsl0R10h8fww7Iw</a></p>\n",
            "tags": [
                "web",
                "http",
                "ccs"
            ]
        },
        {
            "id": "https://blog.17lai.site/posts/69a052c9/",
            "url": "https://blog.17lai.site/posts/69a052c9/",
            "title": "浏览器的渲染过程",
            "date_published": "2021-09-13T14:25:00.000Z",
            "content_html": "<blockquote>\n<p>通常，我们只需要编写HTML，CSS，JavaScript，浏览器上就能呈现出漂亮的网页了，但是浏览器是如何使用我们的代码在屏幕上渲染像素的呢？</p>\n</blockquote>\n<h3 id=\"首先，请先看一张大图\"><strong>首先，请先看一张大图</strong></h3>\n<p>浏览器将HTML，CSS，JavaScript代码转换成屏幕上所能呈现的实际像素，这期间所经历的一系列步骤，叫做关键渲染路径（Critical Rendering Path）。其中包含：</p>\n<ul>\n<li>构建对象模型（DOM，CSSOM）</li>\n<li>构建渲染树（RenderTree）</li>\n<li>布局</li>\n<li>渲染</li>\n</ul>\n<p>在构建对象模型到构建渲染树的这一过程，还穿插着JS脚本的加载和执行。如下图所示：</p>\n<p><img src=\"https://cimg1.17lai.fun/data/2021/09/1320210913220512.jpeg\" alt=\"\"></p>\n<h3 id=\"1-DOMTree的构建\"><strong>1.DOMTree的构建</strong></h3>\n<p>浏览器的渲染从解析HTML文档开始，宏观上，可以分为下面几个步骤：</p>\n<p><img src=\"https://cimg1.17lai.fun/data/2021/09/1320210913220515.jpeg\" alt=\"\"></p>\n<ul>\n<li>第一步（解析）：从网络或者磁盘下读取的HTML原始字节码，通过设置的charset编码，转换成相字符</li>\n</ul>\n<p><img src=\"https://cimg1.17lai.fun/data/2021/09/1320210913220653.jpeg\" alt=\"\"></p>\n<ul>\n<li>第二步（token化）：通过词法分析器，将字符串解析成Token，Token中会标注出当前的Token是<code>开始标签</code>，还是<code>结束标签</code>，或者<code>文本标签</code>等。</li>\n</ul>\n<p><img src=\"https://cimg1.17lai.fun/data/2021/09/1320210913220522.jpeg\" alt=\"\"></p>\n<ul>\n<li>第三步（生成Nodes并构建DOM树）：浏览器会根据Tokens里记录的<code>开始标签</code>，<code>结束标签</code>，将Tokens之间相互串联起来_（带有结束标签的Token不会生成Node）_。<br>\nNode包含了这个节点的所有属性。例如<code>&lt;img src=\"xxx.png\" &gt;</code>标签最终生成出的节点对象中会保存图片地址等信息。<br>\n事实上，在构建DOM树时，不是要等所有的Tokens都转换成Nodes后才开始，而是一边生成Token一边采取<code>深度遍历算法</code>消耗Token来生成Node，如下图所示：<br>\n图中有颜色的小数字代表构建的具体步骤，可以看出，首先生成出<code>html Token</code>,并消耗Token创建出<code>html 节点对象</code>，接着生成<code>head Token</code>并消耗Token创建出<code>head节点对象</code>…，当所有的Tokens都消耗完了，紧接着DOM树也就构建完了。</li>\n</ul>\n<p><img src=\"https://cimg1.17lai.fun/data/2021/09/1320210913220658.jpeg\" alt=\"\"></p>\n<p>这里抛出个小问题，为什么有时在js中访问DOM时浏览器会报错呢？<br>\n因为在上述的解析的过程中，如果碰到了<code>script</code>或者<code>link</code>标签，就会根据<code>src</code>对应的地址去加载资源，在<code>script</code>标签没有设置<code>async/defer</code>属性时，这个加载过程是<code>下载并执行完全部的代码</code>，此时，DOM树还没有完全创建完毕，这个时候如果js企图访问script标签后面的DOM元素，浏览器就会抛出<strong>找不到该DOM元素</strong>的错误。<br>\n值得注意的是：从bytes到Tokens的这个过程，浏览器都可以交给其他单独的线程去处理，不会堵塞浏览器的渲染线程。但是后面的部分就都在渲染线程下进行了，也就是我们常说的js单线程环境。</p>\n<h3 id=\"2-CSSOMTree的构建\"><strong>2.CSSOMTree的构建</strong></h3>\n<p>DOM会记录页面的内容，但是浏览器还需要知道这些内容该用什么样式去展示，所以还需要构建CSSOMTree。CSSOM的生成过程和DOM的生成过程十分相似，也是：1.解析，2.Token化，3.生成Nodes并构建CSSOMTree：</p>\n<p>假设浏览器收到了下面这样一段css:</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-css\" data-language=\"css\"><code class=\"language-css\">body {font-size: 16px;}\np {font-weight: bold;}\np span {display:none;}\nspan {color: red;}\nimg {float: right;}</code></pre></div></figure>\n<p>最终会生成如下的CSSOMTree:</p>\n<p><img src=\"https://cimg1.17lai.fun/data/2021/09/1320210913220529.jpeg\" alt=\"\"></p>\n<p>从图中可以看出，最开始<code>body</code>有一个样式规则是<code>font-size:16px</code>，之后，在body这个样式基础上每个子节点还会添加自己单独的样式规则，比如<code>span</code>又添加了一个样式规则<code>color:red</code>。正是因为样式这种类似于继承的特性，浏览器设定了一条规则：<strong>CSSOMTree需要等到完全构建后才可以被使用，因为后面的属性可能会覆盖掉前面的设置</strong>。比如在上面的css代码基础上再添加一行代码<code>p {font-size:12px}</code>，那么之前设置的<code>16px</code>将会被覆盖成<code>12px</code>。</p>\n<p>下面是官方给的一种解释：</p>\n<blockquote>\n<p>未构建完的CSSOMTree是不准确的，浏览器必须等到CSSOMTree构建完毕后才能进入下一阶段。<br>\n所以，CSS的加载速度与构建CSSOMTree的速度将直接影响首屏渲染速度，因此在默认情况下CSS被视为阻塞渲染的资源，需要将它尽早、尽快地下载到客户端，以便缩短首次渲染的时间。</p>\n</blockquote>\n<p>那么回到上面生成DOM时提到的JS问题：<strong>在标签没有设置<code>async/defer</code>属性时，js会阻塞DOM的生成</strong>。原因是js会改变DOMTree的内容，如果不阻塞，会出现一边生成DOM内容，一边修改DOM内容的情况，无法确保最终生成的DOMTree是确定唯一的。</p>\n<p>同理，JS也会可以修改CSS样式，影响CSSOMTree最终的结果。而我们前面提到，不完整的CSSOMTree是不可以被使用的，如果JS试图在<strong>浏览器还未完成CSSOMTree的下载和构建</strong>时去操作CSS样式，浏览器会<strong>暂停脚本的运行和DOM的构建</strong>，直至浏览器完成了CSSOM的下载和构建。也就是说，<strong>JS脚本的出现会让CSSOM的构建阻塞DOM的构建</strong>。</p>\n<blockquote>\n<p>平时谈及页面性能优化，经常会强调css文件应该放在html文档中的前面引入，js文件应该放在后面引入，这么做的原因是什么呢？</p>\n</blockquote>\n<p>举个例子：本来，DOM构建和CSSOM构建是两个过程，井水不犯河水。假设DOM构建完成需要1s，CSSOM构建也需要1s，在DOM构建了0.2s时发现了一个<code>link</code>标签，此时完成这个操作需要的时间大概是1.2s，如下图所示：</p>\n<p><img src=\"https://cimg1.17lai.fun/data/2021/09/1320210913220540.jpeg\" alt=\"\"></p>\n<p>而此时我们在HTML文档的中间插中入了一段JS代码，在DOM构建中间的过程中发现了这个<code>script</code>标签，假设这段JS代码只需要执行0.0001s，那么完成这个操作需要的时间就会变成：</p>\n<p><img src=\"https://cimg1.17lai.fun/data/2021/09/1320210913220546.jpeg\" alt=\"\"></p>\n<p>那如果我们把css放到前面，js放到最后引入时，构建时间会变成：</p>\n<p><img src=\"https://cimg1.17lai.fun/data/2021/09/1320210913220705.jpeg\" alt=\"\"></p>\n<p>由此可见，虽然只是插入了小小的一段只运行0.0001s的js代码，不同的引入时机也会严重影响DOMTree的构建速度。</p>\n<p>简而言之，如果在DOM，CSSOM和JavaScript执行之间引入大量的依赖关系，可能会导致浏览器在处理渲染资源时出现大幅度延迟：</p>\n<ul>\n<li>当浏览器遇到一个script标签时，DOMTree的构建将被暂停，直至脚本执行完毕</li>\n<li>JavaScript可以查询和修改DOMTree与CSSOMTree</li>\n<li>直至CSSOM构建完毕，JavaScript才会执行</li>\n<li>脚本在文档中的位置很重要</li>\n</ul>\n<h3 id=\"3-渲染树的构建\"><strong>3.渲染树的构建</strong></h3>\n<p>现在，我们已经拥有了完整的DOM树和CSSOM树。DOM 树上每一个节点对应着网页里每一个元素，CSSOM树上每个节点对应着网页里每个元素的样式，并且此时浏览器也可以通过 JavaScript 操作DOM/CSSOM树，动态改变它的结构。但是DOM/CSSOM树本身并不能直接用于排版和渲染，浏览器还会生成另外一棵树：Render树</p>\n<p><img src=\"https://cimg1.17lai.fun/data/2021/09/1320210913220711.jpeg\" alt=\"\"></p>\n<p>接下来我们来谈几条概念</p>\n<ul>\n<li>\n<p>Render 树上的每一个节点被称为：<code>RenderObject</code>。</p>\n</li>\n<li>\n<p>RenderObject跟 DOM 节点几乎是一一对应的，当一个<code>可见的 DOM 节点</code>被添加到 DOM 树上时，内核就会为它生成对应的 RenderOject 添加到 Render 树上。</p>\n</li>\n<li>\n<p>其中，可见的DOM节点不包括：</p>\n</li>\n<li>\n<p>一些不会体现在渲染输出中的节点（<code>&lt;html&gt;&lt;script&gt;&lt;link&gt;….</code>），会直接被忽略掉。</p>\n</li>\n<li>\n<p>通过CSS隐藏的节点。例如上图中的<code>span</code>节点，因为有一个CSS显式规则在该节点上设置了<code>display:none</code>属性，那么它在生成RenderObject时会被直接忽略掉。</p>\n</li>\n<li>\n<p>Render 树是衔接浏览器排版引擎和渲染引擎之间的<strong>桥梁</strong>，它是<strong>排版引擎的输出，渲染引擎的输入</strong>。</p>\n</li>\n</ul>\n<p>此时的Render树上，已经包含了网页上所有可见元素的内容和位置信息 排版引擎会根据Render树的内容和结构，准确的计算出元素该在网页上的什么位置。到此，我们已经具备进入布局的一切准备条件，但是通过上面我们知道，布局后面还有一个渲染过程，那么_Render 树是衔接浏览器排版引擎和渲染引擎之间的桥梁，它是排版引擎的输出，渲染引擎的输入。_这句话是什么意思呢？</p>\n<h3 id=\"RenderObject-and-RenderLayer\"><strong>RenderObject and RenderLayer</strong></h3>\n<blockquote>\n<p>浏览器渲染引擎并不是直接使用Render树进行绘制，为了方便处理<strong>Positioning,Clipping,Overflow-scroll,CSS Transfrom/Opacrity/Animation/Filter,Mask or Reflection,Z-indexing</strong>等属性，浏览器需要生成另外一棵树：<strong>Layer树</strong></p>\n</blockquote>\n<p><img src=\"https://cimg1.17lai.fun/data/2021/09/1320210913220730.jpeg\" alt=\"\"></p>\n<p>浏览器会为一些<strong>特定</strong>的<code>RenderObject</code>生成对应的<code>RenderLayer</code>，其中的规则是：</p>\n<ul>\n<li>是否是页面的根节点 <em>It’s the root object for the page</em></li>\n<li>是否有css的一些布局属性（relative absolute or a transform) <em>It has explicit CSS position properties (relative, absolute or a transform)</em></li>\n<li>是否透明 <em>It is transparent</em></li>\n<li>是否有溢出 <em>Has overflow, an alpha mask or reflection</em></li>\n<li>是否有css滤镜 <em>Has a CSS filter</em></li>\n<li>是否包含一个canvas元素使得节点拥有视图上下文 <em>Corresponds to canvas element that has a 3D (WebGL) context or an accelerated 2D context</em></li>\n<li>是否包含一个video元素 <em>Corresponds to a video element</em></li>\n</ul>\n<p>当满足上面其中一个条件时，这个<code>RrenderObject</code>就会被浏览器选中生成对应的<code>RenderLayer</code>。至于那些没有被命运选中的RrenderObject，会从属与父节点的RenderLayer。最终，每个RrenderObject都会直接或者间接的属于一个RenderLayer。</p>\n<p>浏览器渲染引擎在布局和渲染时会遍历整个Layer树，访问每一个<code>RenderLayer</code>，再遍历从属于这个RenderLayer的 <code>RrenderObject</code>，将每一个 RenderObject 绘制出来。可以理解为：Layer 树决定了网页绘制的层次顺序，而从属于RenderLayer 的 RrenderObject决定了这个 Layer 的内容，所有的 <code>RenderLayer</code> 和 <code>RrenderObject</code> 一起就决定了网页在屏幕上最终呈现出来的内容。</p>\n<h3 id=\"4-布局\"><strong>4.布局</strong></h3>\n<p>到目前为止，浏览器计算出了哪些节点是可见的以及它的信息和样式，接下来就需要计算这些节点在设备视口内的确切位置和大小，这个过程我们称之为“布局”。</p>\n<p>布局最后的输出是一个“盒模型”：将所有相对测量值都转换成屏幕上的绝对像素。</p>\n<p><img src=\"https://cimg1.17lai.fun/data/2021/09/1320210913220553.jpeg\" alt=\"\"></p>\n<h3 id=\"5-渲染\"><strong>5.渲染</strong></h3>\n<p>最后，既然我们知道了哪些节点可见、它们的计算样式以及几何信息，我们终于可以将这些信息传递给最后一个阶段：将渲染树中的每个节点转换成屏幕上的实际像素：浏览器通过发出“Paint Setup”和“Paint”事件，将渲染树转换成屏幕上的像素。</p>\n<p><img src=\"https://cimg1.17lai.fun/data/2021/09/1320210913220718.jpeg\" alt=\"\"></p>\n<p>至此，我们就能够在浏览器上看到漂亮的网页了</p>\n<blockquote>\n<p>谈及页面性能优化，我们也常说要尽量减少浏览器的重排和重绘，浏览器重排和重绘时究竟做了哪些工作呢？</p>\n</blockquote>\n<p>我们平时常说的重排，其实就是浏览器计算render树，布局到渲染的这个过程，而重绘就是计算layer树到渲染的这个过程，每当触发一次重绘和重排时，浏览器都需要重新经过一遍上述的计算。很显然，重排会产生比重绘更大的开销，但无论是重排还是重绘，都会给浏览器渲染线程造成很大的负担，所以，我们在实际生产中要严格注意减少重排和重绘的触发。至于如何减少重排和重绘的次数，这里就不多做展开了，详细请听下回分解~</p>\n<h3 id=\"总结：\"><strong>总结：</strong></h3>\n<ul>\n<li>经过：1.构建对象模型（DOM，CSSOM），2.构建渲染树（RenderTree），3.布局，4.渲染 这几个步骤后，我们就能在浏览器上看到漂亮的网页啦。</li>\n<li>CSS被视为阻塞渲染的资源，应放到代码的头部尽快加载。</li>\n<li>同步的JavaScript会暂停DOMTree的构建，应放到代码的尾部最后加载，或者使用<code>async/defer属性</code>异步加载JavaScript。</li>\n<li>重排和重绘会给浏览器渲染线程造成很大的负担，尽量减少重排和重绘的触发次数</li>\n</ul>\n<h3 id=\"参考文献：\"><strong>参考文献：</strong></h3>\n<p><a href=\"https://developers.google.com/web/fundamentals/performance/critical-rendering-path/constructing-the-object-model?hl=zh-cn\">https://developers.google.com/web/fundamentals/performance/critical-rendering-path/constructing-the-object-model?hl=zh-cn</a></p>\n<p><a href=\"https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction?hl=zh-cn\">https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction?hl=zh-cn</a></p>\n<p><a href=\"https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-blocking-css?hl=zh-cn\">https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-blocking-css?hl=zh-cn</a></p>\n<p><a href=\"https://mp.weixin.qq.com/s?__biz=MzA5NzkwNDk3MQ==&amp;mid=2650588806&amp;idx=1&amp;sn=408a54e7c8102fd6944c9a40b119015a&amp;scene=21#wechat_redirect\">https://mp.weixin.qq.com/s?__biz=MzA5NzkwNDk3MQ==&amp;mid=2650588806&amp;idx=1&amp;sn=408a54e7c8102fd6944c9a40b119015a&amp;scene=21#wechat_redirect</a></p>\n",
            "tags": [
                "web",
                "http",
                "css",
                "js"
            ]
        },
        {
            "id": "https://blog.17lai.site/posts/656a0abb/",
            "url": "https://blog.17lai.site/posts/656a0abb/",
            "title": "在浏览器输入 URL 回车之后发生了什么",
            "date_published": "2021-09-13T01:25:00.000Z",
            "content_html": "<h2 id=\"前言\">前言</h2>\n<hr>\n<p>这个问题已经是老生常谈了，更是经常被作为面试的压轴题出现，网上也有很多文章，但最近闲的无聊，然后就自己做了一篇笔记，感觉比之前理解更透彻了。</p>\n<p>这篇笔记是我这两天看了数十篇文章总结出来的，所以相对全面一点，但由于我是做前端的，所以会比较重点分析浏览器渲染页面那一部分，至于其他部分我会罗列出关键词，感兴趣的可以自行查阅，</p>\n<p>**注意：**本文的步骤是建立在，请求的是一个简单的 HTTP 请求，没有 HTTPS、HTTP2、最简单的 DNS、没有代理、并且服务器没有任何问题的基础上，尽管这是不切实际的。</p>\n<h2 id=\"大致流程\">大致流程</h2>\n<ol>\n<li>URL 解析</li>\n<li>DNS 查询</li>\n<li>TCP 连接</li>\n<li>处理请求</li>\n<li>接受响应</li>\n<li>渲染页面</li>\n</ol>\n<h2 id=\"一、URL-解析\">一、URL 解析</h2>\n<h3 id=\"地址解析：\"><strong>地址解析：</strong></h3>\n<p>首先判断你输入的是一个合法的 URL 还是一个待搜索的关键词，并且根据你输入的内容进行自动完成、字符编码等操作。</p>\n<h3 id=\"HSTS\"><strong>HSTS</strong></h3>\n<p>由于安全隐患，会使用 HSTS 强制客户端使用 HTTPS 访问页面。详见：<a href=\"https://www.barretlee.com/blog/2015/10/22/hsts-intro/\">你所不知道的 HSTS (opens new window)</a>。</p>\n<h3 id=\"其他操作\"><strong>其他操作</strong></h3>\n<p>浏览器还会进行一些额外的操作，比如安全检查、访问限制（之前国产浏览器限制 996.icu）。</p>\n<h3 id=\"检查缓存\"><strong>检查缓存</strong></h3>\n<p><img src=\"https://cimg1.17lai.fun/data/2021/09/1320210913094301.png\" alt=\"\"></p>\n<h2 id=\"二、DNS-查询\">二、DNS 查询</h2>\n<p><strong>基本步骤</strong></p>\n<p><img src=\"https://cimg1.17lai.fun/data/2021/09/1320210913094305.png\" alt=\"\"></p>\n<h3 id=\"1-浏览器缓存\"><strong>1. 浏览器缓存</strong></h3>\n<p>浏览器会先检查是否在缓存中，没有则调用系统库函数进行查询。</p>\n<h3 id=\"2-操作系统缓存\"><strong>2. 操作系统缓存</strong></h3>\n<p>操作系统也有自己的 DNS 缓存，但在这之前，会向检查域名是否存在本地的 Hosts 文件里，没有则向 DNS 服务器发送查询请求。</p>\n<h3 id=\"3-路由器缓存\"><strong>3. 路由器缓存</strong></h3>\n<p>路由器也有自己的缓存。</p>\n<h3 id=\"4-ISP-DNS-缓存\"><strong>4. ISP DNS 缓存</strong></h3>\n<p>ISP DNS 就是在客户端电脑上设置的首选 DNS 服务器，它们在大多数情况下都会有缓存。</p>\n<h3 id=\"根域名服务器查询\"><strong>根域名服务器查询</strong></h3>\n<p>在前面所有步骤没有缓存的情况下，本地 DNS 服务器会将请求转发到互联网上的根域，下面这个图很好的诠释了整个流程：</p>\n<p><img src=\"https://cimg1.17lai.fun/data/2021/09/1320210913094311.png\" alt=\"\"></p>\n<blockquote>\n<p>根域名服务器：<a href=\"https://zh.wikipedia.org/wiki/%E6%A0%B9%E7%B6%B2%E5%9F%9F%E5%90%8D%E7%A8%B1%E4%BC%BA%E6%9C%8D%E5%99%A8\">维基百科 (opens new window)</a></p>\n</blockquote>\n<p><strong>需要注意的点</strong></p>\n<ol>\n<li>递归方式：一路查下去中间不返回，得到最终结果才返回信息（浏览器到本地 DNS 服务器的过程）</li>\n<li>迭代方式，就是本地 DNS 服务器到根域名服务器查询的方式。</li>\n<li>什么是 DNS 劫持</li>\n<li>前端 dns-prefetch 优化</li>\n</ol>\n<h2 id=\"三、TCP-连接\">三、TCP 连接</h2>\n<p>TCP/IP 分为四层，在发送数据时，每层都要对数据进行封装：</p>\n<p><img src=\"https://cimg1.17lai.fun/data/2021/09/1320210913094325.png\" alt=\"\"></p>\n<h3 id=\"1-应用层：发送-HTTP-请求\"><strong>1. 应用层：发送 HTTP 请求</strong></h3>\n<p>在前面的步骤我们已经得到服务器的 IP 地址，浏览器会开始构造一个 HTTP 报文，其中包括：</p>\n<ul>\n<li>请求报头（Request Header）：请求方法、目标地址、遵循的协议等等</li>\n<li>请求主体（其他参数）</li>\n</ul>\n<p>其中需要注意的点：</p>\n<ul>\n<li>浏览器只能发送 GET、POST 方法，而打开网页使用的是 GET 方法</li>\n</ul>\n<h3 id=\"2-传输层：TCP-传输报文\"><strong>2. 传输层：TCP 传输报文</strong></h3>\n<p>传输层会发起一条到达服务器的 TCP 连接，为了方便传输，会对数据进行分割（以报文段为单位），并标记编号，方便服务器接受时能够准确地还原报文信息。</p>\n<p>在建立连接前，会先进行 TCP 三次握手。</p>\n<blockquote>\n<p>关于 TCP/IP 三次握手，网上已经有很多段子和图片生动地描述了。</p>\n<p>相关知识点：</p>\n<ol>\n<li>SYN 泛洪攻击</li>\n</ol>\n</blockquote>\n<h3 id=\"3-网络层：IP-协议查询-Mac-地址\"><strong>3. 网络层：IP 协议查询 Mac 地址</strong></h3>\n<p>将数据段打包，并加入源及目标的 IP 地址，并且负责寻找传输路线。</p>\n<p>判断目标地址是否与当前地址处于同一网络中，是的话直接根据 Mac 地址发送，否则使用路由表查找下一跳地址，以及使用 ARP 协议查询它的 Mac 地址。</p>\n<blockquote>\n<p>注意：在 OSI 参考模型中 ARP 协议位于链路层，但在 TCP/IP 中，它位于网络层。</p>\n</blockquote>\n<h3 id=\"4-链路层：以太网协议\"><strong>4. 链路层：以太网协议</strong></h3>\n<p><strong>以太网协议</strong></p>\n<p>根据以太网协议将数据分为以“帧”为单位的数据包，每一帧分为两个部分：</p>\n<ul>\n<li>标头：数据包的发送者、接受者、数据类型</li>\n<li>数据：数据包具体内容</li>\n</ul>\n<p><strong>Mac 地址</strong></p>\n<p>以太网规定了连入网络的所有设备都必须具备“网卡”接口，数据包都是从一块网卡传递到另一块网卡，网卡的地址就是 Mac 地址。每一个 Mac 地址都是独一无二的，具备了一对一的能力。</p>\n<p><strong>广播</strong></p>\n<p>发送数据的方法很原始，直接把数据通过 ARP 协议，向本网络的所有机器发送，接收方根据标头信息与自身 Mac 地址比较，一致就接受，否则丢弃。</p>\n<p><strong>注意</strong>：接收方回应是单播。</p>\n<blockquote>\n<p>相关知识点：</p>\n<ol>\n<li>ARP 攻击</li>\n</ol>\n</blockquote>\n<p><strong>服务器接受请求</strong></p>\n<p>接受过程就是把以上步骤逆转过来，参见上图。</p>\n<h2 id=\"四、服务器处理请求\">四、服务器处理请求</h2>\n<p><strong>大致流程</strong></p>\n<p><img src=\"https://cimg1.17lai.fun/data/2021/09/1320210913094339.png\" alt=\"\"></p>\n<h3 id=\"HTTPD\"><strong>HTTPD</strong></h3>\n<p>最常见的 HTTPD 有 Linux 上常用的 Apache 和 Nginx，以及 Windows 上的 IIS。</p>\n<p>它会监听得到的请求，然后开启一个子进程去处理这个请求。</p>\n<h3 id=\"处理请求\"><strong>处理请求</strong></h3>\n<p>接受 TCP 报文后，会对连接进行处理，对 HTTP 协议进行解析（请求方法、域名、路径等），并且进行一些验证：</p>\n<ul>\n<li>验证是否配置虚拟主机</li>\n<li>验证虚拟主机是否接受此方法</li>\n<li>验证该用户可以使用该方法（根据 IP 地址、身份信息等）</li>\n</ul>\n<h3 id=\"重定向\"><strong>重定向</strong></h3>\n<p>假如服务器配置了 HTTP 重定向，就会返回一个 <code>301</code>永久重定向响应，浏览器就会根据响应，重新发送 HTTP 请求（重新执行上面的过程）。</p>\n<blockquote>\n<p>关于更多：<a href=\"https://www.cnblogs.com/workest/p/3891321.html\">详见这篇文章 (opens new window)</a></p>\n</blockquote>\n<h3 id=\"URL-重写\"><strong>URL 重写</strong></h3>\n<p>然后会查看 URL 重写规则，如果请求的文件是真实存在的，比如图片、html、css、js 文件等，则会直接把这个文件返回。</p>\n<p>否则服务器会按照规则把请求重写到 一个 REST 风格的 URL 上。</p>\n<p>然后根据动态语言的脚本，来决定调用什么类型的动态文件解释器来处理这个请求。</p>\n<p>以 PHP 语言的 MVC 框架举例，它首先会初始化一些环境的参数，根据 URL 由上到下地去匹配路由，然后让路由所定义的方法去处理请求。</p>\n<h2 id=\"五、浏览器接受响应\">五、浏览器接受响应</h2>\n<p>浏览器接收到来自服务器的响应资源后，会对资源进行分析。</p>\n<p>首先查看 Response header，根据不同状态码做不同的事（比如上面提到的重定向）。</p>\n<p>如果响应资源进行了压缩（比如 gzip），还需要进行解压。</p>\n<p>然后，对响应资源做缓存。</p>\n<p>接下来，根据响应资源里的 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types\">MIME (opens new window)</a> 类型去解析响应内容（比如 HTML、Image 各有不同的解析方式）。</p>\n<h2 id=\"六、渲染页面\">六、渲染页面</h2>\n<p><strong>浏览器内核</strong></p>\n<p><img src=\"https://cimg1.17lai.fun/data/2021/09/1320210913094432.png\" alt=\"\"></p>\n<p>不同的浏览器内核，渲染过程也不完全相同，但大致流程都差不多。</p>\n<p><strong>基本流程</strong></p>\n<p><img src=\"https://cimg1.17lai.fun/data/2021/09/1320210913094347.png\" alt=\"\"></p>\n<h3 id=\"1-HTML-解析\"><strong>1. HTML 解析</strong></h3>\n<p>首先要知道浏览器解析是从上往下一行一行地解析的。</p>\n<p>解析的过程可以分为四个步骤：</p>\n<h4 id=\"1-解码（encoding）\"><strong>1. 解码（encoding）</strong></h4>\n<p>传输回来的其实都是一些二进制字节数据，浏览器需要根据文件指定编码（例如 UTF-8）转换成字符串，也就是 HTML 代码。</p>\n<h4 id=\"2-预解析（pre-parsing）\"><strong>2. 预解析（pre-parsing）</strong></h4>\n<p>预解析做的事情是提前加载资源，减少处理时间，它会识别一些会请求资源的属性，比如<code>img</code>标签的<code>src</code>属性，并将这个请求加到请求队列中。</p>\n<h4 id=\"3-符号化（Tokenization）\"><strong>3. 符号化（Tokenization）</strong></h4>\n<p>符号化是词法分析的过程，将输入解析成符号，HTML 符号包括，开始标签、结束标签、属性名和属性值。</p>\n<p>它通过一个状态机去识别符号的状态，比如遇到<code>&lt;</code>，<code>&gt;</code>状态都会产生变化。</p>\n<h4 id=\"4-构建树（tree-construction）\"><strong>4. 构建树（tree construction）</strong></h4>\n<blockquote>\n<p>注意：符号化和构建树是并行操作的，也就是说只要解析到一个开始标签，就会创建一个 DOM 节点。</p>\n</blockquote>\n<p>在上一步符号化中，解析器获得这些标记，然后以合适的方法创建<code>DOM</code>对象并把这些符号插入到<code>DOM</code>对象中。</p>\n<p><img src=\"https://cimg1.17lai.fun/data/2021/09/1320210913094354.png\" alt=\"\"></p>\n<h4 id=\"浏览器容错进制\"><strong>浏览器容错进制</strong></h4>\n<p>你从来没有在浏览器看过类似\"语法无效\"的错误，这是因为浏览器去纠正错误的语法，然后继续工作。</p>\n<h4 id=\"事件\"><strong>事件</strong></h4>\n<p>当整个解析的过程完成以后，浏览器会通过<code>DOMContentLoaded</code>事件来通知<code>DOM</code>解析完成。</p>\n<h3 id=\"2-CSS-解析\">2. CSS 解析</h3>\n<p>一旦浏览器下载了 CSS，CSS 解析器就会处理它遇到的任何 CSS，根据<a href=\"https://drafts.csswg.org/css-syntax-3/\">语法规范 (opens new window)</a>解析出所有的 CSS 并进行标记化，然后我们得到一个规则表。</p>\n<h4 id=\"CSS-匹配规则\"><strong>CSS 匹配规则</strong></h4>\n<p>在匹配一个节点对应的 CSS 规则时，是按照从右到左的顺序的，例如：<code>div p { font-size :14px }</code>会先寻找所有的<code>p</code>标签然后判断它的父元素是否为<code>div</code>。</p>\n<p>所以我们写 CSS 时，尽量用 id 和 class，千万不要过度层叠。</p>\n<h3 id=\"3-渲染树\">3. 渲染树</h3>\n<p>其实这就是一个 DOM 树和 CSS 规则树合并的过程。</p>\n<blockquote>\n<p>注意：渲染树会忽略那些不需要渲染的节点，比如设置了<code>display:none</code>的节点。</p>\n</blockquote>\n<h4 id=\"计算\"><strong>计算</strong></h4>\n<p>通过计算让任何尺寸值都减少到三个可能之一：<code>auto</code>、百分比、px，比如把<code>rem</code>转化为<code>px</code>。</p>\n<h4 id=\"级联\"><strong>级联</strong></h4>\n<p>浏览器需要一种方法来确定哪些样式才真正需要应用到对应元素，所以它使用一个叫做<code>specificity</code>的公式，这个公式会通过：</p>\n<ol>\n<li>标签名、class、id</li>\n<li>是否内联样式</li>\n<li><code>!important</code></li>\n</ol>\n<p>然后得出一个权重值，取最高的那个。</p>\n<h4 id=\"渲染阻塞\"><strong>渲染阻塞</strong></h4>\n<p>当遇到一个<code>script</code>标签时，DOM 构建会被暂停，直至脚本完成执行，然后继续构建 DOM 树。</p>\n<p>但如果 JS 依赖 CSS 样式，而它还没有被下载和构建时，浏览器就会延迟脚本执行，直至 CSS Rules 被构建。</p>\n<p>所有我们知道：</p>\n<ul>\n<li>CSS 会阻塞 JS 执行</li>\n<li>JS 会阻塞后面的 DOM 解析</li>\n</ul>\n<p>为了避免这种情况，应该以下原则：</p>\n<ul>\n<li>CSS 资源排在 JavaScript 资源前面</li>\n<li>JS 放在 HTML 最底部，也就是 <code>&lt;/body&gt;</code>前</li>\n</ul>\n<p>另外，如果要改变阻塞模式，可以使用 defer 与 async，详见：<a href=\"https://github.com/xiaoyu2er/blog/issues/8\">这篇文章 (opens new window)</a></p>\n<ol start=\"4\">\n<li>布局与绘制</li>\n</ol>\n<p>确定渲染树种所有节点的几何属性，比如：位置、大小等等，最后输入一个盒子模型，它能精准地捕获到每个元素在屏幕内的准确位置与大小。</p>\n<p>然后遍历渲染树，调用渲染器的 paint() 方法在屏幕上显示其内容。</p>\n<h3 id=\"5-合并渲染层\"><strong>5. 合并渲染层</strong></h3>\n<p>把以上绘制的所有图片合并，最终输出一张图片。</p>\n<h3 id=\"6-回流与重绘\"><strong>6. 回流与重绘</strong></h3>\n<h4 id=\"回流-reflow\"><strong>回流(reflow)</strong></h4>\n<p>当浏览器发现某个部分发现变化影响了布局时，需要倒回去重新渲染，会从<code>html</code>标签开始递归往下，重新计算位置和大小。</p>\n<p>reflow 基本是无法避免的，因为当你滑动一下鼠标、resize 窗口，页面就会产生变化。</p>\n<h4 id=\"重绘-repaint\"><strong>重绘(repaint)</strong></h4>\n<p>改变了某个元素的背景色、文字颜色等等不会影响周围元素的位置变化时，就会发生重绘。</p>\n<p>每次重绘后，浏览器还需要合并渲染层并输出到屏幕上。</p>\n<p>回流的成本要比重绘高很多，所以我们应该尽量避免产生回流。</p>\n<p>比如：</p>\n<ul>\n<li><code>display:none</code> 会触发回流，而 <code>visibility:hidden</code> 只会触发重绘。</li>\n</ul>\n<ol start=\"7\">\n<li>JavaScript 编译执行</li>\n</ol>\n<p><strong>大致流程</strong></p>\n<p><img src=\"https://cimg1.17lai.fun/data/2021/09/1320210913094359.png\" alt=\"\"></p>\n<p>可以分为三个阶段：</p>\n<h5 id=\"1-词法分析\"><strong>1. 词法分析</strong></h5>\n<p>JS 脚本加载完毕后，会首先进入语法分析阶段，它首先会分析代码块的语法是否正确，不正确则抛出“语法错误”，停止执行。</p>\n<p>几个步骤：</p>\n<ul>\n<li>分词，例如将<code>var a = 2</code>，，分成<code>var</code>、<code>a</code>、<code>=</code>、<code>2</code>这样的词法单元。</li>\n<li>解析，将词法单元转换成抽象语法树（AST）。</li>\n<li>代码生成，将抽象语法树转换成机器指令。</li>\n</ul>\n<h5 id=\"2-预编译\"><strong>2. 预编译</strong></h5>\n<p>JS 有三种运行环境：</p>\n<ul>\n<li>全局环境</li>\n<li>函数环境</li>\n<li>eval</li>\n</ul>\n<p>每进入一个不同的运行环境都会创建一个对应的执行上下文，根据不同的上下文环境，形成一个函数调用栈，栈底永远是全局执行上下文，栈顶则永远是当前执行上下文。</p>\n<p><strong>创建执行上下文</strong></p>\n<p>创建执行上下文的过程中，主要做了以下三件事：</p>\n<ul>\n<li>创建变量对象\n<ul>\n<li>参数、函数、变量</li>\n</ul>\n</li>\n<li>建立作用域链\n<ul>\n<li>确认当前执行环境是否能访问变量</li>\n</ul>\n</li>\n<li>确定 This 指向</li>\n</ul>\n<h5 id=\"3-执行\"><strong>3. 执行</strong></h5>\n<p><strong>JS 线程</strong></p>\n<p><img src=\"https://cimg1.17lai.fun/data/2021/09/1320210913094406.png\" alt=\"\"></p>\n<p>虽然 JS 是单线程的，但实际上参与工作的线程一共有四个：</p>\n<blockquote>\n<p>其中三个只是协助，只有 JS 引擎线程是真正执行的</p>\n</blockquote>\n<ul>\n<li>JS 引擎线程：也叫 JS 内核，负责解析执行 JS 脚本程序的主线程，例如 V8 引擎</li>\n<li>事件触发线程：属于浏览器内核线程，主要用于控制事件，例如鼠标、键盘等，当事件被触发时，就会把事件的处理函数推进事件队列，等待 JS 引擎线程执行</li>\n<li>定时器触发线程：主要控制<code>setInterval</code>和<code>setTimeout</code>，用来计时，计时完毕后，则把定时器的处理函数推进事件队列中，等待 JS 引擎线程。</li>\n<li>HTTP 异步请求线程：通过 XMLHttpRequest 连接后，通过浏览器新开的一个线程，监控 readyState 状态变更时，如果设置了该状态的回调函数，则将该状态的处理函数推进事件队列中，等待 JS 引擎线程执行。</li>\n</ul>\n<p><strong>注：浏览器对同一域名的并发连接数是有限的，通常为 6 个。</strong></p>\n<p><strong>宏任务</strong></p>\n<p>分为：</p>\n<ul>\n<li>同步任务：按照顺序执行，只有前一个任务完成后，才能执行后一个任务</li>\n<li>异步任务：不直接执行，只有满足触发条件时，相关的线程将该异步任务推进任务队列中，等待 JS 引擎主线程上的任务执行完毕时才开始执行，例如异步 Ajax、DOM 事件，setTimeout 等。</li>\n</ul>\n<p><strong>微任务</strong></p>\n<p>微任务是 ES6 和 Node 环境下的，主要 API 有：<code>Promise</code>，<code>process.nextTick</code>。</p>\n<p>微任务的执行在宏任务的同步任务之后，在异步任务之前。</p>\n<p><img src=\"https://cimg1.17lai.fun/data/2021/09/1320210913094407.png\" alt=\"\"></p>\n<p><strong>代码例子</strong></p>\n<p>以上代码输出顺序为：1,3,5,4,2</p>\n<h2 id=\"参考文档\">参考文档</h2>\n<ul>\n<li><a href=\"https://github.com/skyline75489/what-happens-when-zh_CN\">what-happens-when-zh_CN (opens new window)</a></li>\n<li><a href=\"https://alistapart.com/article/tags-to-dom/\">Tags to DOM (opens new window)</a></li>\n<li><a href=\"https://heyingye.github.io/2018/04/16/%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/\">彻底理解浏览器的缓存机制 (opens new window)</a></li>\n<li><a href=\"https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#The_rendering_engine\">浏览器的工作原理：新式网络浏览器幕后揭秘 (opens new window)</a></li>\n<li><a href=\"https://blog.fundebug.com/2019/01/03/understand-browser-rendering/\">深入浅出浏览器渲染原理 (opens new window)</a></li>\n<li><a href=\"https://heyingye.github.io/2018/03/19/js%E5%BC%95%E6%93%8E%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/#%E9%A2%84%E7%BC%96%E8%AF%91%E9%98%B6%E6%AE%B5\">js 引擎的执行过程（一） (opens new window)</a></li>\n<li>还有一些找不到了。。。。。</li>\n</ul>\n<p>From: <a href=\"https://4ark.me/post/b6c7c0a2.html\">4ark.me</a></p>\n",
            "tags": [
                "web",
                "http"
            ]
        },
        {
            "id": "https://blog.17lai.site/posts/ec2cad2/",
            "url": "https://blog.17lai.site/posts/ec2cad2/",
            "title": "ESNI和加密DNS - 保护信息隐私的最后一块拼图",
            "date_published": "2021-09-06T01:25:00.000Z",
            "content_html": "<p>随着<a href=\"https://www.ietf.org/blog/tls13/\">TLS1.3</a>的发布，让该协议成为有史以来最安全、也是最复杂的TLS协议。在该协议之中，有很多的对于以往协议安全漏洞的修复，包括废弃RSA启用新的秘钥交换机制PSK等等。而<code>Encrypted SNI</code>作为一个<code>TLS1.3</code>的扩展协议用来防止传统的HTTPS流量受到ISP或者陌生网络环境的窥探以及一些网络审查。在过去，由于<code>HTTPS</code>协议之中<code>Server Name Indication - SNI</code>的使用，我们的HTTPS流量经常被窥探我们所访问站点的域名</p>\n<h3 id=\"那么什么是SNI？⌗\">那么什么是SNI？<a href=\"#%E9%82%A3%E4%B9%88%E4%BB%80%E4%B9%88%E6%98%AFsni\">⌗</a></h3>\n<blockquote>\n<p>服务器名称指示（英语：Server Name Indication，简称SNI）是一个扩展的TLS计算机联网协议，在该协议下，在握手过程开始时客户端告诉它正在连接的服务器要连接的主机名称。这允许服务器在相同的IP地址和TCP端口号上呈现多个证书，并且因此允许在相同的IP地址上提供多个安全（HTTPS）网站（或其他任何基于TLS的服务），而不需要所有这些站点使用相同的证书。它与HTTP/1.1基于名称的虚拟主机的概念相同，但是用于HTTPS。所需的主机名未加密， 因此窃听者可以查看请求的网站 为了使SNI协议起作用，绝大多数访问者必须使用实现它的Web浏览器。使用未实现SNI浏览器的用户将被提供默认证书，因此很可能会收到证书警告</p>\n</blockquote>\n<ul>\n<li>SNI协议示意图</li>\n</ul>\n<p><img src=\"https://cimg1.17lai.fun/data/2021/08/2820210828144946.webp\" alt=\"\"></p>\n<ul>\n<li>TLS1.3完整握手流程</li>\n</ul>\n<p><img src=\"https://cimg1.17lai.fun/data/2021/08/2820210828144904.webp\" alt=\"\"></p>\n<h3 id=\"为了弥补缺陷因应运而生的ESNI⌗\">为了弥补缺陷因应运而生的ESNI<a href=\"#%E4%B8%BA%E4%BA%86%E5%BC%A5%E8%A1%A5%E7%BC%BA%E9%99%B7%E5%9B%A0%E5%BA%94%E8%BF%90%E8%80%8C%E7%94%9F%E7%9A%84esni\">⌗</a></h3>\n<p>在上述过程之中，存在的问题就是，在ClientHello环节中，TLS会在这个位置以<strong>明文</strong>的形式讲要请求的Host写在数据包之中，如果在网络路由中有任何的监听节点，那么用户所访问网站的域名将暴露无遗，这将是巨大的用户隐私泄露: <img src=\"https://cimg1.17lai.fun/data/2021/08/2820210828144907.webp\" alt=\"\"></p>\n<p>所以在最新的关于<a href=\"https://tools.ietf.org/html/draft-rescorla-tls-esni-00\">ESNI的草案</a>中，<code>IETF</code>重新设计了一种加密的Client Hello机制，从而修复了这个问题: <img src=\"https://cimg1.17lai.fun/data/2021/08/2820210828144915.webp\" alt=\"\"></p>\n<p><strong>不过这里问题又来了，之前服务器和客户端并没有事先交换任何数据啊，这个加密的凭证从何而来啊？？？</strong></p>\n<h3 id=\"依靠安全DNS的ESNI⌗\">依靠安全DNS的ESNI<a href=\"#%E4%BE%9D%E9%9D%A0%E5%AE%89%E5%85%A8dns%E7%9A%84esni\">⌗</a></h3>\n<p>上一个问题没有难倒工程师们，他们设计了这样一个办法。首先让网站提供者在DNS提供商上公布一个记录，这个记录包含着一个<code>公钥</code>，这个公钥由网站提供者生成，其<code>私钥</code>存储在Web服务器等待着被Web程序读取。如此，当用户想通过TLS1.3协议访问这个域名的时候，首先读取这个公开的公钥，在用公钥加密其想访问的<code>域名Host</code>，装在<code>Client Hello</code>里面发送给目标服务器，目标服务器再用自己的私钥解密，从而和用户建立HTTPS链接，这样就不会暴露Host信息 这时候有人会想，如果有人某Wall想给你的DNS偷天换日，那会不会很不安全啊,请继续向下看</p>\n<p>在<code>ESNI</code>的实现草案之中，里面要求<code>安全加密的DNS</code><strong>是推荐的</strong>。大家都知道我们的DNS查询一般是<code>TCP</code>报文或者是<code>UDP</code>报文，本身它是不加密的，所以如果有人想在篡改你的DNS是相对简单的，大家可能都知道我们伟大的妨炎蔷会使用DNS污染的方式干扰一些网站的正常访问。正式由于DNS的非加密性，DNS也成为了审查信息的利器。此时加密的DNS势在必行</p>\n<h3 id=\"DNS-over-TLS-DoT-and-DNS-over-HTTPS-DoH-⌗\">DNS over TLS (DoT) and DNS over HTTPS (DoH)<a href=\"#dns-over-tls-dot-and-dns-over-https-doh\">⌗</a></h3>\n<p>于是出现了这两种新型的DNS查询方式</p>\n<ul>\n<li>DNS over HTTPS (DoH)</li>\n</ul>\n<blockquote>\n<p>DNS Over HTTPS (DOH) 是一个进行安全化的域名解析的方案，当前尚处于实验性阶段。其意义在于以加密的HTTPS协议进行DNS解析请求，避免原始DNS协议中用户的DNS解析请求被窃听或者修改的问题（例如中间人攻击）来达到保护用户隐私的目的。 Google及Mozilla基金会正在测试这一协议，作为其提高网络安全性的努力的一部分。 当前，该方案由IETF支持，其规范文档以 RFC 8484 的名义发布。2018年9月5日发布的Firefox 62正式版加入了这项功能，但需要用户手动开启 DNS Over HTTPS利用HTTP协议的GET命令发出经由JSON等编码的DNS解析请求。较于传统的DNS协议，此处的HTTP协议通信处于具有加密作用的SSL/TLS协议（两者统称作HTTPS）的保护之下。但是，由于其基于HTTPS，而HTTPS本身需要经由多次数据来回传递才能完成协议初始化，其域名解析耗时较原DNS协议会显著增加。 传统的DNS协议形成于互联网早期，直接基于UDP或TCP协议，且彼时未虑及现代安全性的需要，未利用密码学等手段进行加密或验证。因而，其无法抵御现代互联网常见的DNS投毒污染等攻击手段或监听。虽然后来的DNSSEC方案通过电子签名进行验证，强化了DNS的安全性，并能够抵御DNS投毒污染等篡改通信的手段，但其对于中间网络设备进行的监听仍然没有抵御能力（随后，监听者可以通过获取的通信数据知晓用户访问了哪一域名，而域名往往与具体的网站相关系）。此外，DNSSEC的起效要求现有的大量DNS解析服务的提供商（常为互联网服务提供商或第三方大型互联网机构）对已有的DNS服务器进行大范围修改等问题，其推进进程并不理想。而对于DNS Over HTTPS，在正确部署服务端并妥善配置客户端的前提下，互联网服务提供商或其它中间网络设备无法解密（亦即无法获知请求的实际内容）或者篡改已经加密的HTTPS通信，故其能够有效保护互联网用户的安全及隐私；另一方面，其基于已经成熟并已广泛部署的HTTPS协议，客户端进行利用较为方便。</p>\n</blockquote>\n<ul>\n<li>DNS over TLS (DoT)</li>\n</ul>\n<blockquote>\n<p>DNS over TLS (DoT) 是通过传输层安全协议（TLS）来加密并打包域名系统（DNS）的安全协议。此协议旨在防止中间人攻击与控制DNS数据以保护用户隐私。 RFC 7858及RFC 8310定义了DNS over TLS。 截至2018年，Cloudflare、Quad9与CleanBrowsing均向大众提供支持DNS over TLS的公共DNS解析服务。2018年4月，Google宣布Android P将包含对DNS over TLS的支持。PowerDNS的DNSDist也宣布在其最新的1.3.0版本中添加了对DNS over TLS的支持。BIND用户也可以通过stunnel代理提供DNS over TLS服务。</p>\n</blockquote>\n<h3 id=\"手动配置⌗\">手动配置<a href=\"#%E6%89%8B%E5%8A%A8%E9%85%8D%E7%BD%AE\">⌗</a></h3>\n<p>Firefox所在的Mozilla宣布从<code>Firefox 62</code>版本之后开始支持<code>ESNI</code>，默认没有开启，需要用户手动配置打开，那么我们现在试验一下 这里Firefox的解决方案是使用<code>DNS over HTTPS (DoH)</code>和<code>ESNI</code></p>\n<ol>\n<li>\n<p>安装<code>Firefox Nightly</code>版本，这个版本是预发布版本，使得开发这和即可门可以提前尝鲜到新功能。<a href=\"https://www.mozilla.org/zh-CN/firefox/nightly/all/\">下载地址</a></p>\n</li>\n<li>\n<p>在浏览器地址栏输入<code>about:config</code>并回车，打开配置页面，在搜索位置搜索<code>network.trr.mode</code>，这个是打开浏览器对于<code>DoH</code>的支持，将此项的数值修改为3（<code>0</code>对应的是不开启此功能；<code>1</code>对应的是交由浏览器选择<code>DoH</code>与传统方式那种更快；<code>2</code>代表优先使用加密DNS查询，如果失败则回落到普通DNS查询；<code>3</code>代表只使用加密DNS查询；<code>5</code>代表明确的关闭此功能）</p>\n</li>\n<li>\n<p>继续搜索<code>network.trr.uri</code>，将此项的值修改为<code>https://mozilla.cloudflare-dns.com/dns-query</code>，这个是默认的<code>DoH</code>查询地址，当然我们也可以使用诸如<code>https://1.1.1.1/dns-query</code>、<code>https://dns.google.com/experimental</code>这样的地址，我们可以事先<code>ping</code>检测一下对比哪个延迟更低来使用</p>\n</li>\n<li>\n<p>（可选）搜索<code>network.trr.bootstrapAddress</code>，讲此值修改位第三步的DNS域名的<code>IP</code>。此举是为了避免使用操作系统DNS查询域名受到劫持，一般来说这些DNS的<code>IP</code>是不会变的</p>\n</li>\n</ol>\n<p><img src=\"https://cimg1.17lai.fun/data/2021/08/2820210828145006.webp\" alt=\"\"></p>\n<ol start=\"5\">\n<li>\n<p>将<code>network.security.esni.enabled</code>设置为<code>true</code>,此举为了打开浏览器对于ESNI的支持（感谢<a href=\"https://github.com/chenIshi\">chenlshi</a>同学的提醒，在原版的文章中我不小心遗漏了这个关键的步骤）</p>\n</li>\n<li>\n<p>完成配置后重启浏览器，再打开<a href=\"https://encryptedsni.com/\">在线验证页面验证</a>来查询你的浏览器是否完全支持<code>ESNI</code>功能，如果出现如图说明配置成功了</p>\n</li>\n</ol>\n<p><img src=\"https://cimg1.17lai.fun/data/2021/08/2820210828144924.webp\" alt=\"\"></p>\n<h3 id=\"验证⌗\">验证<a href=\"#%E9%AA%8C%E8%AF%81\">⌗</a></h3>\n<p>为了验证是否真的加密了<code>Client Hello</code>，我们使用<code>Wireshark</code>进行网络抓包 由于这个特性仍在试验阶段，并没有太多站点支持这个特性，<a href=\"https://cloudflare.com/\">CloudFlare</a>是第一个全站支持<code>ESNI</code>的网站，这里我们使用<a href=\"https://blog.cloudflare.com/\">blog.cloudflare.com</a>来做测试：</p>\n<ol>\n<li>首先打开<code>Wireshark</code>的抓包功能，然后开启<code>Chrome</code>浏览器打开上述网址，页面加载完后停止抓包，在得到的结果中查询协议为<code>TLS1.3</code>和报文为<code>Client Hello</code>的报文，通过观察发现域名的Host果然被以明文形式写在数据包中（参见<code>Server_Name</code>字段）：</li>\n</ol>\n<p><img src=\"https://cimg1.17lai.fun/data/2021/08/2820210828144932.webp\" alt=\"\"></p>\n<ol start=\"2\">\n<li>然后打开<code>Firefox Nightly</code>浏览器重复上述操作，这次发现在整个数据包中根本找不到<code>Server_Name</code>字段，说明<code>Host</code>已经被加密：</li>\n</ol>\n<p><img src=\"https://cimg1.17lai.fun/data/2021/08/2820210828144933.webp\" alt=\"\"></p>\n<p>目前来说，我查阅了相关的关键词，仍然没有任何一篇教程有介绍如何在自己的服务器上支持<code>ESNI</code>，同时我也看到在<code>Nginx</code>的论坛里面有人呼吁尽快支持<code>ESNI</code>，所以我推测这个功能仍然在试验期，还没有被这两个Web软件所支持，起劲为止我也没有查阅到任何的Web软件预计支持此项功能。这项扩展已经进入<code>IETF</code>的草案阶段，可以预见到，在不就的将来，这项技术可以普及开来，为我们的网络隐私保驾护航 目前来说，有了<code>HTTPS</code>+<code>TLS1.3</code>+<code>ESNI</code>+<code>DoH/DoT</code>的加持，我们的网络隐私的到了极大的保障，最后还有一个问题是访问服务器<code>IP</code>的泄露仍然无法被避免，迫于<code>IP协议</code>设计的机制，他目前还不能被解决。不过我相信，随着网技术不断的趋于保护个人隐私和更快速的发展方向，这个问题可以最终被解决</p>\n<p>From: <a href=\"https://blog.hackerchai.com/post/encrypted-sni-anti-censorship/\">hackerchai</a></p>\n",
            "tags": [
                "ssl",
                "tls",
                "隐私",
                "安全"
            ]
        },
        {
            "id": "https://blog.17lai.site/posts/1991789c/",
            "url": "https://blog.17lai.site/posts/1991789c/",
            "title": "Github Pages + jekyll 全面介绍极简搭建个人网站和博客",
            "date_published": "2021-03-03T08:25:00.000Z",
            "content_html": "<p>利用github pages搭建个人博客。本文指导建立github工程，并配置github pages搭建博客的全过程。</p>\n<p>注意：图床使用github，图片显示问题自己解决</p>\n<h2 id=\"第一步，建立Github仓库\">第一步，建立Github仓库</h2>\n<p>首先到这里Github，创建一个仓库。</p>\n<p><img src=\"https://cimg1.17lai.fun/data/2021/03/05/20210305002728.png\" alt=\"\"></p>\n<p>仓库名称有固定的格式： <a href=\"http://username.github.io\">username.github.io</a>，其中username必须是Github账户的用户名（我的是scottcgi），github.io是固定的，这个地址将会成为个人站点的网站地址。另外，我们可以勾选Initialize this repository with a README，让仓库自动创建一个README.md文件，我们用它来做站点的首页（当然也可以不创建，后面自行创建，或是建立index.html也行）。</p>\n<p>注意： username如果不是Github账户名，这个仓库就会成为username.github.io的子站点，比如访问地址会是：<a href=\"http://username.github.io/aaa.github.io%E3%80%82%E5%8F%AF%E8%A7%81%EF%BC%8Cusername.github.io%E6%98%AFgithub%E9%BB%98%E8%AE%A4%E5%88%86%E9%85%8D%E7%BB%99%E4%BD%A0%E7%9A%84%E5%9F%9F%E5%90%8D%EF%BC%8C%E5%90%8C%E5%90%8D%E4%BB%93%E5%BA%93%E5%8D%B3%E4%BB%A3%E8%A1%A8%E7%9D%80%E9%BB%98%E8%AE%A4%E7%BD%91%E7%AB%99%E5%86%85%E5%AE%B9%E3%80%82%E8%80%8Cusername.github.io/%E4%BB%93%E5%BA%93%E5%90%8D%E7%A7%B0%EF%BC%8C%E6%98%AF%E7%94%A8%E6%9D%A5%E8%AE%BF%E9%97%AE%E4%BD%A0%E7%9A%84%E5%85%B6%E5%AE%83%E4%BB%93%E5%BA%93%E7%9A%84%E5%9C%B0%E5%9D%80%E3%80%82\">username.github.io/aaa.github.io。可见，username.github.io是github默认分配给你的域名，同名仓库即代表着默认网站内容。而username.github.io/仓库名称，是用来访问你的其它仓库的地址。</a></p>\n<h2 id=\"第二步，设置仓库开启Github-Pages\">第二步，设置仓库开启Github Pages</h2>\n<p>进入仓库设置界面，如图。</p>\n<p><img src=\"https://cimg1.17lai.fun/data/2021/03/05/20210305002731.png\" alt=\"\"></p>\n<p>这里能够重新修改仓库的名称，比如这个仓库内容是fork别人的，就可以在这里修改成自己的username.github.io名称。</p>\n<p><img src=\"https://cimg1.17lai.fun/data/2021/03/05/20210305002731.png\" alt=\"\"></p>\n<p>在Setting页面下有Github Pages的设置选项。绿色表示部署成功，每次修改仓库内容，都会出发Github jekyll重新编译部署，需要1-2分钟的时间，更新才能体现。如果有编译错误，包括js，css，html，markdown语法问题，都会显示红色以及错误页面和行号，同时会发邮件通知。其中，Source有以下几个选项：</p>\n<p>gh-pages branch 是项目新建一个分支命名为这个，使用这个分支来做站点内容。<br>\nmaster branch 是使用主分支也是默认的，来作为站点内容。<br>\nmaster branch/docs folder 是使用主分支的docs文件夹来作为站点内容。<br>\nNone 就是禁用Github Pages。<br>\n如果是username.github.io只能使用主分支，其它仓库项目可以选择其它两个。接下来Choose a theme是Github提供的内置的网站主题，选择即可应用无需其它设置。Custom domain是自定义域名，本文暂不讨论。</p>\n<h2 id=\"第三步，使用Github内置主题\">第三步，使用Github内置主题</h2>\n<p>选择好主题，过一会刷新网站地址就已经能看到效果了，而在Code页面仅有两个文件。</p>\n<p><img src=\"https://cimg1.17lai.fun/data/2021/03/05/20210305002737.png\" alt=\"\"></p>\n<p>编辑README.md文件的内容，就会默认显示在网站首页，<code>_config.yml</code> 是jekyll的全局配置文件，现在里面只有一句话，<code>theme: jekyll-theme-modernist</code>。我们可以手动修改这个theme主题配置，网站就会应用不同的主题。</p>\n<p>Github内置支持的几个主题，官方的仓库在这里：<a href=\"https://pages.github.com/themes%EF%BC%8C%E6%AF%8F%E4%B8%AAREADME.md%E9%87%8C%E9%83%BD%E6%9C%89%E4%BB%8B%E7%BB%8D%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%E3%80%82\">https://pages.github.com/themes，每个README.md里都有介绍如何设置。</a></p>\n<p>那么我们现在就有两种方法来使用这些主题：</p>\n<p>第一种，就是直接fork一个主题仓库，然后修改仓库名称为我们自己的，然后修改我们需要的部分。</p>\n<p><img src=\"https://cimg1.17lai.fun/data/2021/03/05/20210305002743.png\" alt=\"\"></p>\n<p>第二种，只是简单的Choose (Change) theme（或在<code>_config.yml</code>设置theme），然后我们对照着官方仓库的主题目录，需要改什么文件就按照同样的路径拷贝单独一个文件到自己的仓库来修改（保持路径一致），这样就可以保持自己仓库的简洁。（如果使用了github内置的主题，github就会把你仓库的内容和内置主题内容合并到一起编译成静态网页。）</p>\n<p>另外，更多主题可以参看这两个地址（不要挑花眼了）： jekyll themes 和 jekyll wiki site。</p>\n<h2 id=\"第四步，jekyll的目录结构\">第四步，jekyll的目录结构</h2>\n<p>我们只需要关注几个核心的目录结构如下（可以自己创建）：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-none\"><code class=\"language-none\">- _layouts （存放页面模板，md或html文件的内容会填充模板）\n- _sass（存放样式表）\n- _includes （可以复用在其它页面被include的html页面）\n- _posts（博客文章页面）\n- assets（原生的资源文件）\n  - js\n  - css\n  - image\n- _config.yml （全局配置文件）\n- index.html, index.md, README.md （首页index.html优先级最高，如果没有index，默认启用README.md文件）\n- 自定义文件和目录\n  更多更详细的目录结构参看jekyll官网：https://jekyllrb.com/docs/structure</code></pre></div></figure>\n<h2 id=\"第五步，jekyll的模板编程语言Liquid的使用\">第五步，jekyll的模板编程语言Liquid的使用</h2>\n<ul>\n<li>\n<p>变量  被嵌入在页面中，会在静态页面生成的时候被替换成具体的数值。常用的全局变量对象有：site 和 page。这两个对象有很多默认自带的属性，比如：，。更多的默认值参看：<a href=\"https://jekyllrb.com/docs/variables%E3%80%82\">https://jekyllrb.com/docs/variables。</a></p>\n</li>\n<li>\n<p>site对象对应的就是网站范围，自定义变量放在_config.yml中，比如title:标题使用访问。</p>\n</li>\n<li>\n<p>page对象对应的是单个页面，自定义变量放在每个页面的最开头，比如：</p>\n</li>\n</ul>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-none\"><code class=\"language-none\">myNum:100\n \nmyStr:我是字符串</code></pre></div></figure>\n<p>使用 和  访问。<br>\n条件判断语句，更多详见：<a href=\"https://shopify.github.io/liquid/tags/control-flow\">https://shopify.github.io/liquid/tags/control-flow</a></p>\n<p><img src=\"https://cimg1.17lai.fun/data/2021/07/0920210709184021.png\" alt=\"\"></p>\n<p>循环迭代，更多详见：<a href=\"https://shopify.github.io/liquid/tags/iteration\">https://shopify.github.io/liquid/tags/iteration</a></p>\n<p><img src=\"https://cimg1.17lai.fun/data/2021/07/0920210709184048.png\" alt=\"\"></p>\n<p>默认函数，可以对变量进行一些处理，比如大小写转化、数学运算、格式化、排序等等，在Liquid中叫做Filters。比如<code>{{ \"Hello World!\" | downcase }}</code>转换字符串为小写。更多内置函数详见：<a href=\"https://jekyllrb.com/docs/liquid/filters\">https://jekyllrb.com/docs/liquid/filters</a></p>\n<h2 id=\"第六步，使用-config-yml文件设置jekyll\">第六步，使用_config.yml文件设置jekyll</h2>\n<p>如果不是fork别人的仓库，就需要自己创建一个这个文件。然后，我们就可以配置一些默认的属性来控制jekyll的编译过程。更多详细的内置属性详见：<a href=\"https://jekyllrb.com/docs/configuration/default\">https://jekyllrb.com/docs/configuration/default</a></p>\n<p>同时我们可以自定变量，会自动绑定到site对象上，比如我们可以把导航配置到_config.yml中：</p>\n<p><img src=\"https://cimg1.17lai.fun/data/2021/07/0920210709184117.png\" alt=\"\"></p>\n<p><img src=\"https://cimg1.17lai.fun/data/2021/07/0920210709183323.png\" alt=\"\"></p>\n<p>当然，我们也可以把一些数据单独放入一个yml文件，然后放在固定的数据文件夹_data下，比如<code>_data/navigation.yml</code>，这样访问这个文件的数据对象就是site.data.navigation。</p>\n<h2 id=\"第七步，-layouts模板配置\">第七步，_layouts模板配置</h2>\n<p>_layouts文件夹存放的是页面模板，默认需要一个default.html，什么意思？就是说，layout提供一个页面的布局框架，这是固定的模式，包括样式、结构、布局、脚本控制等等。然后，我们在用其它md或html文件去动态填充这个框架，这样就形成了一个完整的页面。比如我的default.html页面如下：</p>\n<p><img src=\"https://cimg1.17lai.fun/data/2021/07/0920210709183622.png\" alt=\"\"></p>\n<p><img src=\"https://cimg1.17lai.fun/data/2021/07/0920210709183638.png\" alt=\"\"></p>\n<ul>\n<li><code>{% seo %}</code> 是jekyll的一个插件提供的seo优化，详情在这里：<a href=\"https://github.com/jekyll/jekyll-seo-tag\">https://github.com/jekyll/jekyll-seo-tag</a></li>\n<li>核心在于 content 这个变量是内置的，会用我们的md或html页面填充这部分内容。</li>\n<li>其它的，我们看到会大量使用变量和流程控制代码，来填充模板的方方面面。</li>\n<li>于是，填充模板的内容，一方面是来自读取配置文件的变量，一方面是来自_includes的页面，还有就是来自 content 对应的页面。<br>\n当然，我们也可以不使用 content 来填充模板，而是使用_includes的页面来代替content  ，但这样不够灵活，因为使用content ，我们可以在每个页面单独设置对应的layout模板。</li>\n</ul>\n<h2 id=\"第八步，md和html页面编写\">第八步，md和html页面编写</h2>\n<p>站点内容页面，可以使用markdown或html来编写，但markdown编写的md文件，在浏览器地址访问的时候依然使用html文件后缀。推荐使用markdown来书写内容，语法参见：Github md 示例 和 Github md 教程。比如下面这个About.md页面：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-markdown\" data-language=\"markdown\"><code class=\"language-markdown\">---\nlayout: default\ntitle: About\n---\n# About page\n \nThis page tells you a little bit about me.\n </code></pre></div></figure>\n<p>layout: default 就是告诉jekyll这个页面使用哪个模板，即这个页面会放入哪个模板的content。当然，我们可以在_layouts文件夹下提供多个不同的模板，然后根据需要不同的页面使用不同的layout。</p>\n<p>页面可以放在任意位置和目录，访问的时候从站点域名开始，带上目录名称，再次注意需要使用html结尾。如果想要自定义浏览器的访问路径，可以参看详细设置：permalinks。</p>\n<p>md和html页面的区别：</p>\n<p>md有自己的语法，可以使用少量的html标签，最终会编译成html，侧重于内容编写。<br>\nhtml可以随意使用html标签，可以使用liquid模板语言，侧重于页面模板和功能控制。<br>\n至此，我们就可以在github上，新建md文件然后编辑提交，等待几分钟编译生成之后，就可以在浏览器里看到页面内容了。</p>\n<h2 id=\"第九步，博客文章编写和管理\">第九步，博客文章编写和管理</h2>\n<p>我们自然可以新建目录，提交文章，然后添加一个文章列表页面。但我们也可以把这些交给jekyll的内置机制来完成，因为它提供了一些方便的内置文章管理功能。</p>\n<ul>\n<li>_posts文件夹是内置的放置文章的目录，我们可以将固定格式year-moth-day-name.md名称的md文件放到这里。比如新建一篇md的博客文章放到_posts目录下：</li>\n</ul>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-markdown\" data-language=\"markdown\"><code class=\"language-markdown\">---\nlayout: post\n---\n这是一篇博客文章。\n</code></pre></div></figure>\n<ul>\n<li>接下来我们需要添加一个post的模板页面到_layouts文件夹下面。</li>\n</ul>\n<p><img src=\"https://cimg1.17lai.fun/data/2021/07/0920210709184604.png\" alt=\"\"></p>\n<p>可见，模板页面本身也可以使用模板，这里post使用了default模板，而这里 content 就会填充_posts下面编写的页面（如果页面使用了layout: post模板）。</p>\n<p>最后，我们还需要编写一个博客文章列表的页面，用来展示所有的文章。比如在根目录新建blog.html页面：</p>\n<p><img src=\"https://cimg1.17lai.fun/data/2021/07/0920210709183357.png\" alt=\"\"></p>\n<ul>\n<li>site.posts jekyll会自动生成_posts目录的对象。</li>\n<li>_post.url jekyll会自动会设置在_posts目录下的页面url。</li>\n<li>post.title 默认是md文件名称，但也可以在文章页面自定义title: 我的文章自定义名称。</li>\n<li>post.excerpt 默认是文章第一段的摘要文字。</li>\n</ul>\n<h2 id=\"第十步，Github-Pages的限制\">第十步，Github Pages的限制</h2>\n<ul>\n<li>Github Pages 并不是无限存储和无限流量的静态站点服务，一些限制如下：</li>\n<li>内容存储不能超过1GB。</li>\n<li>每个月100GB流量带宽。</li>\n<li>每小时编译构建次数不超过10次。（在线修改重新编译并未发现这个限制）</li>\n<li>更多参看官方说明：usage-limits。</li>\n</ul>\n<h2 id=\"总结\">总结</h2>\n<p>在实际的使用过程中，我发现完全可以在Github网站上，编写md和html页面，修改js和css文件，来完成站点的设置和搭建。只不过每次修改都要触发Github jekyll的编译行为，有点慢（不知道是不是增量编译），没有在本地修改调试的速度快。</p>\n<p>更多jekyll详细的设置和功能，参看官方网站的文档：<a href=\"https://jekyllrb.com/docs%E3%80%82\">https://jekyllrb.com/docs。</a></p>\n<p>原文链接：<a href=\"https://blog.csdn.net/tom_221x/article/details/84630283\">https://blog.csdn.net/tom_221x/article/details/84630283</a></p>\n",
            "tags": [
                "github",
                "jekyll",
                "blog"
            ]
        }
    ]
}