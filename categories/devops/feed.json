{
    "version": "https://jsonfeed.org/version/1",
    "title": "夜法之书 • All posts by \"devops\" category",
    "description": "~软件驱动世界~个人独立技术博客，关于Linux,开源，Nas，Docker，嵌入式，理财，健身等主题！",
    "home_page_url": "https://blog.17lai.site",
    "items": [
        {
            "id": "https://blog.17lai.site/posts/bd70a73c/",
            "url": "https://blog.17lai.site/posts/bd70a73c/",
            "title": "开源观察之到底是谁在主导开源软件生态的发展？",
            "date_published": "2023-03-24T13:21:22.000Z",
            "content_html": "<h2 id=\"前言\">前言</h2>\n<blockquote>\n<p>很多人对于开源生态误解很深，这里对开源软件生态的一些介绍和解释，使用ChatGPT辅助编写了一篇对于外行的介绍，使其可以快速了解开源生态</p>\n</blockquote>\n<span id=\"more\"></span>\n<p><img src=\"https://cimg1.17lai.site/data/2023/03/24/20230324213857.webp\" alt=\"Open Source\"></p>\n<h2 id=\"对话开源\">对话开源</h2>\n<blockquote>\n<p>使用了很多很久的开源软件，也参与了一些开源软件的发展，现在软件的选择首选的就是开源软件，对于开源软件生态算是有一个初步的了解和映像。很多外行对于开源有一些错误的认知，很早就有写一篇关于开源生态的文章了，最近使用ChatGPT辅助，很快就完成了一篇文章。</p>\n<p>在思考是否把对话过程整理成文之后，最终决定还是保留交流对话的过程！</p>\n<p>ChatGPT很强大，但你也得具备很多专业知识才能用好它</p>\n</blockquote>\n<div class=\"chat-container\">\n        <div class=\"chat-message assistant\">\n          <img no-lazy=\"\" class=\"avatar\" src=\"/medias_webp/avatar/1.jpg\" alt=\"Assistant\">\n          <div class=\"chat-content\"></div>\n        </div>\n      \n        <div class=\"chat-message user\">\n          <img no-lazy=\"\" class=\"avatar\" src=\"/medias_webp/avatar/2.jpg\" alt=\"User\">\n          <div class=\"chat-content\"><p>开源软件是什么</p>\n</div>\n        </div>\n      \n        <div class=\"chat-message assistant\">\n          <img no-lazy=\"\" class=\"avatar\" src=\"/medias_webp/avatar/1.jpg\" alt=\"Assistant\">\n          <div class=\"chat-content\"><p>开源软件指的是源代码可以被公开查看、使用、修改和分发的软件。与之相对的是闭源软件，它的源代码是私有的，不公开供大众使用和修改。</p>\n<p>开源软件的特点是：</p>\n<ol>\n<li>\n<p>可以被公开查看和修改：任何人都可以查看开源软件的源代码，并且可以根据自己的需要进行修改和定制。</p>\n</li>\n<li>\n<p>可以被免费使用：大部分开源软件都是免费提供给用户使用的，用户不需要支付版权费用。</p>\n</li>\n<li>\n<p>具有较高的安全性：由于源代码公开，开源软件的漏洞和安全问题可以被更多人发现和修复，从而提高了软件的安全性。</p>\n</li>\n<li>\n<p>具有良好的社区支持：开源软件通常有一个庞大的社区支持，用户可以通过社区获得帮助、交流和分享。</p>\n</li>\n<li>\n<p>可以被广泛应用和推广：由于开源软件具有免费和开放的特点，它可以被广泛应用和推广，从而提高了软件的影响力和普及率。</p>\n</li>\n</ol>\n<p>常见的开源软件有Linux操作系统、Apache Web服务器、MySQL数据库、Firefox浏览器、WordPress网站建设平台等等。开源软件已经成为现代软件开发中的重要组成部分，为用户和开发者带来了诸多的好处。</p>\n</div>\n        </div>\n      \n        <div class=\"chat-message user\">\n          <img no-lazy=\"\" class=\"avatar\" src=\"/medias_webp/avatar/2.jpg\" alt=\"User\">\n          <div class=\"chat-content\"><p>开源软件的优点是什么</p>\n</div>\n        </div>\n      \n        <div class=\"chat-message assistant\">\n          <img no-lazy=\"\" class=\"avatar\" src=\"/medias_webp/avatar/1.jpg\" alt=\"Assistant\">\n          <div class=\"chat-content\"><p>开源软件有以下优点：</p>\n<ol>\n<li>\n<p>透明性：开源软件的源代码是公开的，用户可以查看代码并了解软件的实现原理，这种透明性使得用户可以更好地理解软件的功能和运行机制。</p>\n</li>\n<li>\n<p>自由度：开源软件的用户可以自由地复制、分发、修改和使用软件，而且不需要支付任何费用。这种自由度使得用户可以根据自己的需要来定制软件，从而更好地满足自己的需求。</p>\n</li>\n<li>\n<p>安全性：由于开源软件的源代码是公开的，任何人都可以查看代码并发现其中的漏洞和安全问题，这种开放的审查机制可以使得开源软件具有更高的安全性和稳定性。</p>\n</li>\n<li>\n<p>可定制性：开源软件通常具有很好的可定制性，用户可以根据自己的需求和特定的场景对软件进行修改和定制，从而更好地满足自己的需求。</p>\n</li>\n<li>\n<p>社区支持：由于开源软件的用户和开发者通常组成一个庞大的社区，这种社区可以为用户提供技术支持、问题解答、开发经验和资源共享等支持。</p>\n</li>\n<li>\n<p>兼容性：开源软件通常具有更好的兼容性，因为开源软件通常遵循开放标准，不受私有标准的限制，可以更好地与其他软件和系统进行协作。</p>\n</li>\n</ol>\n<p>综上所述，开源软件的优点包括透明性、自由度、安全性、可定制性、社区支持和兼容性等。这些优点使得开源软件成为现代软件开发中不可或缺的一部分，为用户和开发者带来了巨大的价值和好处。</p>\n</div>\n        </div>\n      \n        <div class=\"chat-message user\">\n          <img no-lazy=\"\" class=\"avatar\" src=\"/medias_webp/avatar/2.jpg\" alt=\"User\">\n          <div class=\"chat-content\"><p>那么，开源软件有什么缺点了？</p>\n</div>\n        </div>\n      \n        <div class=\"chat-message assistant\">\n          <img no-lazy=\"\" class=\"avatar\" src=\"/medias_webp/avatar/1.jpg\" alt=\"Assistant\">\n          <div class=\"chat-content\"><p>虽然开源软件具有很多优点，但也存在一些缺点，包括以下几个方面：</p>\n<ol>\n<li>\n<p>缺乏专业支持：开源软件通常由社区维护和支持，缺乏专业支持，这可能导致用户在使用和维护软件时遇到困难。</p>\n</li>\n<li>\n<p>可能存在安全问题：虽然开源软件的源代码可以被公开审查，但这也可能导致黑客更容易找到软件中的漏洞和安全问题，因此开源软件也需要及时修复漏洞以保障安全。</p>\n</li>\n<li>\n<p>兼容性问题：虽然开源软件通常遵循开放标准，但在实际应用中，与其他软件或系统的兼容性可能存在问题，这可能会导致软件无法正常工作。</p>\n</li>\n<li>\n<p>学习成本较高：由于开源软件的源代码是公开的，用户可能需要具有一定的编程知识和技能才能进行定制和修改，因此需要付出一定的学习成本。</p>\n</li>\n<li>\n<p>可能存在版本更新不及时的问题：由于开源软件通常由社区维护，因此可能存在版本更新不及时的问题，用户需要自己去维护和更新软件，这可能会增加用户的工作量。</p>\n</li>\n</ol>\n<p>综上所述，开源软件的缺点包括缺乏专业支持、安全问题、兼容性问题、学习成本较高和版本更新不及时等。对于这些缺点，用户可以通过选择专业的开源软件提供商、参与社区维护和支持、及时更新软件版本等方式来解决。</p>\n</div>\n        </div>\n      \n        <div class=\"chat-message user\">\n          <img no-lazy=\"\" class=\"avatar\" src=\"/medias_webp/avatar/2.jpg\" alt=\"User\">\n          <div class=\"chat-content\"><p>只要投入金钱，开源软件的这些问题可以解决么</p>\n</div>\n        </div>\n      \n        <div class=\"chat-message assistant\">\n          <img no-lazy=\"\" class=\"avatar\" src=\"/medias_webp/avatar/1.jpg\" alt=\"Assistant\">\n          <div class=\"chat-content\"><p>投入金钱确实可以解决一些开源软件存在的问题，例如提供专业支持、加强软件安全等，但并不能完全解决所有问题。以下是一些例子：</p>\n<ol>\n<li>\n<p>提供专业支持：企业可以选择购买专业的开源软件支持服务，获得专业的技术支持、问题解答和定制服务，从而解决由于缺乏专业支持而导致的困难。</p>\n</li>\n<li>\n<p>加强软件安全：企业可以选择购买安全软件，对开源软件进行加固和安全管理，从而提高软件的安全性。</p>\n</li>\n<li>\n<p>定制和维护：企业可以选择雇佣开源软件开发人员，进行定制和维护，从而解决开源软件的兼容性和版本更新等问题。</p>\n</li>\n<li>\n<p>增加社区投入：企业可以向开源社区投入资金，促进社区的发展和维护，从而帮助解决一些开源软件存在的问题。</p>\n</li>\n</ol>\n<p>然而，开源软件的自由性和透明性也意味着，用户可以根据自己的需求和资源选择是否投入金钱。在一些情况下，投入金钱可能并不是必要的，用户可以通过自己的努力和学习来解决开源软件存在的问题。</p>\n</div>\n        </div>\n      \n        <div class=\"chat-message user\">\n          <img no-lazy=\"\" class=\"avatar\" src=\"/medias_webp/avatar/2.jpg\" alt=\"User\">\n          <div class=\"chat-content\"><p>redhat就是一家很成功的开源软件公司，并创造了巨大的利润，redhat的商业模式是否解决了开源软件的问题</p>\n</div>\n        </div>\n      \n        <div class=\"chat-message assistant\">\n          <img no-lazy=\"\" class=\"avatar\" src=\"/medias_webp/avatar/1.jpg\" alt=\"Assistant\">\n          <div class=\"chat-content\"><p>Red Hat 确实是一家非常成功的开源软件公司，它的商业模式可以说是解决了开源软件的问题之一。Red Hat 的商业模式主要是基于以下两个方面：</p>\n<ol>\n<li>\n<p>提供专业支持：Red Hat 提供针对企业级用户的 Linux 操作系统和其他开源软件的专业支持，包括技术支持、培训、咨询和服务等，这可以解决企业在使用和维护开源软件时遇到的困难。</p>\n</li>\n<li>\n<p>付费订阅服务：Red Hat 基于其开源软件产品提供付费订阅服务，订阅用户可以获得 Red Hat 官方提供的软件更新、安全修复、新功能和技术支持等服务，这可以解决开源软件版本更新和安全性问题。</p>\n</li>\n</ol>\n<p>Red Hat 的商业模式的成功不仅在于它提供了专业的支持和服务，而且在于其能够让企业在同时获得开源软件的好处和商业化的优势。Red Hat 的开源软件产品在大多数情况下是免费的，但企业需要付费订阅服务才能获得更好的服务和支持，这既保证了开源软件的自由性和透明性，又能够为企业提供可靠的商业支持。</p>\n<p>总之，Red Hat 的商业模式是非常成功的，但并不能完全解决所有开源软件存在的问题。其他开源软件公司和社区也在不断探索和创新商业模式，以解决开源软件存在的问题。</p>\n</div>\n        </div>\n      \n        <div class=\"chat-message user\">\n          <img no-lazy=\"\" class=\"avatar\" src=\"/medias_webp/avatar/2.jpg\" alt=\"User\">\n          <div class=\"chat-content\"><p>在互联网领域，几乎都是使用的开源软件，未来，开源软件会统治所有的互联网标准么？</p>\n</div>\n        </div>\n      \n        <div class=\"chat-message assistant\">\n          <img no-lazy=\"\" class=\"avatar\" src=\"/medias_webp/avatar/1.jpg\" alt=\"Assistant\">\n          <div class=\"chat-content\"><p>开源软件在互联网领域确实得到了广泛的应用，成为了很多公司和组织选择的首选。然而，要说开源软件会统治所有的互联网标准，还是有一定的困难。</p>\n<p>首先，虽然开源软件在很多领域已经达到了很高的水平，但在某些特定领域，闭源软件仍然具有更好的性能和效率。例如，在一些高性能计算领域，闭源软件仍然是不可替代的选择。</p>\n<p>其次，开源软件也存在一些问题和限制。例如，开源软件的发展和更新速度可能会比较慢，有时候可能存在安全和兼容性问题，需要用户花费时间和精力进行自我调试和维护。</p>\n<p>最后，由于开源软件的自由性和透明性，它们存在着无法控制的风险。如果在开源软件的代码中存在漏洞或安全问题，攻击者可以很容易地获取代码并利用其中的漏洞进行攻击。这可能会对企业和组织的安全带来潜在风险。</p>\n<p>综上所述，虽然开源软件在互联网领域中得到了广泛应用，但是它们并不一定会成为统治所有互联网标准的唯一选择。在未来，我们可能会看到开源软件和闭源软件之间的协同发展，以提供更好的解决方案。</p>\n</div>\n        </div>\n      \n        <div class=\"chat-message user\">\n          <img no-lazy=\"\" class=\"avatar\" src=\"/medias_webp/avatar/2.jpg\" alt=\"User\">\n          <div class=\"chat-content\"><p>但是，我看到，越来越多的闭源软件公司倒闭了，或者转为开源软件模式，例如firefox，谷歌的chrome，开源软件的占比越来越高，你有什么看法</p>\n</div>\n        </div>\n      \n        <div class=\"chat-message assistant\">\n          <img no-lazy=\"\" class=\"avatar\" src=\"/medias_webp/avatar/1.jpg\" alt=\"Assistant\">\n          <div class=\"chat-content\"><p>是的，确实有越来越多的闭源软件公司倒闭或者转为开源软件模式，而开源软件在互联网领域中的占比也越来越高。这是因为开源软件具有很多优势，包括透明性、自由性、灵活性、可定制性等，而这些优势正好能够满足当前互联网应用的需求。</p>\n<p>另外，随着云计算和开放云平台的发展，开源软件也得到了更多的应用机会。云计算和开放云平台为开源软件提供了更好的部署和使用方式，同时也提高了开源软件在企业和组织中的接受度和应用价值。</p>\n<p>最后，开源软件社区的活跃度和贡献者数量也在不断增加，这进一步促进了开源软件的发展和普及。开源软件社区的活跃度和贡献者数量越多，开源软件的功能和性能就越强大，这也让更多的企业和组织愿意选择开源软件。</p>\n<p>综上所述，开源软件在互联网领域中的占比确实越来越高，这是因为开源软件具有很多优势，并且得到了更多的应用机会和社区支持。不过，仍然需要注意开源软件本身的一些问题和限制，并且需要根据实际情况选择最适合自己的软件解决方案。</p>\n</div>\n        </div>\n      \n        <div class=\"chat-message user\">\n          <img no-lazy=\"\" class=\"avatar\" src=\"/medias_webp/avatar/2.jpg\" alt=\"User\">\n          <div class=\"chat-content\"><p>开源软件是由谁主导的？</p>\n</div>\n        </div>\n      \n        <div class=\"chat-message assistant\">\n          <img no-lazy=\"\" class=\"avatar\" src=\"/medias_webp/avatar/1.jpg\" alt=\"Assistant\">\n          <div class=\"chat-content\"><p>开源软件的开发和推广通常是由开源社区和贡献者主导的。这些社区由一群热爱技术和开源理念的人组成，他们相信共享和协作的力量，致力于开发和维护开源软件项目。</p>\n<p>开源社区是由志愿者、爱好者、开发者和公司等组成的多方参与的群体，其成员之间通过互相交流和合作来推动软件的开发和改进。开源社区通常拥有完善的组织结构和开发流程，例如开发者的代码提交、审查和合并流程、用户的反馈和贡献流程等，这些流程可以帮助开发者更好地协作、沟通和共同推进软件的发展。</p>\n<p>除了开源社区，一些公司也在开源软件的发展中扮演了重要的角色。这些公司可以是开源软件的赞助者、贡献者或用户，也可以是基于开源软件构建自己产品和服务的企业。一些知名的开源软件公司，例如Red Hat、Canonical、MongoDB等，不仅为开源社区提供了财务和技术上的支持，同时也为企业用户提供了开源软件的商业服务和支持，从而帮助开源软件在企业中得到更广泛的应用。</p>\n<p>总之，开源软件的开发和推广主要由开源社区和贡献者主导，同时得到了一些公司的支持和参与。这种多方参与的开发模式可以使得开源软件具有更广泛的用户和应用范围，也可以让软件得到更多人的参与和贡献，从而推动软件的不断发展和完善。</p>\n</div>\n        </div>\n      \n        <div class=\"chat-message user\">\n          <img no-lazy=\"\" class=\"avatar\" src=\"/medias_webp/avatar/2.jpg\" alt=\"User\">\n          <div class=\"chat-content\"><p>有人或者组织能够独裁控制开源软件走向么？例如只支持某个操作系统，或者不准某些企业或国家使用</p>\n</div>\n        </div>\n      \n        <div class=\"chat-message assistant\">\n          <img no-lazy=\"\" class=\"avatar\" src=\"/medias_webp/avatar/1.jpg\" alt=\"Assistant\">\n          <div class=\"chat-content\"><p>在开源软件的开发和推广过程中，由于开放的自由性和民主性，很难有人或组织能够完全独裁控制开源软件的走向和应用范围。这是因为开源软件是基于开放源代码的共享和协作模式，其代码和文档等资源都是公开的，并且可以被其他人自由地使用、修改和再分发。</p>\n<p>开源软件通常采用自由软件许可证进行授权，这些许可证保障了用户的自由，例如选择软件的使用、复制、修改和再分发等。这些自由是在法律框架下保护的，因此，无论是个人、企业还是国家，都可以使用和参与开源软件的开发和推广。</p>\n<p>开源软件的发展和应用也是一个开放和民主的过程，任何人都可以参与到开源社区中，提交代码、提出建议和反馈、进行讨论等等，从而共同推动软件的发展和改进。在开源社区中，没有人或组织能够完全控制软件的走向和应用范围，而是基于开放和民主的原则，通过共同协作和讨论来制定和决定软件的发展方向和应用范围。</p>\n<p>因此，开源软件的开放性和民主性是其成功的关键之一，也是其能够避免独裁控制的重要保障。</p>\n</div>\n        </div>\n      \n        <div class=\"chat-message user\">\n          <img no-lazy=\"\" class=\"avatar\" src=\"/medias_webp/avatar/2.jpg\" alt=\"User\">\n          <div class=\"chat-content\"><p>你对谷歌禁止华为使用android，导致华为开发鸿蒙操作系统有什么看法</p>\n</div>\n        </div>\n      \n        <div class=\"chat-message assistant\">\n          <img no-lazy=\"\" class=\"avatar\" src=\"/medias_webp/avatar/1.jpg\" alt=\"Assistant\">\n          <div class=\"chat-content\"><p>谷歌决定禁止向华为提供Android许可证，导致华为无法获得最新的Android更新和支持。这一决定是由于华为与美国政府的关系引起的，谷歌也只是在执行美国政府的规定。这对华为造成了一定的影响，需要花费更多的时间和资源开发自己的操作系统。</p>\n<p>从另一个角度来看，这也提醒了人们开源软件的优势，即开放的自由性和可控性。由于Android的源代码是公开的，华为可以根据自身需求自主开发和修改操作系统，降低了对其他公司的依赖和控制。这也促使华为加快了自主操作系统鸿蒙的研发和推广，增强了技术自主性和可控性。</p>\n<p>总的来说，谷歌禁止华为使用Android虽然给华为带来了一定的困扰，但也加快了自主操作系统的研发和推广，体现了开源软件的优势和技术自主性的重要性。</p>\n</div>\n        </div>\n      \n        <div class=\"chat-message user\">\n          <img no-lazy=\"\" class=\"avatar\" src=\"/medias_webp/avatar/2.jpg\" alt=\"User\">\n          <div class=\"chat-content\"><p>我看到现实生活中，谁掌握了金钱，谁有大量的工程师开发人员，谁就有能力创建分支，或者主导开源软件的走向，对么？</p>\n</div>\n        </div>\n      \n        <div class=\"chat-message assistant\">\n          <img no-lazy=\"\" class=\"avatar\" src=\"/medias_webp/avatar/1.jpg\" alt=\"Assistant\">\n          <div class=\"chat-content\"><p>在某种程度上，金钱和人力资源的掌控确实可以对开源软件的走向产生一定的影响。但是，开源软件的社区是由广泛的利益相关方组成的，不仅包括了公司和组织，也包括了个人用户和开发者。在这个社区中，每个人都有权利和能力发表自己的意见和建议，参与到开源软件的开发和讨论中。</p>\n<p>因此，即使某些公司或组织拥有更多的资源和影响力，但是也需要考虑到广泛的利益相关方的需求和利益。如果一个公司或组织试图独断地掌控开源软件的走向，可能会面临社区成员的反对和抵制。此外，开源软件的代码是公开的，任何人都可以自由地复制、修改和分支，因此即使某个公司或组织试图掌控某个开源软件，也无法完全控制其走向。</p>\n<p>因此，开源软件的发展是由整个社区共同推动和影响的，任何单一的利益相关方都无法完全控制其走向。</p>\n</div>\n        </div>\n      \n        <div class=\"chat-message user\">\n          <img no-lazy=\"\" class=\"avatar\" src=\"/medias_webp/avatar/2.jpg\" alt=\"User\">\n          <div class=\"chat-content\"><p>你对oracle收购mysql后，mysql的创始人出走，创建mariadb，有什么看法</p>\n</div>\n        </div>\n      \n        <div class=\"chat-message assistant\">\n          <img no-lazy=\"\" class=\"avatar\" src=\"/medias_webp/avatar/1.jpg\" alt=\"Assistant\">\n          <div class=\"chat-content\"><p>Oracle收购MySQL后，MySQL的创始人Michael Widenius确实离开了Oracle，随后创建了MariaDB这个分支，这也是开源软件的一种特点，任何人都可以基于原有代码分支出去创建一个新的项目，这样可以实现更加个性化的需求和自由度。</p>\n<p>从MariaDB的角度来看，他们希望继续发展MySQL所代表的关系数据库的优点，并且希望推出一些新的功能和特性，以此吸引更多的用户。同时，MariaDB也注重开源社区的参与和贡献，这一点和MySQL的开源文化类似。在开源软件的世界里，分支和创新是非常普遍的现象，而这些分支往往会针对特定的用户需求，从而推出更加优秀的解决方案。</p>\n<p>总的来说，Oracle收购MySQL后，MySQL的创始人离开创建MariaDB，也展现了开源软件的另外一种特点，即开源社区的自由度和创新性，任何人都可以基于原有代码进行修改和分支，从而创建出更适合自己需求的解决方案。</p>\n</div>\n        </div>\n      \n        <div class=\"chat-message user\">\n          <img no-lazy=\"\" class=\"avatar\" src=\"/medias_webp/avatar/2.jpg\" alt=\"User\">\n          <div class=\"chat-content\"><p>我看到，越来越多的大公司采用开源的模式开发软件，谁不做开源，谁就会被业界淘汰，这种说法对么</p>\n</div>\n        </div>\n      \n        <div class=\"chat-message assistant\">\n          <img no-lazy=\"\" class=\"avatar\" src=\"/medias_webp/avatar/1.jpg\" alt=\"Assistant\">\n          <div class=\"chat-content\"><p>在当前的软件开发领域，开源软件确实已经变得越来越普遍，越来越多的大公司也开始采用开源的模式进行软件开发，这是因为开源软件具有很多优点，比如可以节约成本、提高软件质量、增加开发效率等等。因此，采用开源的模式来开发软件的公司和项目越来越多，这也是一种趋势。</p>\n<p>然而，不能简单地说谁不做开源就会被业界淘汰。闭源软件也有其存在的合理性，比如有些公司需要保护商业机密或是保持技术优势等等，因此不会选择开源软件。此外，对于某些领域或特定的应用场景，闭源软件可能会更为适合。</p>\n<p>总之，开源软件的普及是一个趋势，但是不能简单地说谁不做开源就会被业界淘汰，应该根据具体情况来选择采用开源还是闭源的方式。</p>\n</div>\n        </div>\n      \n        <div class=\"chat-message user\">\n          <img no-lazy=\"\" class=\"avatar\" src=\"/medias_webp/avatar/2.jpg\" alt=\"User\">\n          <div class=\"chat-content\"><p>你了解v2ray, v2fly, xray之间的关系么，这对于了解开源软件的分裂和发展是一个很好地观察对象</p>\n</div>\n        </div>\n      \n        <div class=\"chat-message assistant\">\n          <img no-lazy=\"\" class=\"avatar\" src=\"/medias_webp/avatar/1.jpg\" alt=\"Assistant\">\n          <div class=\"chat-content\"><p>是的，我了解v2ray、v2fly和xray之间的关系。这三个项目都是开源的代理软件，都基于v2ray核心代码开发而来，但是它们之间又有一些不同之处。</p>\n<p>v2ray是最早的一个项目，由一个叫做\"逆向太阳\"的开发者发起，并得到了很多社区贡献者的支持。后来，由于一些开发方面的分歧，v2ray的主要开发者\"逆向太阳\"和其他核心开发者决裂，最终导致了v2ray项目的分裂。</p>\n<p>v2fly是在v2ray分裂后成立的一个新项目，由一些原来的v2ray社区贡献者和其他开发者组成的团队共同开发，旨在继续推进v2ray的发展。与v2ray不同的是，v2fly更加注重用户体验，提供了更加友好的界面和更多的功能。</p>\n<p>xray是最近出现的一个项目，也是基于v2ray核心代码开发而来，但是它在性能方面进行了很大的优化，并增加了一些新的功能。与v2ray和v2fly不同的是，xray由一个商业公司进行开发和支持。</p>\n<p>这三个项目之间的关系反映了开源软件的分裂和发展的一般规律。在开源社区中，由于人员变动、技术分歧、商业利益等因素的影响，很容易出现项目分裂的情况，而且分裂后的项目往往会根据各自的方向和目标进行不同的发展。但是，这些项目之间也会有合作和交流，共同推进整个领域的发展。</p>\n</div>\n        </div>\n      \n        <div class=\"chat-message user\">\n          <img no-lazy=\"\" class=\"avatar\" src=\"/medias_webp/avatar/2.jpg\" alt=\"User\">\n          <div class=\"chat-content\"><p>对于一些新的操作系统挑战者，只能选择开源的方式才能和闭源的微软操作系统相对抗，对么？</p>\n</div>\n        </div>\n      \n        <div class=\"chat-message assistant\">\n          <img no-lazy=\"\" class=\"avatar\" src=\"/medias_webp/avatar/1.jpg\" alt=\"Assistant\">\n          <div class=\"chat-content\"><p>可以这么说。操作系统是一个非常复杂的软件系统，需要大量的研发资源和技术积累才能打造出一款稳定、安全、易用的产品。相对于成熟的闭源操作系统，新的操作系统挑战者往往面临着技术和资源上的巨大压力。选择开源的方式，可以借鉴已有的开源技术和社区资源，降低开发成本和风险，提高开发效率。同时，开源的方式也可以吸引更多的开发者和用户参与到项目中来，形成一个更加广泛的社区和生态系统，增强产品的可持续发展能力。因此，对于一些新的操作系统挑战者来说，选择开源的方式确实是一个比较明智的选择。</p>\n</div>\n        </div>\n      \n        <div class=\"chat-message user\">\n          <img no-lazy=\"\" class=\"avatar\" src=\"/medias_webp/avatar/2.jpg\" alt=\"User\">\n          <div class=\"chat-content\"><p>开源就是免费，对么？</p>\n</div>\n        </div>\n      \n        <div class=\"chat-message assistant\">\n          <img no-lazy=\"\" class=\"avatar\" src=\"/medias_webp/avatar/1.jpg\" alt=\"Assistant\">\n          <div class=\"chat-content\"><p>不完全正确。开源软件和免费软件是不同的概念。开源软件是指软件源代码开放给公众，并允许公众在遵循特定协议的情况下自由使用、修改、分发和分享的软件。而免费软件是指在价格上免费提供给用户使用的软件，这并不意味着软件的源代码一定是开放的。实际上，开源软件往往是免费的，因为任何人都可以自由获取和使用源代码来构建软件。但是，也有一些开源软件提供商会提供商业版的软件，这些商业版的软件可能是收费的。因此，开源软件不一定就是免费的，而且免费软件也不一定就是开源的。</p>\n</div>\n        </div>\n      \n        <div class=\"chat-message user\">\n          <img no-lazy=\"\" class=\"avatar\" src=\"/medias_webp/avatar/2.jpg\" alt=\"User\">\n          <div class=\"chat-content\"><p>开源有哪些协议，商用使用能用那些协议的软件？</p>\n</div>\n        </div>\n      \n        <div class=\"chat-message assistant\">\n          <img no-lazy=\"\" class=\"avatar\" src=\"/medias_webp/avatar/1.jpg\" alt=\"Assistant\">\n          <div class=\"chat-content\"><p>开源软件有很多种协议，其中比较常见的包括：</p>\n<ol>\n<li>\n<p>GNU通用公共许可证（GPL）：允许自由使用、修改、发布和再授权源代码，但只有在使用相同的许可证下发布其衍生作品。</p>\n</li>\n<li>\n<p>BSD许可证：允许自由使用、修改、发布和再授权源代码，但要求在衍生作品中包含原始版权声明和许可证。</p>\n</li>\n<li>\n<p>MIT许可证：允许自由使用、修改、发布和再授权源代码，但不需要在衍生作品中包含原始版权声明和许可证。</p>\n</li>\n<li>\n<p>Apache许可证：允许自由使用、修改、发布和再授权源代码，但要求在衍生作品中包含原始版权声明、许可证和贡献者声明。</p>\n</li>\n</ol>\n<p>商用使用开源软件需要注意的是，不同的开源协议有不同的限制和要求。一些协议（如MIT许可证）对商业使用没有限制，而其他协议（如GPL许可证）可能会要求发布衍生作品的源代码，或者要求将使用的其他组件的源代码公开。因此，在商业使用开源软件之前，需要仔细阅读相关的许可证并遵守其规定。</p>\n</div>\n        </div>\n      </div>\n<h2 id=\"参考-致谢\">参考&amp;致谢</h2>\n<ul>\n<li>chatGPT</li>\n</ul>\n",
            "tags": [
                "devops",
                "chatgpt",
                "开源"
            ]
        },
        {
            "id": "https://blog.17lai.site/posts/78c3371/",
            "url": "https://blog.17lai.site/posts/78c3371/",
            "title": "那些有用的Github工具介绍！Action、app、workflow等",
            "date_published": "2022-10-02T11:16:04.000Z",
            "content_html": "<blockquote>\n<p>Github Actoins 是 GitHub 推出的持续集成 (Con­tin­u­ous in­te­gra­tion，简称 CI) 服务，它提供了配置非常不错的虚拟服务器环境，基于它可以进行构建、测试、打包、部署项目。是CICD的强力工具！</p>\n<p>本文介绍几个常用的极为有用的Action工具！</p>\n</blockquote>\n<span id=\"more\"></span>\n<p><img src=\"https://cimg1.17lai.site/data/2022/10/02/20221002200706.webp\" alt=\"\"></p>\n<h2 id=\"GitHub-Actions-是什么？\">GitHub Actions 是什么？</h2>\n<p>大家知道，持续集成由很多操作组成，比如抓取代码、运行测试、登录远程服务器，发布到第三方服务等等。GitHub 把这些操作就称为 actions。</p>\n<p>很多操作在不同项目里面是类似的，完全可以共享。GitHub 注意到了这一点，想出了一个很妙的点子，允许开发者把每个操作写成独立的脚本文件，存放到代码仓库，使得其他开发者可以引用。</p>\n<p>如果你需要某个 action，不必自己写复杂的脚本，直接引用他人写好的 action 即可，整个持续集成过程，就变成了一个 actions 的组合。这就是 GitHub Actions 最特别的地方。</p>\n<p>GitHub 做了一个<a href=\"https://github.com/marketplace?type=actions\">官方市场</a>，可以搜索到他人提交的 actions。另外，还有一个 <a href=\"https://github.com/sdras/awesome-actions\">awesome actions</a> 的仓库，也可以找到不少 action。</p>\n<p><img src=\"https://cimg1.17lai.site/data/2022/10/02/20221002200706-1.webp\" alt=\"\"></p>\n<p>上面说了，每个 action 就是一个独立脚本，因此可以做成代码仓库，使用<code>userName/repoName</code>的语法引用 action。比如，<code>actions/setup-node</code>就表示<code>github.com/actions/setup-node</code>这个<a href=\"https://github.com/actions/setup-node\">仓库</a>，它代表一个 action，作用是安装 Node.js。事实上，GitHub 官方的 actions 都放在 <a href=\"https://github.com/actions\">github.com/actions</a> 里面。</p>\n<p>更多 Github action 介绍</p>\n<p><a href=\"https://github.com/sdras/awesome-actions\">awesome-actions</a></p>\n<h2 id=\"Github-Action-使用限制：\">Github Action 使用限制：</h2>\n<blockquote>\n<ul>\n<li><a href=\"https://docs.github.com/cn/actions/learn-github-actions/usage-limits-billing-and-administration\">官方文档：使用限制、计费和管理</a></li>\n<li>在复刻公共仓库时，默认情况下将禁用计划的工作流程。</li>\n<li>在公共仓库中，当 60 天内未发生仓库活动时，将自动禁用计划的工作流程。</li>\n</ul>\n</blockquote>\n<ul>\n<li>每个仓库只能同时支持20个 workflow 并行。</li>\n<li>每小时可以调用1000次 GitHub API 。</li>\n<li>每个 job 最多可以执行6个小时。</li>\n<li>免费版的用户最大支持20个 job 并发执行，macOS 最大只支持5个。</li>\n<li>私有仓库每月累计使用时间为2000分钟，超过后$ 0.008/分钟，公共仓库则无限制。</li>\n</ul>\n<h2 id=\"Github-仓库与上游自动同步\">Github 仓库与上游自动同步</h2>\n<blockquote>\n<p>保持自己github的forks自动和上游仓库同步的</p>\n<p>信息来源于 <a href=\"https://github.com/wei/pull\">https://github.com/wei/pull</a></p>\n</blockquote>\n<h3 id=\"只同步默认分支的教程\">只同步默认分支的教程</h3>\n<blockquote>\n<p>当上游的仓库仅有一个默认分支。或者上游仓库有两个分支，我们仅需要同步他的默认分支，其他分支对内容对我们来说无关紧要。</p>\n</blockquote>\n<p><img src=\"https://cimg1.17lai.site/data/2022/10/02/20221002200706-2.webp\" alt=\"git1.jpg\"></p>\n<p>a)  登录自己的github账号，另开网页打开 <a href=\"https://github.com/wei/pull\">https://github.com/wei/pull</a></p>\n<p>b)  点击Pull app进行安装。</p>\n<p><img src=\"https://cimg1.17lai.site/data/2022/10/02/20221002200706-3.webp\" alt=\"git2.jpg\"></p>\n<p>c)  安装过程中会让你选择要选择那一种方式，All repositories(就是同步已经frok的仓库以及未来fork的仓库)，Only select repositories(仅选择要自己需要同步的仓库，其他fork的仓库不会被同步)，根据自己需求选择，实在不知道怎么选择，就选All repositories；点击install，完成安装。</p>\n<p><img src=\"https://cimg1.17lai.site/data/2022/10/02/20221002200706-4.webp\" alt=\"git3.jpg\"></p>\n<p>d)  后续，如果要调整1.c中的选项，打开 <a href=\"https://github.com/apps/pull\">https://github.com/apps/pull</a> ，点击Configure，输入github密码进入pull的相关设置。</p>\n<p><img src=\"https://cimg1.17lai.site/data/2022/10/02/20221002200706-5.webp\" alt=\"git4.jpg\"></p>\n<p>e)  进入后，找到Repository access，根据自己的需求，重新选择：All repositories(就是同步已经frok的仓库以及未来fork的仓库)，Only select repositories(仅选择要自己需要同步的仓库，其他fork的仓库不会被同步)，Save后保存生效。</p>\n<p><img src=\"https://cimg1.17lai.site/data/2022/10/02/20221002200706-6.webp\" alt=\"git5.jpg\"></p>\n<p>f)  Pull app作者虽然在项目中写道keeps your forks up-to-date with upstream via automated pull requests，但当上游仓库有更改时，自己的仓库会在3个小时内完成与上游的同步，3个小时是Pull app作者说的最长时间。当然也可以通过手动触发同步上游仓库，手动触发方式：<code>https://pull.git.ci/process/你的GitHub名字/你的仓库名字</code> （例如：<code>https://pull.git.ci/process/xxxxx/test</code> ），手动触发可能会进行人机验证，验证通过后会显示Success。</p>\n<p><img src=\"https://cimg1.17lai.site/data/2022/10/02/20221002200706-7.webp\" alt=\"git12.jpg\"></p>\n<p><img src=\"https://cimg1.17lai.site/data/2022/10/02/20221002200706-8.webp\" alt=\"git13.jpg\"></p>\n<h3 id=\"同步其他分支的教程\">同步其他分支的教程</h3>\n<p><img src=\"https://cimg1.17lai.site/data/2022/10/02/20221002200706-9.webp\" alt=\"git8.jpg\"></p>\n<p>a)  假设你fork了上游仓库后，你fork后的地址为 <code>https://github.com/你的仓库名字/test</code> ，首先设置完成第1部分内容，注意在1.c步骤没有设置全部同步的，要回到1.e步，确认是否设置同步了 <code>你的仓库名字/test</code>，如果没有,请添加上。</p>\n<p><img src=\"https://cimg1.17lai.site/data/2022/10/02/20221002200706-10.webp\" alt=\"git9.jpg\"></p>\n<p>b)  在默认分支下添加一个文件。</p>\n<p><img src=\"https://cimg1.17lai.site/data/2022/10/02/20221002200706-11.webp\" alt=\"git10.jpg\"></p>\n<p>c)  复制 <code>.github/pull.yml</code> 粘贴后看到以下页面，注意github前面的那个.别漏掉了。</p>\n<p><img src=\"https://cimg1.17lai.site/data/2022/10/02/20221002200706-12.webp\" alt=\"git11.jpg\"></p>\n<p>d)  请在<a href=\"https://github.com/wei/pull%5C#advanced-setup-with-config\">https://github.com/wei/pull\\#advanced-setup-with-config</a> 页复制代码，</p>\n<p>注意：upstream处要修改为上游仓库作者名字。</p>\n<p><img src=\"https://cimg1.17lai.site/data/2022/10/02/20221002200706-13.webp\" alt=\"git12.jpg\"></p>\n<p><img src=\"https://cimg1.17lai.site/data/2022/10/02/20221002200706-14.webp\" alt=\"git13.jpg\"></p>\n<p>e)  最终的示例如下，假设上游作者是zhangsan，所有的注意点都用红线圈出来了，保存后生效。</p>\n<p><img src=\"https://cimg1.17lai.site/data/2022/10/02/20221002200706-15.webp\" alt=\"git14.jpg\"></p>\n<p>f)  Pull app作者虽然在项目中写道keeps your forks up-to-date with upstream via automated pull requests，但当上游仓库有更改时，自己的仓库会在3个小时内完成与上游的同步，3个小时是Pull app作者说的最长时间。当然也可以通过手动触发同步上游仓库，手动触发方式：<code>https://pull.git.ci/process/你的GitHub名字/你的仓库名字</code> （例如：<code>https://pull.git.ci/process/xxxxx/test</code>），手动触发可能会进行人机验证，验证通过后会显示Success。具体见1.f提供的图片。</p>\n<p>g)  本人仅测试过forks一个仓库只有2个分支的项目，如果有多个分支，不能保证是否可行，请自行测试，或者是使用本教程第3部分高级玩法。</p>\n<h3 id=\"高级玩法\">高级玩法</h3>\n<blockquote>\n<p>当然，作者还有其他更好的项目用于同步所有分支，例如使用 GitHub actions 进行同步。请参考原作者的项目</p>\n</blockquote>\n<ul>\n<li><a href=\"https://github.com/wei/git-sync\">https://github.com/wei/git-sync</a></li>\n<li><a href=\"https://github.com/repo-sync/github-sync\">https://github.com/repo-sync/github-sync</a></li>\n</ul>\n<h2 id=\"Github-自动合并-PR\">Github 自动合并 PR</h2>\n<h3 id=\"renovate\">renovate</h3>\n<ul>\n<li><a href=\"https://github.com/marketplace/renovate\">renovate</a></li>\n<li><a href=\"https://docs.renovatebot.com/\">使用文档</a></li>\n<li><a href=\"https://docs.renovatebot.com/configuration-options/#automerge\">自动合并</a></li>\n</ul>\n<p><img src=\"https://cimg1.17lai.site/data/2022/10/02/20221002200706-16.webp\" alt=\"renovate free\"></p>\n<p>自动合并example  renovate.json</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\">{\n  \"extends\": [\"config:base\"],\n  \"assignees\": [\"17lai\"],\n  \"separateMinorPatch\": true,\n  \"packageRules\": [\n    {\n      \"updateTypes\": [\"minor\", \"patch\"],\n      \"automerge\": true,\n      \"automergeType\": \"branch\"\n    }\n  ]\n}</code></pre></div></figure>\n<h3 id=\"mergify\">mergify</h3>\n<ul>\n<li><a href=\"https://github.com/marketplace/mergify\">mergify</a></li>\n<li>开源项目这个工具是免费使用的！</li>\n</ul>\n<p><img src=\"https://cimg1.17lai.site/data/2022/10/02/20221002200706-17.webp\" alt=\"mergify free for open source\"></p>\n<h2 id=\"使用-Github-Dependabot-自动更新依赖版本\">使用 Github Dependabot 自动更新依赖版本</h2>\n<blockquote>\n<p>通过将配置文件检入仓库，可启用 Dependabot 版本更新。 配置文件指定存储在仓库中的清单或其他包定义文件的位置。 Dependabot 使用此信息来检查过时的软件包和应用程序。 Dependabot 确定依赖项是否有新版本，它通过查看依赖的语义版本 (semver) 来决定是否应更新该版本。 对于某些软件包管理器，Dependabot 版本更新 也支持供应。 供应（或缓存）的依赖项是检入仓库中特定目录的依赖项，而不是在清单中引用的依赖项。 即使包服务器不可用，供应的依赖项在生成时也可用。 Dependabot 版本更新可以配置为检查为新版本供应的依赖项，并在必要时更新它们。</p>\n</blockquote>\n<p>以上内容来自 GitHub 官方文档，简单的讲 Dependabot 就是一个没有感情的依赖更新机器人，在您的项目所依赖的上游软件包或应用程序发布新版本后，它会在您的 GitHub 仓库自动创建一个 PR 来更新依赖文件，并说明依赖更新内容，用户自己选择是否 merge 该 PR，效果如下图：</p>\n<p><img src=\"https://cimg1.17lai.site/data/2022/10/02/20221002200706-18.webp\" alt=\"Dependabot PR\"></p>\n<h3 id=\"开启-Dependabot\">开启 Dependabot</h3>\n<p>开启方式比较简单，仅需将 <code>dependabot.yml</code> 配置文件放入仓库的 <code>.github</code> 目录中即可开启。之后 Dependabot 就会自动提交 PR 来更新您项目中的依赖项了。您也可以在 GitHub 页面上进行操作，在仓库页面通过 <code>Insights</code> -&gt; <code>Dependency graph</code> -&gt; <code>Dependabot</code> -&gt; <code>Enable Dependabot</code> 路径即可开启，之后就可以点击 <code>Create config file</code> 来创建配置文件了。</p>\n<p><img src=\"https://cimg1.17lai.site/data/2022/10/02/20221002200706-19.webp\" alt=\"开启 Dependabot\"></p>\n<p>配置完成后，即可看到需要监控的依赖文件和上次检查更新的时间。</p>\n<p><img src=\"https://cimg1.17lai.site/data/2022/10/02/20221002200706-20.webp\" alt=\"img\"></p>\n<h3 id=\"配置-dependabot-yml\">配置 dependabot.yml</h3>\n<p>文件的配置也相对较为简单的直接，<code>version</code>、<code>updates</code>、<code>package-ecosystem</code> 、<code>schedule</code> 是必填的，还可以配置 <code>registries</code> 来指定私有仓库地址及认证信息。下面这个是官方示例，该示例中为 <code>npm</code> 和 <code>Docker</code> 配置了依赖自动更新，同时指定其依赖文件的地址和更新频率。有意思的是，在下面这个示例中，如果 Docker 依赖项已过时很久，可能会先执行 <code>daily</code> 安排，直到这些依赖项达到最新状态，然后降回每周安排。更多内容，可以参考<a href=\"https://docs.github.com/en/code-security/supply-chain-security/keeping-your-dependencies-updated-automatically/configuration-options-for-dependency-updates\">官方文档</a>。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\"># Basic dependabot.yml file with\n# minimum configuration for two package managers\n\nversion: 2\nupdates:\n  # Enable version updates for npm\n  - package-ecosystem: \"npm\"\n    # Look for `package.json` and `lock` files in the `root` directory\n    directory: \"/\"\n    # Check the npm registry for updates every day (weekdays)\n    schedule:\n      interval: \"daily\"\n\n  # Enable version updates for Docker\n  - package-ecosystem: \"docker\"\n    # Look for a `Dockerfile` in the `root` directory\n    directory: \"/\"\n    # Check for updates once a week\n    schedule:\n      interval: \"weekly\"</code></pre></div></figure>\n<h3 id=\"支持的包管理器\">支持的包管理器</h3>\n<p>目前 Dependabot 支持很多包管理器，具体内容可以参考下表：</p>\n<ul>\n<li>要用于 <code>dependabot.yml</code> 文件中的 YAML 值</li>\n<li>支持的包管理器版本</li>\n<li>是否支持私有 GitHub 仓库或注册表中的依赖项</li>\n<li>是否支持供应的依赖项</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>Package manager</th>\n<th>YAML value</th>\n<th>Supported versions</th>\n<th>Private repositories</th>\n<th>Private registries</th>\n<th>Vendoring</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Bundler</td>\n<td><code>bundler</code></td>\n<td>v1, v2</td>\n<td></td>\n<td><strong>✓</strong></td>\n<td><strong>✓</strong></td>\n</tr>\n<tr>\n<td>Cargo</td>\n<td><code>cargo</code></td>\n<td>v1</td>\n<td><strong>✓</strong></td>\n<td><strong>✓</strong></td>\n<td></td>\n</tr>\n<tr>\n<td>Composer</td>\n<td><code>composer</code></td>\n<td>v1, v2</td>\n<td><strong>✓</strong></td>\n<td><strong>✓</strong></td>\n<td></td>\n</tr>\n<tr>\n<td>Docker</td>\n<td><code>docker</code></td>\n<td>v1</td>\n<td><strong>✓</strong></td>\n<td><strong>✓</strong></td>\n<td></td>\n</tr>\n<tr>\n<td>Hex</td>\n<td><code>mix</code></td>\n<td>v1</td>\n<td></td>\n<td><strong>✓</strong></td>\n<td></td>\n</tr>\n<tr>\n<td>elm-package</td>\n<td><code>elm</code></td>\n<td>v0.19</td>\n<td><strong>✓</strong></td>\n<td><strong>✓</strong></td>\n<td></td>\n</tr>\n<tr>\n<td>git submodule</td>\n<td><code>gitsubmodule</code></td>\n<td>N/A (no version)</td>\n<td><strong>✓</strong></td>\n<td><strong>✓</strong></td>\n<td></td>\n</tr>\n<tr>\n<td>GitHub Actions</td>\n<td><code>github-actions</code></td>\n<td>N/A (no version)</td>\n<td><strong>✓</strong></td>\n<td><strong>✓</strong></td>\n<td></td>\n</tr>\n<tr>\n<td>Go modules</td>\n<td><code>gomod</code></td>\n<td>v1</td>\n<td><strong>✓</strong></td>\n<td><strong>✓</strong></td>\n<td><strong>✓</strong></td>\n</tr>\n<tr>\n<td>Gradle</td>\n<td><code>gradle</code></td>\n<td>N/A (no version)</td>\n<td><strong>✓</strong></td>\n<td><strong>✓</strong></td>\n<td></td>\n</tr>\n<tr>\n<td>Maven</td>\n<td><code>maven</code></td>\n<td>N/A (no version)</td>\n<td><strong>✓</strong></td>\n<td><strong>✓</strong></td>\n<td></td>\n</tr>\n<tr>\n<td>npm</td>\n<td><code>npm</code></td>\n<td>v6, v7</td>\n<td><strong>✓</strong></td>\n<td><strong>✓</strong></td>\n<td></td>\n</tr>\n<tr>\n<td>NuGet</td>\n<td><code>nuget</code></td>\n<td>&lt;= 4.8</td>\n<td><strong>✓</strong></td>\n<td><strong>✓</strong></td>\n<td></td>\n</tr>\n<tr>\n<td>pip</td>\n<td><code>pip</code></td>\n<td>v21.1.2</td>\n<td></td>\n<td><strong>✓</strong></td>\n<td></td>\n</tr>\n<tr>\n<td>pipenv</td>\n<td><code>pip</code></td>\n<td>&lt;= 2021-05-29</td>\n<td></td>\n<td><strong>✓</strong></td>\n<td></td>\n</tr>\n<tr>\n<td>pip-compile</td>\n<td><code>pip</code></td>\n<td>6.1.0</td>\n<td></td>\n<td><strong>✓</strong></td>\n<td></td>\n</tr>\n<tr>\n<td>poetry</td>\n<td><code>pip</code></td>\n<td>v1</td>\n<td></td>\n<td><strong>✓</strong></td>\n<td></td>\n</tr>\n<tr>\n<td>Terraform</td>\n<td><code>terraform</code></td>\n<td>&gt;= 0.13, &lt;= 1.0</td>\n<td><strong>✓</strong></td>\n<td><strong>✓</strong></td>\n<td></td>\n</tr>\n<tr>\n<td>yarn</td>\n<td><code>npm</code></td>\n<td>v1</td>\n<td><strong>✓</strong></td>\n<td><strong>✓</strong></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<p>更多内容可以参考<a href=\"https://docs.github.com/en/code-security/supply-chain-security/keeping-your-dependencies-updated-automatically/about-dependabot-version-updates#supported-repositories-and-ecosystems\">官方文档</a>。</p>\n<h2 id=\"Gitlab-镜像-Github\">Gitlab 镜像 Github</h2>\n<blockquote>\n<p>这个功能需要 gitlab ee 版本，CE版本是不支持镜像的</p>\n</blockquote>\n<ul>\n<li>个人用户可以参考 <a href=\"/posts/29a820b3/\">破解Gitlab EE</a></li>\n<li>企业用户去付费买授权</li>\n</ul>\n<p><img src=\"https://cimg1.17lai.site/data/2022/10/02/20221002200706-21.webp\" alt=\"Gitlab Mirror\"></p>\n<h2 id=\"Github-仓库备份\">Github 仓库备份</h2>\n<blockquote>\n<p>最优秀的资源，大多只在短时间内出现！</p>\n<p>平时多备份你重要的仓库，以及你使用的仓库的重要上下游仓库！</p>\n</blockquote>\n<blockquote>\n<ul>\n<li><a href=\"https://github.com/appotry/docker-github-backup\">github-backup Githb</a></li>\n<li><a href=\"https://hub.docker.com/r/lnxd/github-backup\">github-backup Dockerhub</a></li>\n</ul>\n</blockquote>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">githubback:\n  image: lnxd/github-backup\n  container_name: \"githubback\"\n  hostname: githubback\n  # ports:\n    # - \"80:80\"\n  volumes:\n    - \"${USERDIR}/githubback/data:/home/docker/backups:rw\"\n  env_file:\n    - .env\n  environment:\n    - HTTP_PROXY=http://[ip]:[port]\n    - HTTPS_PROXY=http://[ip]:[port]\n  restart: always</code></pre></div></figure>\n<h2 id=\"自动翻译\">自动翻译</h2>\n<p>实例 GitHub Action <a href=\"https://github.com/walinejs/waline/blob/main/.github/workflows/issue-translator.yml\">https://github.com/walinejs/waline/blob/main/.github/workflows/issue-translator.yml</a></p>\n<p>源码 <a href=\"https://github.com/lizheming/issues-translate-action\">https://github.com/lizheming/issues-translate-action</a> 基于 <a href=\"https://github.com/dromara/issues-translate-action\">https://github.com/dromara/issues-translate-action</a></p>\n<h2 id=\"后记\">后记</h2>\n<p>github action 太多强大，这里仅仅只能介绍一点点，有太多好东西了，太多宝藏值得去挖掘！</p>\n<p>这就是开源的力量！在被大公司白嫖的同时，创造了无与伦比的社区生态！</p>\n<h2 id=\"参考-致谢\">参考&amp;致谢</h2>\n<ul>\n<li><a href=\"https://www.ruanyifeng.com/blog/2019/09/getting-started-with-github-actions.html\">GitHub Actions 入门教程</a></li>\n<li><a href=\"https://guoxudong.io/post/github-dependabot/\">使用 Github Dependabot 自动更新依赖版本</a></li>\n<li><a href=\"https://p3terx.com/archives/github-actions-started-tutorial.html\">GitHub Actions 入门教程</a></li>\n</ul>\n<h2 id=\"系列教程\"><strong>系列教程</strong></h2>\n<p><a href=\"/atom.xml\"><i class=\"fas fa-rss\"></i>全部文章RSS订阅</a></p>\n<h3 id=\"Devops系列\"><strong>Devops系列</strong></h3>\n<p><a href=\"/categories/devops/atom.xml\"><i class=\"fas fa-rss\"></i><strong>Devops 分类 RSS 订阅</strong></a></p>\n<ul>\n<li><a href=\"/posts/ab63eb8f/\">自建全套开源Devops开发系统</a></li>\n<li><a href=\"/posts/d32a07a7/\">Git介绍以及分支模型图解</a></li>\n<li><a href=\"/posts/39563241/\">三万字无坑搭建基于Docker+K8S+GitLab/SVN+Jenkins+Harbor持续集成交付环境</a></li>\n<li><a href=\"/posts/3437994a/\">DevOps系列—【Jenkinsfile+Dockerfile+nginx+vue】</a></li>\n<li><a href=\"/posts/f4c3ad41/\">项目开发管理工具推荐</a></li>\n<li><a href=\"/posts/acc13b70/\">Gitlab的安装及使用教程完全版</a></li>\n<li><a href=\"/posts/d08eb7b/\">Gitlab的安装及使用</a></li>\n<li><a href=\"/posts/78c3371/\">那些有用的Github工具介绍！Action、app、workflow等</a></li>\n</ul>\n<h3 id=\"Gitbook使用系列\"><strong>Gitbook使用系列</strong></h3>\n<p><a href=\"/categories/gitbook/atom.xml\"><i class=\"fas fa-rss\"></i>Gitbook分类RSS订阅</a></p>\n<ul>\n<li><a href=\"/posts/7fe86002/\">GitBook+GitLab撰写发布技术文档-Part1:GitBook篇</a></li>\n<li><a href=\"/posts/7790e989/\">GitBook+GitLab撰写发布技术文档-Part2:GitLab篇</a></li>\n<li><a href=\"/posts/d6bad1e5/\">自己动手制作电子书的最佳方式（支持PDF、ePub、mobi等格式）</a></li>\n</ul>\n<h3 id=\"Gitlab-使用系列\"><strong>Gitlab 使用系列</strong></h3>\n<p><a href=\"/categories/gitlab/atom.xml\"><i class=\"fas fa-rss\"></i><strong>Gitlab RSS 分类订阅</strong></a></p>\n<ul>\n<li><a href=\"/posts/acc13b70/\"><strong>Gitlab的安装及使用教程完全版</strong></a></li>\n<li><a href=\"/posts/29a820b3/\">破解Gitlab EE</a></li>\n<li><a href=\"/posts/d08eb7b/\">Gitlab的安装及使用</a></li>\n<li><a href=\"/posts/1879721e/\">CI/CD与Git Flow与GitLab</a></li>\n</ul>\n",
            "tags": [
                "github",
                "action",
                "workflow"
            ]
        },
        {
            "id": "https://blog.17lai.site/posts/ab63eb8f/",
            "url": "https://blog.17lai.site/posts/ab63eb8f/",
            "title": "自建全套开源Devops开发系统",
            "date_published": "2022-05-09T05:00:25.000Z",
            "content_html": "<blockquote>\n<p>国内的Devops云平台动辄封号，删库，屏蔽，还多次发生数据泄密，项目被云平台克隆事件，国内云平台devops已死！数据安全没法保证，自建私有Devops平台才靠谱。这里采用开源项目建立一个完善的低成本Devops系统，基本运行良好！</p>\n</blockquote>\n<blockquote>\n<p>目标：单节点，以最低成本，最低消耗，使用开源软件实现一个可用的DevOps！满足中小企业的研发、测试、运维需求。并对后续如何扩展本套DevOps系统做了项目，成本，路线升级规划，可以一直扩展到业界最前沿最大系统。</p>\n<p>整套系统已经跑起来很长时间了！单节点Nas服务器，32G内存，共运行了约80个Docker，优化到平均负载10以下。</p>\n</blockquote>\n<p><img src=\"https://cimg1.17lai.site/data/2022/05/14/20220514113906.webp\" alt=\"devops\"></p>\n<span id=\"more\"></span>\n<h2 id=\"Devops框架图解\">Devops框架图解</h2>\n<blockquote>\n<p>下面系统大多可以做负载平衡，多节点备份，可以扩展为一个高可用，大中央平台。</p>\n<p>珍爱生命，使用<code>Docker</code>！</p>\n</blockquote>\n<p><img src=\"https://cimg1.17lai.site/data/2022/05/09/20220509132230.webp\" alt=\"自建Devops.drawio\"></p>\n<h2 id=\"开源云平台生死连问\">开源云平台生死连问</h2>\n<blockquote>\n<p>珍爱生命，不建议使用国内云平台。</p>\n</blockquote>\n<p>什么是大教堂？</p>\n<p>什么是集市？</p>\n<p>什么是信任链？</p>\n<p>什么是开源生态？</p>\n<p>为什么要做开源生态？</p>\n<p>怎么做开源生态？</p>\n<p>开源生态的土壤肥力维护如何做？</p>\n<p>这些问题没想明白，没想到如何做的是没法做开源的。</p>\n<p>国内平台连种子嫩芽都要收割，到处收费，动辄删库，屏蔽，封号，注定做不了开源生态。</p>\n<h2 id=\"Consul自动负载均衡\"><code>Consul</code>自动负载均衡</h2>\n<blockquote>\n<p>基于服务自动发现和注册的负载均衡，负载均衡的方式没有变，只是多了一些<strong>外围组件</strong>，当然这些组件对 <code>Client</code> 是不可见的，<code>client</code> 依然只能看到 <code>Nginx</code> 入口，访问方式也没变化。</p>\n</blockquote>\n<p><img src=\"https://cimg1.17lai.site/data/2022/04/29/20220429190914-1.webp\" alt=\"Consul\"></p>\n<h2 id=\"Github仓库备份\"><code>Github</code>仓库备份</h2>\n<blockquote>\n<p>最优秀的资源，大多只在短时间内出现！</p>\n<p>平时多备份你重要的仓库，以及你使用的仓库的重要上下游仓库！</p>\n</blockquote>\n<blockquote>\n<ul>\n<li><a href=\"https://github.com/appotry/docker-github-backup\">github-backup Githb</a></li>\n<li><a href=\"https://hub.docker.com/r/lnxd/github-backup\">github-backup Dockerhub</a></li>\n</ul>\n</blockquote>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">githubback:\n  image: lnxd/github-backup\n  container_name: \"githubback\"\n  hostname: githubback\n  # ports:\n    # - \"80:80\"\n  volumes:\n    - \"${USERDIR}/githubback/data:/home/docker/backups:rw\"\n  env_file:\n    - .env\n  environment:\n    - HTTP_PROXY=http://[ip]:[port]\n    - HTTPS_PROXY=http://[ip]:[port]\n  restart: always</code></pre></div></figure>\n<h2 id=\"配置要求\">配置要求</h2>\n<p>个人Nas配置</p>\n<blockquote>\n<ul>\n<li>cpu j4125 4 核 14nm 2.00 GHz ~2.70 GHz</li>\n<li>SSD sata 接口的 读写 500MB/S</li>\n<li>32G DDR4. 2x16G 双通道</li>\n</ul>\n</blockquote>\n<p>上图中介绍的系统都是上面配置的单服务器中可以运行的。</p>\n<p>如何以最低的配置，最少的内存运行起来最多的功能才是本文的追求，花费更多金钱去满足极少数情况的高压力是钱多的没处花。</p>\n<ul>\n<li><code>8G</code>内存的nas 就可以运行 <code>gitea + drone</code> ，<code>zentao</code> 想用就用</li>\n<li><code>gitlab</code> 要跑起来至少要2核 <code>8G</code> 内存，<code>jenkins</code> 也是内存 <code>cpu</code> 占用大户。大于 <code>16G</code> 内存时考虑上这个</li>\n<li>4核 <code>32G</code> 内存的nas，图片中介绍的可以全都跑起来！</li>\n</ul>\n<h2 id=\"可靠性\">可靠性</h2>\n<p><code>ELK</code>集群监控对于单服务器来说完全多余，<code>netdata</code>监控也不错，<code>portainer</code>就够用了，以后为了节约资源，<code>portainer</code>说不定也会被干掉，大多数时候命令行监控就够了。少于200节点<code>K8S</code>就是多余的。</p>\n<h3 id=\"数据安全\">数据安全</h3>\n<blockquote>\n<p>云平台把数据交给别人，赌别人的道德不会私自偷拿你的数据？真是想多了。</p>\n<p>某垄断社交平台内部有专门的团队分析客户的数据，看有什么有价值的没有，是很多年前就爆出来的消息。</p>\n<p>自建<code>DevOps</code>成本其实相当的低！</p>\n</blockquote>\n<p>整套系统可以从少到多，从小到大，慢慢优化，扩展的。硬件成本也是随着需求变化而变化的，随着业务扩展而增加成本，一开始单节点单服务器就可以满足要求了，后面业务增加慢慢扩展为集群，k8s 等。</p>\n<p>数据，代码是公司核心资产与竞争力的公司，上云赌别人的人品就是找死。你注册账户的时候，就同意了，无论别人随意删除你的数据，或者窃取你的数据都是不用付任何责任的，再说，整个系统数据都在别人手上，你要维权也没有证据。</p>\n<h3 id=\"备份\">备份</h3>\n<ul>\n<li><code>UPS</code>电源，防止意外断电</li>\n<li><code>rsync</code> 备份，对于大多数人，已经够用了</li>\n<li>文件系统快照</li>\n<li>离线每日，或者每周冷备份</li>\n<li>大系统，多台服务器的时候可以用多节点集群备灾。<code>nginx</code>,<code>harbor</code>，<code>gitlab</code>，<code>elasticsearch</code>等都可以使用集群</li>\n</ul>\n<h2 id=\"扩展性\">扩展性</h2>\n<blockquote>\n<p>上面说的都可以单服务器搞定。多台服务器的时候可以用多节点集群备灾。<code>nginx</code>,<code>harbor</code>，<code>gitlab</code>，<code>elasticsearch</code>等都可以使用集群。</p>\n<p>多于200节点，大于3台服务器以后考虑上<code>K8S</code>。ELK监控之类的这时候可以上了。<a href=\"https://github.com/Tencent/bk-sops\">蓝鲸智云标准运维</a>这时候也可以考虑了。</p>\n<p>再次扩大的时候可以考虑<code>Proxmox VE（PVE）</code> + <code>ceph</code></p>\n<p>更大的系统，或者对外提供云平台服务的时候可以考虑上<code>OpenStack</code></p>\n</blockquote>\n<h2 id=\"项目介绍\">项目介绍</h2>\n<h3 id=\"ELK\">ELK</h3>\n<blockquote>\n<p>消耗资源很多，至少上百节点以上再考虑上这个</p>\n<p><code>portainer</code> -&gt; <code>netdata </code>-&gt; <code>ELK</code>，<code>zabbix </code></p>\n</blockquote>\n<p><img src=\"https://cimg1.17lai.site/data/2021/08/0520210805165405.png\" alt=\"\"></p>\n<h3 id=\"cacti\"><a href=\"https://www.cacti.net/\">cacti</a></h3>\n\n<div class=\"github-card-container\">\n  <div class=\"github-card\" data-user=\"Cacti\"></div>\n  <noscript>\n    <div class=\"github-card-error\">\n      JavaScript is required to load GitHub Cards\n    </div>\n  </noscript>\n</div>\n    \n\n<div class=\"github-card-container\">\n  <div class=\"github-card\" data-user=\"Cacti\" data-repo=\"cacti\"></div>\n  <noscript>\n    <div class=\"github-card-error\">\n      JavaScript is required to load GitHub Cards\n    </div>\n  </noscript>\n</div>\n    \n<h3 id=\"zabbix\">zabbix</h3>\n\n<div class=\"github-card-container\">\n  <div class=\"github-card\" data-user=\"zabbix\"></div>\n  <noscript>\n    <div class=\"github-card-error\">\n      JavaScript is required to load GitHub Cards\n    </div>\n  </noscript>\n</div>\n    \n\n<div class=\"github-card-container\">\n  <div class=\"github-card\" data-user=\"zabbix\" data-repo=\"zabbix\"></div>\n  <noscript>\n    <div class=\"github-card-error\">\n      JavaScript is required to load GitHub Cards\n    </div>\n  </noscript>\n</div>\n    \n<h3 id=\"ansible\">ansible</h3>\n\n<div class=\"github-card-container\">\n  <div class=\"github-card\" data-user=\"ansible\"></div>\n  <noscript>\n    <div class=\"github-card-error\">\n      JavaScript is required to load GitHub Cards\n    </div>\n  </noscript>\n</div>\n    \n\n<div class=\"github-card-container\">\n  <div class=\"github-card\" data-user=\"ansible\" data-repo=\"ansible\"></div>\n  <noscript>\n    <div class=\"github-card-error\">\n      JavaScript is required to load GitHub Cards\n    </div>\n  </noscript>\n</div>\n    \n<h3 id=\"CMDB\">CMDB</h3>\n\n<div class=\"github-card-container\">\n  <div class=\"github-card\" data-user=\"netbox-community\" data-repo=\"netbox\"></div>\n  <noscript>\n    <div class=\"github-card-error\">\n      JavaScript is required to load GitHub Cards\n    </div>\n  </noscript>\n</div>\n    \n\n<div class=\"github-card-container\">\n  <div class=\"github-card\" data-user=\"open-cmdb\" data-repo=\"cmdb\"></div>\n  <noscript>\n    <div class=\"github-card-error\">\n      JavaScript is required to load GitHub Cards\n    </div>\n  </noscript>\n</div>\n    \n<h3 id=\"PVE\">PVE</h3>\n<blockquote>\n<p>Proxmox VE（PVE）</p>\n</blockquote>\n\n<div class=\"github-card-container\">\n  <div class=\"github-card\" data-user=\"proxmox\"></div>\n  <noscript>\n    <div class=\"github-card-error\">\n      JavaScript is required to load GitHub Cards\n    </div>\n  </noscript>\n</div>\n    \n<h3 id=\"CEPH\"><a href=\"https://ceph.io/\">CEPH</a></h3>\n\n<div class=\"github-card-container\">\n  <div class=\"github-card\" data-user=\"ceph\"></div>\n  <noscript>\n    <div class=\"github-card-error\">\n      JavaScript is required to load GitHub Cards\n    </div>\n  </noscript>\n</div>\n    \n\n<div class=\"github-card-container\">\n  <div class=\"github-card\" data-user=\"ceph\" data-repo=\"ceph\"></div>\n  <noscript>\n    <div class=\"github-card-error\">\n      JavaScript is required to load GitHub Cards\n    </div>\n  </noscript>\n</div>\n    \n<h3 id=\"OpenStack\">OpenStack</h3>\n\n<div class=\"github-card-container\">\n  <div class=\"github-card\" data-user=\"openstack\"></div>\n  <noscript>\n    <div class=\"github-card-error\">\n      JavaScript is required to load GitHub Cards\n    </div>\n  </noscript>\n</div>\n    \n\n<div class=\"github-card-container\">\n  <div class=\"github-card\" data-user=\"openstack\" data-repo=\"openstack\"></div>\n  <noscript>\n    <div class=\"github-card-error\">\n      JavaScript is required to load GitHub Cards\n    </div>\n  </noscript>\n</div>\n    \n<h2 id=\"其它项目\">其它项目</h2>\n<blockquote>\n<p>大家还有啥好项目建议？</p>\n</blockquote>\n<h3 id=\"onedev\">onedev</h3>\n<p><a href=\"https://github.com/theonedev/onedev\">onedev</a> 是替代<code>Gitlab</code>的极佳候补，看文档介绍，潜力无限！</p>\n\n<div class=\"github-card-container\">\n  <div class=\"github-card\" data-user=\"theonedev\" data-repo=\"onedev\"></div>\n  <noscript>\n    <div class=\"github-card-error\">\n      JavaScript is required to load GitHub Cards\n    </div>\n  </noscript>\n</div>\n    \n<h3 id=\"smartdns\">smartdns</h3>\n<blockquote>\n<p>一个本地DNS服务器，获取最快的网站IP，获得最佳上网体验。</p>\n</blockquote>\n\n<div class=\"github-card-container\">\n  <div class=\"github-card\" data-user=\"pymumu\" data-repo=\"smartdns\"></div>\n  <noscript>\n    <div class=\"github-card-error\">\n      JavaScript is required to load GitHub Cards\n    </div>\n  </noscript>\n</div>\n    \n<h3 id=\"awesome-selfhosted\"><a href=\"https://github.com/awesome-selfhosted/awesome-selfhosted\">awesome-selfhosted</a></h3>\n<blockquote>\n<p>这里你能找到各种各样的自建 Docker 服务</p>\n</blockquote>\n\n<div class=\"github-card-container\">\n  <div class=\"github-card\" data-user=\"awesome-selfhosted\" data-repo=\"awesome-selfhosted\"></div>\n  <noscript>\n    <div class=\"github-card-error\">\n      JavaScript is required to load GitHub Cards\n    </div>\n  </noscript>\n</div>\n    \n<h3 id=\"私有Git服务器整理\">私有Git服务器整理</h3>\n<ol>\n<li>ruby系：<a href=\"https://gitlab.com/gitlab-org/gitlab\">GitLab</a>。这个没什么好说的，说到私有git服务器第一反应必然是这个，似乎也是目前已知的开源git服务器中体量最大的，功能齐全，界面美观。</li>\n<li>golang系：<a href=\"https://github.com/gogs/gogs\">Gogs</a>、<a href=\"https://github.com/go-gitea/gitea\">gitea</a>、<a href=\"https://codeberg.org/forgejo/forgejo\">forgejo</a>。这仨一脉相传，简单概括来说，就是先有的gogs，然后一群贡献者嫌gogs更新慢、不加新功能，然后fork出了gitea；然后gitea搞了几年之后开公司了，codeberg担心gitea搞收费，就又从gitea代码fork出了一个forgejo自己开发。</li>\n<li>Java系：<a href=\"https://github.com/gitbucket/gitbucket\">gitbucket</a>、<a href=\"https://github.com/gitblit-org/gitblit\">GitBlit</a>、<a href=\"https://github.com/theonedev/onedev\">OneDev</a>。这三家都是个搞个的，其中OneDev比较新，界面做的也比较现代化。</li>\n</ol>\n<h2 id=\"系列教程\"><strong>系列教程</strong></h2>\n<p><a href=\"/atom.xml\"><i class=\"fas fa-rss\"></i>全部文章RSS订阅</a></p>\n<h3 id=\"Devops系列\"><strong>Devops系列</strong></h3>\n<p><a href=\"/categories/devops/atom.xml\"><i class=\"fas fa-rss\"></i><strong>Devops 分类 RSS 订阅</strong></a></p>\n<ul>\n<li><a href=\"/posts/ab63eb8f/\">自建全套开源Devops开发系统</a></li>\n<li><a href=\"/posts/d32a07a7/\">Git介绍以及分支模型图解</a></li>\n<li><a href=\"/posts/39563241/\">三万字无坑搭建基于Docker+K8S+GitLab/SVN+Jenkins+Harbor持续集成交付环境</a></li>\n<li><a href=\"/posts/3437994a/\">DevOps系列—【Jenkinsfile+Dockerfile+nginx+vue】</a></li>\n<li><a href=\"/posts/f4c3ad41/\">项目开发管理工具推荐</a></li>\n<li><a href=\"/posts/acc13b70/\">Gitlab的安装及使用教程完全版</a></li>\n<li><a href=\"/posts/d08eb7b/\">Gitlab的安装及使用</a></li>\n<li><a href=\"/posts/78c3371/\">那些有用的Github工具介绍！Action、app、workflow等</a></li>\n</ul>\n<h2 id=\"相关文档\">相关文档</h2>\n<ul>\n<li><a href=\"http://dbaselife.com/project-3/\">Devops</a></li>\n</ul>\n",
            "tags": [
                "docker",
                "devops",
                "框架",
                "图解"
            ]
        },
        {
            "id": "https://blog.17lai.site/posts/d32a07a7/",
            "url": "https://blog.17lai.site/posts/d32a07a7/",
            "title": "Git介绍以及分支模型图解",
            "date_published": "2022-04-19T12:07:16.000Z",
            "content_html": "<blockquote>\n<p>不废话，直接上图。</p>\n<p>由 Drawio 绘制</p>\n</blockquote>\n<p><img src=\"https://cimg1.17lai.site/data/2022/04/1920220419221343.svg\" alt=\"git使用\"></p>\n<h2 id=\"GIT架构\"><strong>GIT架构</strong></h2>\n<p>GIT的架构，可以分为几个部分：</p>\n<ul>\n<li>本地工作区(working directory)</li>\n<li>暂存区(stage area, 又称为索引区, index)、</li>\n<li>本地仓库(local repository)、</li>\n<li>远程仓库副本</li>\n<li>远程仓库(remote repository)。</li>\n</ul>\n<p><strong>工作区(working directory)</strong> 简言之就是你工作的区域。对于git而言，就是的本地工作目录。工作区的内容会包含提交到暂存区和版本库(当前提交点)的内容，同时也包含自己的修改内容。</p>\n<p><strong>暂存区(stage area, 又称为索引区index)</strong> 是git中一个非常重要的概念。是我们把修改提交版本库前的一个过渡阶段。查看GIT自带帮助手册的时候，通常以index来表示暂存区。在工作目录下有一个.git的目录，里面有个index文件，存储着关于暂存区的内容。git add命令将工作区内容添加到暂存区。</p>\n<p><strong>本地仓库(local repository)</strong> 版本控制系统的仓库，存在于本地。当执行git commit命令后，会将暂存区内容提交到仓库之中。在工作区下面有.git的目录，这个目录下的内容不属于工作区，里面便是仓库的数据信息，暂存区相关内容也在其中。</p>\n<p><strong>远程版本库(remote repository)</strong> 与本地仓库概念基本一致，不同之处在于一个存在远程，可用于远程协作，一个却是存在于本地。通过push/pull可实现本地与远程的交互；</p>\n<p><strong>远程仓库副本</strong> 可以理解为存在于本地的远程仓库缓存。如需更新，可通过git fetch/pull命令获取远程仓库内容。使用fech获取时，并未合并到本地仓库，此时可使用git merge实现远程仓库副本与本地仓库的合并。</p>\n<h2 id=\"git介绍\"><code>.git</code>介绍</h2>\n<p><code>.git</code>目录下各个文件中所存放的内容信息：</p>\n<ul>\n<li>\n<p><strong>HEAD</strong> 当前所在位置，其实就是工作区的在版本库中的那个提交点，最终会指向一个40位的HASH值；</p>\n</li>\n<li>\n<p><strong>config</strong> 当前版本库的专有配置文件，如使用命令git config <a href=\"http://user.name\">user.name</a> poloxue便会记录在此文件；</p>\n</li>\n<li>\n<p><strong>description</strong> 被gitweb (Github的原型)用来显示对repo的描述。</p>\n</li>\n<li>\n<p><strong>hooks</strong> git有可自动运行在 git 任有意义阶段的脚本hooks, 如commit/release/pull/push等状态之前或者之后。个人思考的一个用处，如pre-push可以用来强制进行代码检查。</p>\n</li>\n<li>\n<p><strong>index</strong> 存放暂存区(stage area)的相关信息；</p>\n</li>\n<li>\n<p><strong>info/exclue</strong> 可以做到和.gitignore相同的事情，用于排除不要包含进版本库的文件。区别就是，此文件不会被共享。</p>\n</li>\n<li>\n<p><strong>refs/heads</strong> 目录下有关于本地仓库的所有分支；</p>\n</li>\n<li>\n<p><strong>refs/remote</strong> 目录下有关于远程仓库的所有分支；</p>\n</li>\n<li>\n<p><strong>object</strong> 目录下存放的就是实际的数据文件</p>\n</li>\n</ul>\n<h2 id=\"Commitizen\">Commitizen</h2>\n<blockquote>\n<p>Commitizen——标准化的Git commit工具</p>\n</blockquote>\n<p><img src=\"https://cimg1.17lai.site/data/2024/06/15/20240615121259.webp\" alt=\"Commitizen\"></p>\n<p>Commitizen 分为两部分，<a href=\"https://github.com/commitizen/cz-cli\">脚手架（cz-cli）</a> 和 <a href=\"https://github.com/commitizen/cz-cli#adapters\">规范（Adapters）</a></p>\n<p>脚手架可以帮助我们初始化和构建 Commitizen，而规范是开发者可以自定义的内容</p>\n<p>官方默认提供的规范是 <a href=\"https://www.npmjs.com/package/cz-conventional-changelog\">cz-conventional-changelog</a></p>\n<p>同时，官方也提供了一些优秀的第三方规范，例如你肯定想要的表情包commit规范：<a href=\"https://www.npmjs.com/package/cz-emoji-conventional\">cz-emoji-conventional</a></p>\n<p>本文也将提供这两种规范的安装和使用方式</p>\n<h2 id=\"安装\">安装</h2>\n<p>一条命令搞定</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">npm install -g commitizen</code></pre></div></figure>\n<p>这就安装成功了，而且是全局安装，以后再用就不用重复安装了</p>\n<p>当然，安装成功的只是一个脚手架，现在还不能使用</p>\n<h2 id=\"创建-package-json\">创建 package.json</h2>\n<p>Commitizen 基于 nodejs，想要使用的话，在你的项目中自然需要一个 package.json</p>\n<p>如果已经存在了那最好，没有的话，例如是一个 java 项目，那么你可以在项目根目录执行以下命令</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">npm init</code></pre></div></figure>\n<p>当然，如果不是 nodejs 的项目，你肯定不需要将这些文件也上传到 git</p>\n<p>你可以在 <code>.gitignore</code> 文件中加入下面几句来忽略这些文件</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-none\"><code class=\"language-none\">package-lock.json\npackage.json\nnode_modules/</code></pre></div></figure>\n<h2 id=\"初始化\">初始化</h2>\n<p>这一步就可以选择我们需要的规范了</p>\n<blockquote>\n<p>windows</p>\n</blockquote>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">commitizen init 规范名称 --save-dev --save-exact</code></pre></div></figure>\n<blockquote>\n<p>linux</p>\n</blockquote>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">commitizen init 规范名称 --yarn --dev --exact</code></pre></div></figure>\n<hr>\n<p>commitizen 脚手架会自动帮我们导入规范的依赖并进行下载，所以你只要注意不要写错规范名称就好了</p>\n<p>关于这些名称，可以参考 <a href=\"https://github.com/commitizen/cz-cli#adapters\">这里推荐的规范</a></p>\n<p>例如你想使用默认的规范</p>\n<p>那么可以这样写：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">commitizen init cz-conventional-changelog --save-dev --save-exact</code></pre></div></figure>\n<p>而如果你想使用带表情包的，就这样写：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">commitizen init cz-emoji-conventional --save-dev --save-exact</code></pre></div></figure>\n<h2 id=\"使用\">使用</h2>\n<p>使用的方式很简单，将你原本要输入的 <code>git commit</code> 命令替换为 <code>git cz</code> 即可</p>\n<p><img src=\"https://cimg1.17lai.site/data/2024/06/15/20240615121259-1.webp\" alt=\"Commitizen\"></p>\n<p>当你的控制台出现这样的界面，你可以使用方向键的 ↑ 和 ↓ 来移动光标选择这次 commit 的 type</p>\n<p>按回车 enter 进行选择</p>\n<p>常用的 type 有：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">英文</th>\n<th style=\"text-align:left\">含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">feat</td>\n<td style=\"text-align:left\">新特性，新功能</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">fix</td>\n<td style=\"text-align:left\">修bug</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">docs</td>\n<td style=\"text-align:left\">更新文档</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">style</td>\n<td style=\"text-align:left\">修改代码风格、代码格式（不影响代码运行的变动）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">refactor</td>\n<td style=\"text-align:left\">重构代码（既不是新增功能，也不是修改bug，可以理解为觉得原本写太烂了，重新写了一遍）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">perf</td>\n<td style=\"text-align:left\">优化性能、优化体验</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">test</td>\n<td style=\"text-align:left\">测试</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">chore</td>\n<td style=\"text-align:left\">构建过程或者辅助工具的变动</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">revert</td>\n<td style=\"text-align:left\">回滚版本</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">merge</td>\n<td style=\"text-align:left\">代码合并</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">sync</td>\n<td style=\"text-align:left\">同步主线或分支</td>\n</tr>\n</tbody>\n</table>\n<p>随后，根据提示输入相关信息即可</p>\n<p>例如</p>\n<ul>\n<li>scope 作用域，也就是这次变动影响的范围，例如数据层，控制层，或者单单某个类</li>\n<li>subject / description 描述，cz 将描述分为简短描述和详细描述，使用几下就清楚了</li>\n</ul>\n<p>除此以外，cz 还会提示你这次变动是否与某个 issue 有关等等</p>\n<h2 id=\"变更规范\">变更规范</h2>\n<p>上面是在初始化时选择的规范，如果在后期我们想要变更该怎么做？</p>\n<p>首先，脚手架只有在初始化才能帮我们自动管理依赖</p>\n<p>后期想要变动，就得手动下载依赖了</p>\n<p>例如初始化时用的是官方默认的规范</p>\n<p>那么这时候你的package.json里面会有这样一段代码</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\">\"config\": {\n    \"commitizen\": {\n        \"path\": \"node_modules/cz-conventional-changelog\"\n    }\n}</code></pre></div></figure>\n<p>我们如果想要换成有表情包的规范形式 <code>cz-emoji-conventional</code></p>\n<p>首先需要下载依赖，当然是要在项目根目录执行：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">npm i cz-emoji-conventional</code></pre></div></figure>\n<p>然后修改上面 package.json 中的配置</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\">\"config\": {\n    \"commitizen\": {\n        \"path\": \"node_modules/cz-emoji-conventional\"\n    }\n}</code></pre></div></figure>\n<p>到这里，规范就修改完成了</p>\n<h2 id=\"全局安装\">全局安装</h2>\n<p>上面所讲的安装方式仅适用于项目内，也就是每一个项目都会创建node_modules并安装依赖。</p>\n<p>如果需要在电脑上任意地方都能用 <code>git cz</code> 命令，需要进行全局安装：</p>\n<ol>\n<li>\n<p>脚手架 <code>npm install -g commitizen</code></p>\n</li>\n<li>\n<p>选择一个<strong>规范</strong>，参考上文：<code>npm install -g cz-emoji-conventional</code></p>\n</li>\n<li>\n<p>在用户目录下创建文件 <code>.czrc</code></p>\n<p>Windows：C:\\user\\用户名</p>\n<p>Linux: /home</p>\n</li>\n<li>\n<p>编辑 <code>.czrc</code> 文件，写入<strong>规范</strong>名称：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\">{\n    \"path\": \"cz-emoji-conventional\"\n}</code></pre></div></figure>\n</li>\n</ol>\n<h2 id=\"参考\"><strong>参考</strong></h2>\n<p><a href=\"http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000\">Git 教程</a></p>\n<p><a href=\"https://git-scm.com/book/zh/v2\">Git book</a></p>\n<h2 id=\"系列教程\"><strong>系列教程</strong></h2>\n<p><a href=\"/atom.xml\"><i class=\"fas fa-rss\"></i>全部文章RSS订阅</a></p>\n<h3 id=\"Devops系列\"><strong>Devops系列</strong></h3>\n<p><a href=\"/categories/devops/atom.xml\"><i class=\"fas fa-rss\"></i><strong>Devops 分类 RSS 订阅</strong></a></p>\n<ul>\n<li><a href=\"/posts/ab63eb8f/\">自建全套开源Devops开发系统</a></li>\n<li><a href=\"/posts/d32a07a7/\">Git介绍以及分支模型图解</a></li>\n<li><a href=\"/posts/39563241/\">三万字无坑搭建基于Docker+K8S+GitLab/SVN+Jenkins+Harbor持续集成交付环境</a></li>\n<li><a href=\"/posts/3437994a/\">DevOps系列—【Jenkinsfile+Dockerfile+nginx+vue】</a></li>\n<li><a href=\"/posts/f4c3ad41/\">项目开发管理工具推荐</a></li>\n<li><a href=\"/posts/acc13b70/\">Gitlab的安装及使用教程完全版</a></li>\n<li><a href=\"/posts/d08eb7b/\">Gitlab的安装及使用</a></li>\n<li><a href=\"/posts/78c3371/\">那些有用的Github工具介绍！Action、app、workflow等</a></li>\n</ul>\n",
            "tags": [
                "git",
                "devops",
                "drowio"
            ]
        },
        {
            "id": "https://blog.17lai.site/posts/39563241/",
            "url": "https://blog.17lai.site/posts/39563241/",
            "title": "三万字无坑搭建基于Docker+K8S+GitLab/SVN+Jenkins+Harbor持续集成交付环境",
            "date_published": "2022-04-16T10:49:57.000Z",
            "content_html": "<blockquote>\n<p>最近在 K8S 1.18.2 版本的集群上搭建DevOps环境，期间遇到了各种坑。目前，搭建环境的过程中出现的各种坑均已被填平，特此记录，并分享给大家！</p>\n<p>文章和搭建环境所需要的yml文件已收录到：<a href=\"https://github.com/sunshinelyz/technology-binghe\">https://github.com/sunshinelyz/technology-binghe</a> 和 <a href=\"https://gitee.com/binghe001/technology-binghe\">https://gitee.com/binghe001/technology-binghe</a> 。如果文件对你有点帮助，别忘记给个Star哦！</p>\n</blockquote>\n<h2 id=\"服务器规划\">服务器规划</h2>\n<table>\n<thead>\n<tr>\n<th>IP</th>\n<th>主机名</th>\n<th>节点</th>\n<th>操作系统</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>192.168.175.101</td>\n<td>binghe101</td>\n<td>K8S Master</td>\n<td>CentOS 8.0.1905</td>\n</tr>\n<tr>\n<td>192.168.175.102</td>\n<td>binghe102</td>\n<td>K8S Worker</td>\n<td>CentOS 8.0.1905</td>\n</tr>\n<tr>\n<td>192.168.175.103</td>\n<td>binghe103</td>\n<td>K8S Worker</td>\n<td>CentOS 8.0.1905</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"安装环境版本\">安装环境版本</h2>\n<table>\n<thead>\n<tr>\n<th>软件名称</th>\n<th>软件版本</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Docker</td>\n<td>19.03.8</td>\n<td>提供容器环境</td>\n</tr>\n<tr>\n<td>docker-compose</td>\n<td>1.25.5</td>\n<td>定义和运行由多个容器组成的应用</td>\n</tr>\n<tr>\n<td>K8S</td>\n<td>1.8.12</td>\n<td>是一个开源的，用于管理云平台中多个主机上的容器化的应用，Kubernetes的目标是让部署容器化的应用简单并且高效（powerful）,Kubernetes提供了应用部署，规划，更新，维护的一种机制。</td>\n</tr>\n<tr>\n<td>GitLab</td>\n<td>12.1.6</td>\n<td>代码仓库（与SVN安装一个即可）</td>\n</tr>\n<tr>\n<td>Harbor</td>\n<td>1.10.2</td>\n<td>私有镜像仓库</td>\n</tr>\n<tr>\n<td>Jenkins</td>\n<td>2.89.3</td>\n<td>持续集成交付</td>\n</tr>\n<tr>\n<td>SVN</td>\n<td>1.10.2</td>\n<td>代码仓库（与GitLab安装一个即可）</td>\n</tr>\n<tr>\n<td>JDK</td>\n<td>1.8.0_202</td>\n<td>Java运行基础环境</td>\n</tr>\n<tr>\n<td>maven</td>\n<td>3.6.3</td>\n<td>构建项目的基础插件</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"服务器免密码登录\">服务器免密码登录</h2>\n<p>在各服务器执行如下命令。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">ssh-keygen -t rsa\ncat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys \n</code></pre></div></figure>\n<p>将binghe102和binghe103服务器上的id_rsa.pub文件复制到binghe101服务器。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">[root@binghe102 ~]# scp .ssh/id_rsa.pub binghe101:/root/.ssh/102\n[root@binghe103 ~]# scp .ssh/id_rsa.pub binghe101:/root/.ssh/103\n</code></pre></div></figure>\n<p>在binghe101服务器上执行如下命令。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">cat ~/.ssh/102 &gt;&gt; ~/.ssh/authorized_keys\ncat ~/.ssh/103 &gt;&gt; ~/.ssh/authorized_keys\n</code></pre></div></figure>\n<p>然后将authorized_keys文件分别复制到binghe102、binghe103服务器。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">[root@binghe101 ~]# scp .ssh/authorized_keys binghe102:/root/.ssh/authorized_keys\n[root@binghe101 ~]# scp .ssh/authorized_keys binghe103:/root/.ssh/authorized_keys\n</code></pre></div></figure>\n<p>删除binghe101节点上~/.ssh下的102和103文件。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">rm ~/.ssh/102\nrm ~/.ssh/103\n</code></pre></div></figure>\n<h2 id=\"安装JDK\">安装JDK</h2>\n<p>需要在每台服务器上安装JDK环境。到Oracle官方下载JDK，我这里下的JDK版本为1.8.0_202，下载后解压并配置系统环境变量。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">tar -zxvf jdk1.8.0_212.tar.gz\nmv jdk1.8.0_212 /usr/local\n</code></pre></div></figure>\n<p>接下来，配置系统环境变量。</p>\n<p>配置项内容如下所示。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">JAVA_HOME=/usr/local/jdk1.8.0_212\nCLASS_PATH=.:$JAVA_HOME/lib\nPATH=$JAVA_HOME/bin:$PATH\nexport JAVA_HOME CLASS_PATH PATH\n</code></pre></div></figure>\n<p>接下来执行如下命令使系统环境变量生效。</p>\n<h2 id=\"安装Maven\">安装Maven</h2>\n<p>到Apache官方下载Maven，我这里下载的Maven版本为3.6.3。下载后直接解压并配置系统环境变量。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">tar -zxvf apache-maven-3.6.3-bin.tar.gz\nmv apache-maven-3.6.3-bin /usr/local\n</code></pre></div></figure>\n<p>接下来，就是配置系统环境变量。</p>\n<p>配置项内容如下所示。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">JAVA_HOME=/usr/local/jdk1.8.0_212\nMAVEN_HOME=/usr/local/apache-maven-3.6.3-bin\nCLASS_PATH=.:$JAVA_HOME/lib\nPATH=$MAVEN_HOME/bin:$JAVA_HOME/bin:$PATH\nexport JAVA_HOME CLASS_PATH MAVEN_HOME PATH\n</code></pre></div></figure>\n<p>接下来执行如下命令使系统环境变量生效。</p>\n<p>接下来，修改Maven的配置文件，如下所示。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">&lt;localRepository&gt;/home/repository&lt;/localRepository&gt;\n</code></pre></div></figure>\n<p>将Maven下载的Jar包存储到/home/repository目录下。</p>\n<h2 id=\"安装Docker环境\">安装Docker环境</h2>\n<p><strong>本文档基于Docker 19.03.8 版本搭建Docker环境。</strong></p>\n<p>在所有服务器上创建install_docker.sh脚本，脚本内容如下所示。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">export REGISTRY_MIRROR=https://registry.cn-hangzhou.aliyuncs.com\ndnf install yum*\nyum install -y yum-utils device-mapper-persistent-data lvm2\nyum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo\ndnf install https://mirrors.aliyun.com/docker-ce/linux/centos/7/x86_64/stable/Packages/containerd.io-1.2.13-3.1.el7.x86_64.rpm\nyum install -y docker-ce-19.03.8 docker-ce-cli-19.03.8\nsystemctl enable docker.service\nsystemctl start docker.service\ndocker version\n</code></pre></div></figure>\n<p>在每台服务器上为install_docker.sh脚本赋予可执行权限，并执行脚本即可。</p>\n<h2 id=\"安装docker-compose\">安装docker-compose</h2>\n<p><strong>注意：在每台服务器上安装docker-compose</strong></p>\n<p><strong>1.下载docker-compose文件</strong></p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">curl -L https://github.com/docker/compose/releases/download/1.25.5/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose \n</code></pre></div></figure>\n<h3 id=\"2-为docker-compose文件赋予可执行权限\">2.为docker-compose文件赋予可执行权限</h3>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">chmod a+x /usr/local/bin/docker-compose\n</code></pre></div></figure>\n<h3 id=\"3-查看docker-compose版本\">3.查看docker-compose版本</h3>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">[root@binghe ~]# docker-compose version\ndocker-compose version 1.25.5, build 8a1c60f6\ndocker-py version: 4.1.0\nCPython version: 3.7.5\nOpenSSL version: OpenSSL 1.1.0l  10 Sep 2019\n</code></pre></div></figure>\n<h2 id=\"安装K8S集群环境\">安装K8S集群环境</h2>\n<p><strong>本文档基于K8S 1.8.12版本来搭建K8S集群</strong></p>\n<h3 id=\"安装K8S基础环境\">安装K8S基础环境</h3>\n<p>在所有服务器上创建install_k8s.sh脚本文件，脚本文件的内容如下所示。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">#配置阿里云镜像加速器\nmkdir -p /etc/docker\ntee /etc/docker/daemon.json &lt;&lt;-'EOF'\n{\n  \"registry-mirrors\": [\"https://zz3sblpi.mirror.aliyuncs.com\"]\n}\nEOF\nsystemctl daemon-reload\nsystemctl restart docker\n\n#安装nfs-utils\nyum install -y nfs-utils\nyum install -y wget\n\n#启动nfs-server\nsystemctl start nfs-server\nsystemctl enable nfs-server\n\n#关闭防火墙\nsystemctl stop firewalld\nsystemctl disable firewalld\n\n#关闭SeLinux\nsetenforce 0\nsed -i \"s/SELINUX=enforcing/SELINUX=disabled/g\" /etc/selinux/config\n\n# 关闭 swap\nswapoff -a\nyes | cp /etc/fstab /etc/fstab_bak\ncat /etc/fstab_bak |grep -v swap &gt; /etc/fstab\n\n#修改 /etc/sysctl.conf\n# 如果有配置，则修改\nsed -i \"s#^net.ipv4.ip_forward.*#net.ipv4.ip_forward=1#g\"  /etc/sysctl.conf\nsed -i \"s#^net.bridge.bridge-nf-call-ip6tables.*#net.bridge.bridge-nf-call-ip6tables=1#g\"  /etc/sysctl.conf\nsed -i \"s#^net.bridge.bridge-nf-call-iptables.*#net.bridge.bridge-nf-call-iptables=1#g\"  /etc/sysctl.conf\nsed -i \"s#^net.ipv6.conf.all.disable_ipv6.*#net.ipv6.conf.all.disable_ipv6=1#g\"  /etc/sysctl.conf\nsed -i \"s#^net.ipv6.conf.default.disable_ipv6.*#net.ipv6.conf.default.disable_ipv6=1#g\"  /etc/sysctl.conf\nsed -i \"s#^net.ipv6.conf.lo.disable_ipv6.*#net.ipv6.conf.lo.disable_ipv6=1#g\"  /etc/sysctl.conf\nsed -i \"s#^net.ipv6.conf.all.forwarding.*#net.ipv6.conf.all.forwarding=1#g\"  /etc/sysctl.conf\n# 可能没有，追加\necho \"net.ipv4.ip_forward = 1\" &gt;&gt; /etc/sysctl.conf\necho \"net.bridge.bridge-nf-call-ip6tables = 1\" &gt;&gt; /etc/sysctl.conf\necho \"net.bridge.bridge-nf-call-iptables = 1\" &gt;&gt; /etc/sysctl.conf\necho \"net.ipv6.conf.all.disable_ipv6 = 1\" &gt;&gt; /etc/sysctl.conf\necho \"net.ipv6.conf.default.disable_ipv6 = 1\" &gt;&gt; /etc/sysctl.conf\necho \"net.ipv6.conf.lo.disable_ipv6 = 1\" &gt;&gt; /etc/sysctl.conf\necho \"net.ipv6.conf.all.forwarding = 1\"  &gt;&gt; /etc/sysctl.conf\n# 执行命令以应用\nsysctl -p\n\n# 配置K8S的yum源\ncat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo\n[kubernetes]\nname=Kubernetes\nbaseurl=http://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64\nenabled=1\ngpgcheck=0\nrepo_gpgcheck=0\ngpgkey=http://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg\n       http://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg\nEOF\n\n# 卸载旧版本K8S\nyum remove -y kubelet kubeadm kubectl\n\n# 安装kubelet、kubeadm、kubectl，这里我安装的是1.18.2版本，你也可以安装1.17.2版本\nyum install -y kubelet-1.18.2 kubeadm-1.18.2 kubectl-1.18.2\n\n# 修改docker Cgroup Driver为systemd\n# # 将/usr/lib/systemd/system/docker.service文件中的这一行 ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock\n# # 修改为 ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock --exec-opt native.cgroupdriver=systemd\n# 如果不修改，在添加 worker 节点时可能会碰到如下错误\n# [WARNING IsDockerSystemdCheck]: detected \"cgroupfs\" as the Docker cgroup driver. The recommended driver is \"systemd\". \n# Please follow the guide at https://kubernetes.io/docs/setup/cri/\nsed -i \"s#^ExecStart=/usr/bin/dockerd.*#ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock --exec-opt native.cgroupdriver=systemd#g\" /usr/lib/systemd/system/docker.service\n\n# 设置 docker 镜像，提高 docker 镜像下载速度和稳定性\n# 如果访问 https://hub.docker.io 速度非常稳定，亦可以跳过这个步骤\n# curl -sSL https://kuboard.cn/install-script/set_mirror.sh | sh -s ${REGISTRY_MIRROR}\n\n# 重启 docker，并启动 kubelet\nsystemctl daemon-reload\nsystemctl restart docker\nsystemctl enable kubelet &amp;&amp; systemctl start kubelet\n\ndocker version\n</code></pre></div></figure>\n<p>在每台服务器上为install_k8s.sh脚本赋予可执行权限，并执行脚本即可。</p>\n<h3 id=\"初始化Master节点\">初始化Master节点</h3>\n<p><strong>只在binghe101服务器上执行的操作。</strong></p>\n<p><strong>1.初始化Master节点的网络环境</strong></p>\n<p>注意：下面的命令需要在命令行手动执行。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"># 只在 master 节点执行\n# export 命令只在当前 shell 会话中有效，开启新的 shell 窗口后，如果要继续安装过程，请重新执行此处的 export 命令\nexport MASTER_IP=192.168.175.101\n# 替换 k8s.master 为 您想要的 dnsName\nexport APISERVER_NAME=k8s.master\n# Kubernetes 容器组所在的网段，该网段安装完成后，由 kubernetes 创建，事先并不存在于物理网络中\nexport POD_SUBNET=172.18.0.1/16\necho \"${MASTER_IP}    ${APISERVER_NAME}\" &gt;&gt; /etc/hosts\n</code></pre></div></figure>\n<p><strong>2.初始化Master节点</strong></p>\n<p>在binghe101服务器上创建init_master.sh脚本文件，文件内容如下所示。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">#!/bin/bash\n# 脚本出错时终止执行\nset -e\n\nif [ ${#POD_SUBNET} -eq 0 ] || [ ${#APISERVER_NAME} -eq 0 ]; then\n  echo -e \"\\033[31;1m请确保您已经设置了环境变量 POD_SUBNET 和 APISERVER_NAME \\033[0m\"\n  echo 当前POD_SUBNET=$POD_SUBNET\n  echo 当前APISERVER_NAME=$APISERVER_NAME\n  exit 1\nfi\n\n\n# 查看完整配置选项 https://godoc.org/k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm/v1beta2\nrm -f ./kubeadm-config.yaml\ncat &lt;&lt;EOF &gt; ./kubeadm-config.yaml\napiVersion: kubeadm.k8s.io/v1beta2\nkind: ClusterConfiguration\nkubernetesVersion: v1.18.2\nimageRepository: registry.cn-hangzhou.aliyuncs.com/google_containers\ncontrolPlaneEndpoint: \"${APISERVER_NAME}:6443\"\nnetworking:\n  serviceSubnet: \"10.96.0.0/16\"\n  podSubnet: \"${POD_SUBNET}\"\n  dnsDomain: \"cluster.local\"\nEOF\n\n# kubeadm init\n# 根据服务器网速的情况，您需要等候 3 - 10 分钟\nkubeadm init --config=kubeadm-config.yaml --upload-certs\n\n# 配置 kubectl\nrm -rf /root/.kube/\nmkdir /root/.kube/\ncp -i /etc/kubernetes/admin.conf /root/.kube/config\n\n# 安装 calico 网络插件\n# 参考文档 https://docs.projectcalico.org/v3.13/getting-started/kubernetes/self-managed-onprem/onpremises\necho \"安装calico-3.13.1\"\nrm -f calico-3.13.1.yaml\nwget https://kuboard.cn/install-script/calico/calico-3.13.1.yaml\nkubectl apply -f calico-3.13.1.yaml\n</code></pre></div></figure>\n<p>赋予init_master.sh脚本文件可执行权限并执行脚本。</p>\n<p><strong>3.查看Master节点的初始化结果</strong></p>\n<p><strong>（1）确保所有容器组处于Running状态</strong></p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"># 执行如下命令，等待 3-10 分钟，直到所有的容器组处于 Running 状态\nwatch kubectl get pod -n kube-system -o wide\n</code></pre></div></figure>\n<p>具体执行如下所示。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">[root@binghe101 ~]# watch kubectl get pod -n kube-system -o wide\nEvery 2.0s: kubectl get pod -n kube-system -o wide                                                                                                                          binghe101: Sun May 10 11:01:32 2020\n\nNAME                                       READY   STATUS    RESTARTS   AGE    IP                NODE        NOMINATED NODE   READINESS GATES          \ncalico-kube-controllers-5b8b769fcd-5dtlp   1/1     Running   0          118s   172.18.203.66     binghe101   &lt;none&gt;           &lt;none&gt;          \ncalico-node-fnv8g                          1/1     Running   0          118s   192.168.175.101   binghe101   &lt;none&gt;           &lt;none&gt;          \ncoredns-546565776c-27t7h                   1/1     Running   0          2m1s   172.18.203.67     binghe101   &lt;none&gt;           &lt;none&gt;          \ncoredns-546565776c-hjb8z                   1/1     Running   0          2m1s   172.18.203.65     binghe101   &lt;none&gt;           &lt;none&gt;          \netcd-binghe101                             1/1     Running   0          2m7s   192.168.175.101   binghe101   &lt;none&gt;           &lt;none&gt;          \nkube-apiserver-binghe101                   1/1     Running   0          2m7s   192.168.175.101   binghe101   &lt;none&gt;           &lt;none&gt;          \nkube-controller-manager-binghe101          1/1     Running   0          2m7s   192.168.175.101   binghe101   &lt;none&gt;           &lt;none&gt;          \nkube-proxy-dvgsr                           1/1     Running   0          2m1s   192.168.175.101   binghe101   &lt;none&gt;           &lt;none&gt;          \nkube-scheduler-binghe101                   1/1     Running   0          2m7s   192.168.175.101   binghe101   &lt;none&gt;           &lt;none&gt;\n</code></pre></div></figure>\n<p><strong>（2） 查看 Master 节点初始化结果</strong></p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">kubectl get nodes -o wide\n</code></pre></div></figure>\n<p>具体执行如下所示。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">[root@binghe101 ~]# kubectl get nodes -o wide\nNAME        STATUS   ROLES    AGE     VERSION   INTERNAL-IP       EXTERNAL-IP   OS-IMAGE                KERNEL-VERSION         CONTAINER-RUNTIME\nbinghe101   Ready    master   3m28s   v1.18.2   192.168.175.101   &lt;none&gt;        CentOS Linux 8 (Core)   4.18.0-80.el8.x86_64   docker://19.3.8\n</code></pre></div></figure>\n<h3 id=\"初始化Worker节点\">初始化Worker节点</h3>\n<p><strong>1.获取join命令参数</strong></p>\n<p>在Master节点（binghe101服务器）上执行如下命令获取join命令参数。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">kubeadm token create --print-join-command\n</code></pre></div></figure>\n<p>具体执行如下所示。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">[root@binghe101 ~]# kubeadm token create --print-join-command\nW0510 11:04:34.828126   56132 configset.go:202] WARNING: kubeadm cannot validate component configs for API groups [kubelet.config.k8s.io kubeproxy.config.k8s.io]\nkubeadm join k8s.master:6443 --token 8nblts.62xytoqufwsqzko2     --discovery-token-ca-cert-hash sha256:1717cc3e34f6a56b642b5751796530e367aa73f4113d09994ac3455e33047c0d \n</code></pre></div></figure>\n<p>其中，有如下一行输出。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">kubeadm join k8s.master:6443 --token 8nblts.62xytoqufwsqzko2     --discovery-token-ca-cert-hash sha256:1717cc3e34f6a56b642b5751796530e367aa73f4113d09994ac3455e33047c0d \n</code></pre></div></figure>\n<p>这行代码就是获取到的join命令。</p>\n<blockquote>\n<p>注意：join命令中的token的有效时间为 2 个小时，2小时内，可以使用此 token 初始化任意数量的 worker 节点。</p>\n</blockquote>\n<p><strong>2.初始化Worker节点</strong></p>\n<p>针对所有的 worker 节点执行，在这里，就是在binghe102服务器和binghe103服务器上执行。</p>\n<p>在命令分别手动执行如下命令。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"># 只在 worker 节点执行\n# 192.168.175.101 为 master 节点的内网 IP\nexport MASTER_IP=192.168.175.101\n# 替换 k8s.master 为初始化 master 节点时所使用的 APISERVER_NAME\nexport APISERVER_NAME=k8s.master\necho \"${MASTER_IP}    ${APISERVER_NAME}\" &gt;&gt; /etc/hosts\n\n# 替换为 master 节点上 kubeadm token create 命令输出的join\nkubeadm join k8s.master:6443 --token 8nblts.62xytoqufwsqzko2     --discovery-token-ca-cert-hash sha256:1717cc3e34f6a56b642b5751796530e367aa73f4113d09994ac3455e33047c0d \n</code></pre></div></figure>\n<p>具体执行如下所示。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">[root@binghe102 ~]# export MASTER_IP=192.168.175.101\n[root@binghe102 ~]# export APISERVER_NAME=k8s.master\n[root@binghe102 ~]# echo \"${MASTER_IP}    ${APISERVER_NAME}\" &gt;&gt; /etc/hosts\n[root@binghe102 ~]# kubeadm join k8s.master:6443 --token 8nblts.62xytoqufwsqzko2     --discovery-token-ca-cert-hash sha256:1717cc3e34f6a56b642b5751796530e367aa73f4113d09994ac3455e33047c0d \nW0510 11:08:27.709263   42795 join.go:346] [preflight] WARNING: JoinControlPane.controlPlane settings will be ignored when control-plane flag is not set.\n[preflight] Running pre-flight checks\n        [WARNING FileExisting-tc]: tc not found in system path\n[preflight] Reading configuration from the cluster...\n[preflight] FYI: You can look at this config file with 'kubectl -n kube-system get cm kubeadm-config -oyaml'\n[kubelet-start] Downloading configuration for the kubelet from the \"kubelet-config-1.18\" ConfigMap in the kube-system namespace\n[kubelet-start] Writing kubelet configuration to file \"/var/lib/kubelet/config.yaml\"\n[kubelet-start] Writing kubelet environment file with flags to file \"/var/lib/kubelet/kubeadm-flags.env\"\n[kubelet-start] Starting the kubelet\n[kubelet-start] Waiting for the kubelet to perform the TLS Bootstrap...\n\nThis node has joined the cluster:\n* Certificate signing request was sent to apiserver and a response was received.\n* The Kubelet was informed of the new secure connection details.\n\nRun 'kubectl get nodes' on the control-plane to see this node join the cluster.\n</code></pre></div></figure>\n<p>根据输出结果可以看出，Worker节点加入了K8S集群。</p>\n<blockquote>\n<p>注意：kubeadm join…就是master 节点上 kubeadm token create 命令输出的join。</p>\n</blockquote>\n<p><strong>3.查看初始化结果</strong></p>\n<p>在Master节点（binghe101服务器）执行如下命令查看初始化结果。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">kubectl get nodes -o wide\n</code></pre></div></figure>\n<p>具体执行如下所示。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">[root@binghe101 ~]# kubectl get nodes\nNAME        STATUS   ROLES    AGE     VERSION\nbinghe101   Ready    master   20m     v1.18.2\nbinghe102   Ready    &lt;none&gt;   2m46s   v1.18.2\nbinghe103   Ready    &lt;none&gt;   2m46s   v1.18.2\n</code></pre></div></figure>\n<blockquote>\n<p>注意：kubectl get nodes命令后面加上-o wide参数可以输出更多的信息。</p>\n</blockquote>\n<h2 id=\"重启K8S集群引起的问题\">重启K8S集群引起的问题</h2>\n<h3 id=\"1-Worker节点故障不能启动\">1.Worker节点故障不能启动</h3>\n<p>Master 节点的 IP 地址发生变化，导致 worker 节点不能启动。需要重新安装K8S集群，并确保所有节点都有固定的内网 IP 地址。</p>\n<h3 id=\"2-Pod崩溃或不能正常访问\">2.Pod崩溃或不能正常访问</h3>\n<p>重启服务器后使用如下命令查看Pod的运行状态。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">kubectl get pods --all-namespaces\n</code></pre></div></figure>\n<p>发现很多 Pod 不在 Running 状态，此时，需要使用如下命令删除运行不正常的Pod。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">kubectl delete pod &lt;pod-name&gt; -n &lt;pod-namespece&gt;\n</code></pre></div></figure>\n<blockquote>\n<p>注意：如果Pod 是使用 Deployment、StatefulSet 等控制器创建的，K8S 将创建新的 Pod 作为替代，重新启动的 Pod 通常能够正常工作。</p>\n</blockquote>\n<h2 id=\"K8S安装ingress-nginx\">K8S安装ingress-nginx</h2>\n<p><strong>注意：在Master节点（binghe101服务器上执行）</strong></p>\n<h3 id=\"1-创建ingress-nginx命名空间\">1.创建ingress-nginx命名空间</h3>\n<p>创建ingress-nginx-namespace.yaml文件，文件内容如下所示。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">apiVersion: v1\nkind: Namespace\nmetadata:\n  name: ingress-nginx\n  labels:\n    name: ingress-nginx\n</code></pre></div></figure>\n<p>执行如下命令创建ingress-nginx命名空间。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">kubectl apply -f ingress-nginx-namespace.yaml\n</code></pre></div></figure>\n<h3 id=\"2-安装ingress-controller\">2.安装ingress controller</h3>\n<p>创建ingress-nginx-mandatory.yaml文件，文件内容如下所示。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">apiVersion: v1\nkind: Namespace\nmetadata:\n  name: ingress-nginx\n\n---\n\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: default-http-backend\n  labels:\n    app.kubernetes.io/name: default-http-backend\n    app.kubernetes.io/part-of: ingress-nginx\n  namespace: ingress-nginx\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app.kubernetes.io/name: default-http-backend\n      app.kubernetes.io/part-of: ingress-nginx\n  template:\n    metadata:\n      labels:\n        app.kubernetes.io/name: default-http-backend\n        app.kubernetes.io/part-of: ingress-nginx\n    spec:\n      terminationGracePeriodSeconds: 60\n      containers:\n        - name: default-http-backend\n          \n          \n          \n          image: registry.cn-qingdao.aliyuncs.com/kubernetes_xingej/defaultbackend-amd64:1.5\n          livenessProbe:\n            httpGet:\n              path: /healthz\n              port: 8080\n              scheme: HTTP\n            initialDelaySeconds: 30\n            timeoutSeconds: 5\n          ports:\n            - containerPort: 8080\n          resources:\n            limits:\n              cpu: 10m\n              memory: 20Mi\n            requests:\n              cpu: 10m\n              memory: 20Mi\n\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: default-http-backend\n  namespace: ingress-nginx\n  labels:\n    app.kubernetes.io/name: default-http-backend\n    app.kubernetes.io/part-of: ingress-nginx\nspec:\n  ports:\n    - port: 80\n      targetPort: 8080\n  selector:\n    app.kubernetes.io/name: default-http-backend\n    app.kubernetes.io/part-of: ingress-nginx\n\n---\n\nkind: ConfigMap\napiVersion: v1\nmetadata:\n  name: nginx-configuration\n  namespace: ingress-nginx\n  labels:\n    app.kubernetes.io/name: ingress-nginx\n    app.kubernetes.io/part-of: ingress-nginx\n\n---\n\nkind: ConfigMap\napiVersion: v1\nmetadata:\n  name: tcp-services\n  namespace: ingress-nginx\n  labels:\n    app.kubernetes.io/name: ingress-nginx\n    app.kubernetes.io/part-of: ingress-nginx\n\n---\n\nkind: ConfigMap\napiVersion: v1\nmetadata:\n  name: udp-services\n  namespace: ingress-nginx\n  labels:\n    app.kubernetes.io/name: ingress-nginx\n    app.kubernetes.io/part-of: ingress-nginx\n\n---\n\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: nginx-ingress-serviceaccount\n  namespace: ingress-nginx\n  labels:\n    app.kubernetes.io/name: ingress-nginx\n    app.kubernetes.io/part-of: ingress-nginx\n\n---\napiVersion: rbac.authorization.k8s.io/v1beta1\nkind: ClusterRole\nmetadata:\n  name: nginx-ingress-clusterrole\n  labels:\n    app.kubernetes.io/name: ingress-nginx\n    app.kubernetes.io/part-of: ingress-nginx\nrules:\n  - apiGroups:\n      - \"\"\n    resources:\n      - configmaps\n      - endpoints\n      - nodes\n      - pods\n      - secrets\n    verbs:\n      - list\n      - watch\n  - apiGroups:\n      - \"\"\n    resources:\n      - nodes\n    verbs:\n      - get\n  - apiGroups:\n      - \"\"\n    resources:\n      - services\n    verbs:\n      - get\n      - list\n      - watch\n  - apiGroups:\n      - \"extensions\"\n    resources:\n      - ingresses\n    verbs:\n      - get\n      - list\n      - watch\n  - apiGroups:\n      - \"\"\n    resources:\n      - events\n    verbs:\n      - create\n      - patch\n  - apiGroups:\n      - \"extensions\"\n    resources:\n      - ingresses/status\n    verbs:\n      - update\n\n---\napiVersion: rbac.authorization.k8s.io/v1beta1\nkind: Role\nmetadata:\n  name: nginx-ingress-role\n  namespace: ingress-nginx\n  labels:\n    app.kubernetes.io/name: ingress-nginx\n    app.kubernetes.io/part-of: ingress-nginx\nrules:\n  - apiGroups:\n      - \"\"\n    resources:\n      - configmaps\n      - pods\n      - secrets\n      - namespaces\n    verbs:\n      - get\n  - apiGroups:\n      - \"\"\n    resources:\n      - configmaps\n    resourceNames:\n      \n      \n      \n      \n      - \"ingress-controller-leader-nginx\"\n    verbs:\n      - get\n      - update\n  - apiGroups:\n      - \"\"\n    resources:\n      - configmaps\n    verbs:\n      - create\n  - apiGroups:\n      - \"\"\n    resources:\n      - endpoints\n    verbs:\n      - get\n\n---\napiVersion: rbac.authorization.k8s.io/v1beta1\nkind: RoleBinding\nmetadata:\n  name: nginx-ingress-role-nisa-binding\n  namespace: ingress-nginx\n  labels:\n    app.kubernetes.io/name: ingress-nginx\n    app.kubernetes.io/part-of: ingress-nginx\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: Role\n  name: nginx-ingress-role\nsubjects:\n  - kind: ServiceAccount\n    name: nginx-ingress-serviceaccount\n    namespace: ingress-nginx\n\n---\napiVersion: rbac.authorization.k8s.io/v1beta1\nkind: ClusterRoleBinding\nmetadata:\n  name: nginx-ingress-clusterrole-nisa-binding\n  labels:\n    app.kubernetes.io/name: ingress-nginx\n    app.kubernetes.io/part-of: ingress-nginx\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name: nginx-ingress-clusterrole\nsubjects:\n  - kind: ServiceAccount\n    name: nginx-ingress-serviceaccount\n    namespace: ingress-nginx\n\n---\n\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-ingress-controller\n  namespace: ingress-nginx\n  labels:\n    app.kubernetes.io/name: ingress-nginx\n    app.kubernetes.io/part-of: ingress-nginx\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app.kubernetes.io/name: ingress-nginx\n      app.kubernetes.io/part-of: ingress-nginx\n  template:\n    metadata:\n      labels:\n        app.kubernetes.io/name: ingress-nginx\n        app.kubernetes.io/part-of: ingress-nginx\n      annotations:\n        prometheus.io/port: \"10254\"\n        prometheus.io/scrape: \"true\"\n    spec:\n      serviceAccountName: nginx-ingress-serviceaccount\n      containers:\n        - name: nginx-ingress-controller\n          image: registry.cn-qingdao.aliyuncs.com/kubernetes_xingej/nginx-ingress-controller:0.20.0\n          args:\n            - /nginx-ingress-controller\n            - --default-backend-service=$(POD_NAMESPACE)/default-http-backend\n            - --configmap=$(POD_NAMESPACE)/nginx-configuration\n            - --tcp-services-configmap=$(POD_NAMESPACE)/tcp-services\n            - --udp-services-configmap=$(POD_NAMESPACE)/udp-services\n            - --publish-service=$(POD_NAMESPACE)/ingress-nginx\n            - --annotations-prefix=nginx.ingress.kubernetes.io\n          securityContext:\n            capabilities:\n              drop:\n                - ALL\n              add:\n                - NET_BIND_SERVICE\n            \n            runAsUser: 33\n          env:\n            - name: POD_NAME\n              valueFrom:\n                fieldRef:\n                  fieldPath: metadata.name\n            - name: POD_NAMESPACE\n              valueFrom:\n                fieldRef:\n                  fieldPath: metadata.namespace\n          ports:\n            - name: http\n              containerPort: 80\n            - name: https\n              containerPort: 443\n          livenessProbe:\n            failureThreshold: 3\n            httpGet:\n              path: /healthz\n              port: 10254\n              scheme: HTTP\n            initialDelaySeconds: 10\n            periodSeconds: 10\n            successThreshold: 1\n            timeoutSeconds: 1\n          readinessProbe:\n            failureThreshold: 3\n            httpGet:\n              path: /healthz\n              port: 10254\n              scheme: HTTP\n            periodSeconds: 10\n            successThreshold: 1\n            timeoutSeconds: 1\n\n---\n</code></pre></div></figure>\n<p>执行如下命令安装ingress controller。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">kubectl apply -f ingress-nginx-mandatory.yaml\n</code></pre></div></figure>\n<h3 id=\"3-安装K8S-SVC：ingress-nginx\">3.安装K8S SVC：ingress-nginx</h3>\n<p>主要是用来用于暴露pod：nginx-ingress-controller。</p>\n<p>创建service-nodeport.yaml文件，文件内容如下所示。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">apiVersion: v1\nkind: Service\nmetadata:\n  name: ingress-nginx\n  namespace: ingress-nginx\n  labels:\n    app.kubernetes.io/name: ingress-nginx\n    app.kubernetes.io/part-of: ingress-nginx\nspec:\n  type: NodePort\n  ports:\n    - name: http\n      port: 80\n      targetPort: 80\n      protocol: TCP\n      nodePort: 30080\n    - name: https\n      port: 443\n      targetPort: 443\n      protocol: TCP\n      nodePort: 30443\n  selector:\n    app.kubernetes.io/name: ingress-nginx\n    app.kubernetes.io/part-of: ingress-nginx\n</code></pre></div></figure>\n<p>执行如下命令安装。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">kubectl apply -f service-nodeport.yaml\n</code></pre></div></figure>\n<h3 id=\"4-访问K8S-SVC：ingress-nginx\">4.访问K8S SVC：ingress-nginx</h3>\n<p>查看ingress-nginx命名空间的部署情况，如下所示。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">[root@binghe101 k8s]# kubectl get pod -n ingress-nginx\nNAME                                        READY   STATUS    RESTARTS   AGE\ndefault-http-backend-796ddcd9b-vfmgn        1/1     Running   1          10h\nnginx-ingress-controller-58985cc996-87754   1/1     Running   2          10h\n</code></pre></div></figure>\n<p>在命令行服务器命令行输入如下命令查看ingress-nginx的端口映射情况。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">kubectl get svc -n ingress-nginx \n</code></pre></div></figure>\n<p>具体如下所示。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">[root@binghe101 k8s]# kubectl get svc -n ingress-nginx \nNAME                   TYPE        CLUSTER-IP    EXTERNAL-IP   PORT(S)                      AGE\ndefault-http-backend   ClusterIP   10.96.247.2   &lt;none&gt;        80/TCP                       7m3s\ningress-nginx          NodePort    10.96.40.6    &lt;none&gt;        80:30080/TCP,443:30443/TCP   4m35s\n</code></pre></div></figure>\n<p>所以，可以通过Master节点（binghe101服务器）的IP地址和30080端口号来访问ingress-nginx，如下所示。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">[root@binghe101 k8s]# curl 192.168.175.101:30080       \ndefault backend - 404\n</code></pre></div></figure>\n<p>也可以在浏览器打开<a href=\"http://192.168.175.101:30080\">http://192.168.175.101:30080</a> 来访问ingress-nginx，如下所示。</p>\n<p><img src=\"https://cimg1.17lai.site/data/2022/04/1620220416011231.jpg\" alt=\"\"></p>\n<h2 id=\"K8S安装gitlab代码仓库\">K8S安装gitlab代码仓库</h2>\n<p><strong>注意：在Master节点（binghe101服务器上执行）</strong></p>\n<h3 id=\"1-创建k8s-ops命名空间\">1.创建k8s-ops命名空间</h3>\n<p>创建k8s-ops-namespace.yaml文件，文件内容如下所示。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">apiVersion: v1\nkind: Namespace\nmetadata:\n  name: k8s-ops\n  labels:\n    name: k8s-ops\n</code></pre></div></figure>\n<p>执行如下命令创建命名空间。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">kubectl apply -f k8s-ops-namespace.yaml \n</code></pre></div></figure>\n<h3 id=\"2-安装gitlab-redis\">2.安装gitlab-redis</h3>\n<p>创建gitlab-redis.yaml文件，文件的内容如下所示。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: redis\n  namespace: k8s-ops\n  labels:\n    name: redis\nspec:\n  selector:\n    matchLabels:\n      name: redis\n  template:\n    metadata:\n      name: redis\n      labels:\n        name: redis\n    spec:\n      containers:\n      - name: redis\n        image: sameersbn/redis\n        imagePullPolicy: IfNotPresent\n        ports:\n        - name: redis\n          containerPort: 6379\n        volumeMounts:\n        - mountPath: /var/lib/redis\n          name: data\n        livenessProbe:\n          exec:\n            command:\n            - redis-cli\n            - ping\n          initialDelaySeconds: 30\n          timeoutSeconds: 5\n        readinessProbe:\n          exec:\n            command:\n            - redis-cli\n            - ping\n          initialDelaySeconds: 10\n          timeoutSeconds: 5\n      volumes:\n      - name: data\n        hostPath:\n          path: /data1/docker/xinsrv/redis\n\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: redis\n  namespace: k8s-ops\n  labels:\n    name: redis\nspec:\n  ports:\n    - name: redis\n      port: 6379\n      targetPort: redis\n  selector:\n    name: redis\n</code></pre></div></figure>\n<p>首先，在命令行执行如下命令创建/data1/docker/xinsrv/redis目录。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">mkdir -p /data1/docker/xinsrv/redis\n</code></pre></div></figure>\n<p>执行如下命令安装gitlab-redis。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">kubectl apply -f gitlab-redis.yaml \n</code></pre></div></figure>\n<h3 id=\"3-安装gitlab-postgresql\">3.安装gitlab-postgresql</h3>\n<p>创建gitlab-postgresql.yaml，文件内容如下所示。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: postgresql\n  namespace: k8s-ops\n  labels:\n    name: postgresql\nspec:\n  selector:\n    matchLabels:\n      name: postgresql\n  template:\n    metadata:\n      name: postgresql\n      labels:\n        name: postgresql\n    spec:\n      containers:\n      - name: postgresql\n        image: sameersbn/postgresql\n        imagePullPolicy: IfNotPresent\n        env:\n        - name: DB_USER\n          value: gitlab\n        - name: DB_PASS\n          value: passw0rd\n        - name: DB_NAME\n          value: gitlab_production\n        - name: DB_EXTENSION\n          value: pg_trgm\n        ports:\n        - name: postgres\n          containerPort: 5432\n        volumeMounts:\n        - mountPath: /var/lib/postgresql\n          name: data\n        livenessProbe:\n          exec:\n            command:\n            - pg_isready\n            - -h\n            - localhost\n            - -U\n            - postgres\n          initialDelaySeconds: 30\n          timeoutSeconds: 5\n        readinessProbe:\n          exec:\n            command:\n            - pg_isready\n            - -h\n            - localhost\n            - -U\n            - postgres\n          initialDelaySeconds: 5\n          timeoutSeconds: 1\n      volumes:\n      - name: data\n        hostPath:\n          path: /data1/docker/xinsrv/postgresql\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: postgresql\n  namespace: k8s-ops\n  labels:\n    name: postgresql\nspec:\n  ports:\n    - name: postgres\n      port: 5432\n      targetPort: postgres\n  selector:\n    name: postgresql\n</code></pre></div></figure>\n<p>首先，执行如下命令创建/data1/docker/xinsrv/postgresql目录。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">mkdir -p /data1/docker/xinsrv/postgresql\n</code></pre></div></figure>\n<p>接下来，安装gitlab-postgresql，如下所示。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">kubectl apply -f gitlab-postgresql.yaml\n</code></pre></div></figure>\n<h3 id=\"4-安装gitlab\">4.安装gitlab</h3>\n<p><strong>（1）配置用户名和密码</strong></p>\n<p>首先，在命令行使用base64编码为用户名和密码进行转码，本示例中，使用的用户名为admin，密码为admin.1231</p>\n<p>转码情况如下所示。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">[root@binghe101 k8s]# echo -n 'admin' | base64 \nYWRtaW4=\n[root@binghe101 k8s]# echo -n 'admin.1231' | base64 \nYWRtaW4uMTIzMQ==\n</code></pre></div></figure>\n<p>转码后的用户名为：YWRtaW4= 密码为：YWRtaW4uMTIzMQ==</p>\n<p>也可以对base64编码后的字符串解码，例如，对密码字符串解码，如下所示。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">[root@binghe101 k8s]# echo 'YWRtaW4uMTIzMQ==' | base64 --decode \nadmin.1231\n</code></pre></div></figure>\n<p>接下来，创建secret-gitlab.yaml文件，主要是用户来配置GitLab的用户名和密码，文件内容如下所示。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">apiVersion: v1\nkind: Secret\nmetadata:\n  namespace: k8s-ops\n  name: git-user-pass\ntype: Opaque\ndata:\n  username: YWRtaW4=\n  password: YWRtaW4uMTIzMQ==\n</code></pre></div></figure>\n<p>执行配置文件的内容，如下所示。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">kubectl create -f ./secret-gitlab.yaml\n</code></pre></div></figure>\n<p><strong>（2）安装GitLab</strong></p>\n<p>创建gitlab.yaml文件，文件的内容如下所示。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: gitlab\n  namespace: k8s-ops\n  labels:\n    name: gitlab\nspec:\n  selector:\n    matchLabels:\n      name: gitlab\n  template:\n    metadata:\n      name: gitlab\n      labels:\n        name: gitlab\n    spec:\n      containers:\n      - name: gitlab\n        image: sameersbn/gitlab:12.1.6\n        imagePullPolicy: IfNotPresent\n        env:\n        - name: TZ\n          value: Asia/Shanghai\n        - name: GITLAB_TIMEZONE\n          value: Beijing\n        - name: GITLAB_SECRETS_DB_KEY_BASE\n          value: long-and-random-alpha-numeric-string\n        - name: GITLAB_SECRETS_SECRET_KEY_BASE\n          value: long-and-random-alpha-numeric-string\n        - name: GITLAB_SECRETS_OTP_KEY_BASE\n          value: long-and-random-alpha-numeric-string\n        - name: GITLAB_ROOT_PASSWORD\n          valueFrom:\n            secretKeyRef:\n              name: git-user-pass\n              key: password\n        - name: GITLAB_ROOT_EMAIL\n          value: 12345678@qq.com\n        - name: GITLAB_HOST\n          value: gitlab.binghe.com\n        - name: GITLAB_PORT\n          value: \"80\"\n        - name: GITLAB_SSH_PORT\n          value: \"30022\"\n        - name: GITLAB_NOTIFY_ON_BROKEN_BUILDS\n          value: \"true\"\n        - name: GITLAB_NOTIFY_PUSHER\n          value: \"false\"\n        - name: GITLAB_BACKUP_SCHEDULE\n          value: daily\n        - name: GITLAB_BACKUP_TIME\n          value: 01:00\n        - name: DB_TYPE\n          value: postgres\n        - name: DB_HOST\n          value: postgresql\n        - name: DB_PORT\n          value: \"5432\"\n        - name: DB_USER\n          value: gitlab\n        - name: DB_PASS\n          value: passw0rd\n        - name: DB_NAME\n          value: gitlab_production\n        - name: REDIS_HOST\n          value: redis\n        - name: REDIS_PORT\n          value: \"6379\"\n        ports:\n        - name: http\n          containerPort: 80\n        - name: ssh\n          containerPort: 22\n        volumeMounts:\n        - mountPath: /home/git/data\n          name: data\n        livenessProbe:\n          httpGet:\n            path: /\n            port: 80\n          initialDelaySeconds: 180\n          timeoutSeconds: 5\n        readinessProbe:\n          httpGet:\n            path: /\n            port: 80\n          initialDelaySeconds: 5\n          timeoutSeconds: 1\n      volumes:\n      - name: data\n        hostPath:\n          path: /data1/docker/xinsrv/gitlab\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: gitlab\n  namespace: k8s-ops\n  labels:\n    name: gitlab\nspec:\n  ports:\n    - name: http\n      port: 80\n      nodePort: 30088\n    - name: ssh\n      port: 22\n      targetPort: ssh\n      nodePort: 30022\n  type: NodePort\n  selector:\n    name: gitlab\n\n---\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  name: gitlab\n  namespace: k8s-ops\n  annotations:\n    kubernetes.io/ingress.class: traefik\nspec:\n  rules:\n  - host: gitlab.binghe.com\n    http:\n      paths:\n      - backend:\n          serviceName: gitlab\n          servicePort: http\n</code></pre></div></figure>\n<p><strong>注意：在配置GitLab时，监听主机时，不能使用IP地址，需要使用主机名或者域名，上述配置中，我使用的是gitlab.binghe.com主机名。</strong></p>\n<p>在命令行执行如下命令创建/data1/docker/xinsrv/gitlab目录。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">mkdir -p /data1/docker/xinsrv/gitlab\n</code></pre></div></figure>\n<p>安装GitLab，如下所示。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">kubectl apply -f gitlab.yaml\n</code></pre></div></figure>\n<h3 id=\"5-安装完成\">5.安装完成</h3>\n<p>查看k8s-ops命名空间部署情况，如下所示。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">[root@binghe101 k8s]# kubectl get pod -n k8s-ops\nNAME                          READY   STATUS    RESTARTS   AGE\ngitlab-7b459db47c-5vk6t       0/1     Running   0          11s\npostgresql-79567459d7-x52vx   1/1     Running   0          30m\nredis-67f4cdc96c-h5ckz        1/1     Running   1          10h\n</code></pre></div></figure>\n<p>也可以使用如下命令查看。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">[root@binghe101 k8s]# kubectl get pod --namespace=k8s-ops\nNAME                          READY   STATUS    RESTARTS   AGE\ngitlab-7b459db47c-5vk6t       0/1     Running   0          36s\npostgresql-79567459d7-x52vx   1/1     Running   0          30m\nredis-67f4cdc96c-h5ckz        1/1     Running   1          10h\n</code></pre></div></figure>\n<p>二者效果一样。</p>\n<p>接下来，查看GitLab的端口映射，如下所示。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">[root@binghe101 k8s]# kubectl get svc -n k8s-ops\nNAME         TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)                     AGE\ngitlab       NodePort    10.96.153.100   &lt;none&gt;        80:30088/TCP,22:30022/TCP   2m42s\npostgresql   ClusterIP   10.96.203.119   &lt;none&gt;        5432/TCP                    32m\nredis        ClusterIP   10.96.107.150   &lt;none&gt;        6379/TCP                    10h\n</code></pre></div></figure>\n<p>此时，可以看到，可以通过Master节点（binghe101）的主机名gitlab.binghe.com和端口30088就能够访问GitLab。由于我这里使用的是虚拟机来搭建相关的环境，在本机访问虚拟机映射的gitlab.binghe.com时，需要配置本机的hosts文件，在本机的hosts文件中加入如下配置项。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-ini\" data-language=\"ini\"><code class=\"language-ini\">192.168.175.101 gitlab.binghe.com\n</code></pre></div></figure>\n<p>注意：在Windows操作系统中，hosts文件所在的目录如下。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-ini\" data-language=\"ini\"><code class=\"language-ini\">C:\\Windows\\System32\\drivers\\etc\n</code></pre></div></figure>\n<p>接下来，就可以在浏览器中通过链接：<a href=\"https://gitlab.binghe.com/30088\">http://gitlab.binghe.com:30088</a> 来访问GitLab了，如下所示。</p>\n<p><img src=\"https://cimg1.17lai.site/data/2022/04/1620220416011231-1.jpg\" alt=\"\"></p>\n<p>此时，可以通过用户名root和密码admin.1231来登录GitLab了。</p>\n<p><strong>注意：这里的用户名是root而不是admin，因为root是GitLab默认的超级用户。</strong></p>\n<p><img src=\"https://cimg1.17lai.site/data/2022/04/1620220416011231-2.jpg\" alt=\"\"></p>\n<p>登录后的界面如下所示。</p>\n<p><img src=\"https://cimg1.17lai.site/data/2022/04/1620220416011231-3.jpg\" alt=\"\"></p>\n<p>到此，K8S安装gitlab完成。</p>\n<h2 id=\"安装Harbor私有仓库\">安装Harbor私有仓库</h2>\n<p><strong>注意：这里将Harbor私有仓库安装在Master节点（binghe101服务器）上，实际生产环境中建议安装在其他服务器。</strong></p>\n<h3 id=\"1-下载Harbor的离线安装版本\">1.下载Harbor的离线安装版本</h3>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">wget https://github.com/goharbor/harbor/releases/download/v1.10.2/harbor-offline-installer-v1.10.2.tgz\n</code></pre></div></figure>\n<h3 id=\"2-解压Harbor的安装包\">2.解压Harbor的安装包</h3>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">tar -zxvf harbor-offline-installer-v1.10.2.tgz\n</code></pre></div></figure>\n<p>解压成功后，会在服务器当前目录生成一个harbor目录。</p>\n<h3 id=\"3-配置Harbor\">3.配置Harbor</h3>\n<p><strong>注意：这里，我将Harbor的端口修改成了1180，如果不修改Harbor的端口，默认的端口是80。</strong></p>\n<p><strong>（1）修改harbor.yml文件</strong></p>\n<p>修改的配置项如下所示。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">hostname: 192.168.175.101\nhttp:\n  port: 1180\nharbor_admin_password: binghe123\n###并把https注释掉，不然在安装的时候会报错：ERROR:root:Error: The protocol is https but attribute ssl_cert is not set\n#https:\n  #port: 443\n  #certificate: /your/certificate/path\n  #private_key: /your/private/key/path\n</code></pre></div></figure>\n<p><strong>（2）修改daemon.json文件</strong></p>\n<p>修改/etc/docker/daemon.json文件，没有的话就创建，在/etc/docker/daemon.json文件中添加如下内容。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\">[root@binghe~]# cat /etc/docker/daemon.json\n{\n  \"registry-mirrors\": [\"https://zz3sblpi.mirror.aliyuncs.com\"],\n  \"insecure-registries\":[\"192.168.175.101:1180\"]\n}\n</code></pre></div></figure>\n<p>也可以在服务器上使用 <strong>ip addr</strong> 命令查看本机所有的IP地址段，将其配置到/etc/docker/daemon.json文件中。这里，我配置后的文件内容如下所示。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\">{\n    \"registry-mirrors\": [\"https://zz3sblpi.mirror.aliyuncs.com\"],\n    \"insecure-registries\":[\"192.168.175.0/16\",\"172.17.0.0/16\", \"172.18.0.0/16\", \"172.16.29.0/16\", \"192.168.175.101:1180\"]\n}\n</code></pre></div></figure>\n<h3 id=\"4-安装并启动harbor\">4.安装并启动harbor</h3>\n<p>配置完成后，输入如下命令即可安装并启动Harbor</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">[root@binghe harbor]# ./install.sh \n</code></pre></div></figure>\n<h3 id=\"5-登录Harbor并添加账户\">5.登录Harbor并添加账户</h3>\n<p>安装成功后，在浏览器地址栏输入http://192.168.175.101:1180打开链接，如下图所示。</p>\n<p><img src=\"https://cimg1.17lai.site/data/2022/04/1620220416011231-4.jpg\" alt=\"\"></p>\n<p>输入用户名admin和密码binghe123，登录系统，如下图所示</p>\n<p><img src=\"https://cimg1.17lai.site/data/2022/04/1620220416011231-5.jpg\" alt=\"\"></p>\n<p>接下来，我们选择用户管理，添加一个管理员账户，为后续打包Docker镜像和上传Docker镜像做准备。添加账户的步骤如下所示。</p>\n<p><img src=\"https://cimg1.17lai.site/data/2022/04/1620220416011231-6.jpg\" alt=\"\"></p>\n<p><img src=\"https://cimg1.17lai.site/data/2022/04/1620220416011231-7.jpg\" alt=\"\"></p>\n<p>此处填写的密码为Binghe123。</p>\n<p>点击确定后，如下所示。</p>\n<p><img src=\"https://cimg1.17lai.site/data/2022/04/1620220416011231-8.jpg\" alt=\"\"></p>\n<p>此时，账户binghe还不是管理员，此时选中binghe账户，点击“设置为管理员”。</p>\n<p><img src=\"https://cimg1.17lai.site/data/2022/04/1620220416011231-9.jpg\" alt=\"\"></p>\n<p><img src=\"https://cimg1.17lai.site/data/2022/04/1620220416011231-10.jpg\" alt=\"\"></p>\n<p>此时，binghe账户就被设置为管理员了。到此，Harbor的安装就完成了。</p>\n<h3 id=\"6-修改Harbor端口\">6.修改Harbor端口</h3>\n<p><strong>如果安装Harbor后，大家需要修改Harbor的端口，可以按照如下步骤修改Harbor的端口，这里，我以将80端口修改为1180端口为例</strong></p>\n<p><strong>（1）修改harbor.yml文件</strong></p>\n<p>修改的配置项如下所示。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">hostname: 192.168.175.101\nhttp:\n  port: 1180\nharbor_admin_password: binghe123\n###并把https注释掉，不然在安装的时候会报错：ERROR:root:Error: The protocol is https but attribute ssl_cert is not set\n#https:\n  #port: 443\n  #certificate: /your/certificate/path\n  #private_key: /your/private/key/path\n</code></pre></div></figure>\n<p><strong>（2）修改docker-compose.yml文件</strong></p>\n<p>修改的配置项如下所示。</p>\n<p><strong>（3）修改config.yml文件</strong></p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">cd common/config/registry\nvim config.yml\n</code></pre></div></figure>\n<p>修改的配置项如下所示。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">realm: http://192.168.175.101:1180/service/token\n</code></pre></div></figure>\n<p><strong>（4）重启Docker</strong></p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">systemctl daemon-reload\nsystemctl restart docker.service\n</code></pre></div></figure>\n<p><strong>（5）重启Harbor</strong></p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">[root@binghe harbor]# docker-compose down\nStopping harbor-log ... done\nRemoving nginx             ... done\nRemoving harbor-portal     ... done\nRemoving harbor-jobservice ... done\nRemoving harbor-core       ... done\nRemoving redis             ... done\nRemoving registry          ... done\nRemoving registryctl       ... done\nRemoving harbor-db         ... done\nRemoving harbor-log        ... done\nRemoving network harbor_harbor\n \n[root@binghe harbor]# ./prepare\nprepare base dir is set to /mnt/harbor\nClearing the configuration file: /config/log/logrotate.conf\nClearing the configuration file: /config/nginx/nginx.conf\nClearing the configuration file: /config/core/env\nClearing the configuration file: /config/core/app.conf\nClearing the configuration file: /config/registry/root.crt\nClearing the configuration file: /config/registry/config.yml\nClearing the configuration file: /config/registryctl/env\nClearing the configuration file: /config/registryctl/config.yml\nClearing the configuration file: /config/db/env\nClearing the configuration file: /config/jobservice/env\nClearing the configuration file: /config/jobservice/config.yml\nGenerated configuration file: /config/log/logrotate.conf\nGenerated configuration file: /config/nginx/nginx.conf\nGenerated configuration file: /config/core/env\nGenerated configuration file: /config/core/app.conf\nGenerated configuration file: /config/registry/config.yml\nGenerated configuration file: /config/registryctl/env\nGenerated configuration file: /config/db/env\nGenerated configuration file: /config/jobservice/env\nGenerated configuration file: /config/jobservice/config.yml\nloaded secret from file: /secret/keys/secretkey\nGenerated configuration file: /compose_location/docker-compose.yml\nClean up the input dir\n \n[root@binghe harbor]# docker-compose up -d\nCreating network \"harbor_harbor\" with the default driver\nCreating harbor-log ... done\nCreating harbor-db   ... done\nCreating redis       ... done\nCreating registry    ... done\nCreating registryctl ... done\nCreating harbor-core ... done\nCreating harbor-jobservice ... done\nCreating harbor-portal     ... done\nCreating nginx             ... done\n \n[root@binghe harbor]# docker ps -a\nCONTAINER ID        IMAGE                                               COMMAND                  CREATED             STATUS                             PORTS\n</code></pre></div></figure>\n<h2 id=\"安装Jenkins（一般的做法）\">安装Jenkins（一般的做法）</h2>\n<h3 id=\"1-安装nfs（之前安装过的话，可以省略此步）\">1.安装nfs（之前安装过的话，可以省略此步）</h3>\n<p>使用 nfs 最大的问题就是写权限，可以使用 kubernetes 的 securityContext/runAsUser 指定 jenkins 容器中运行 jenkins 的用户 uid，以此来指定 nfs 目录的权限，让 jenkins 容器可写；也可以不限制，让所有用户都可以写。这里为了简单，就让所有用户可写了。</p>\n<p>如果之前已经安装过nfs，则这一步可以省略。找一台主机，安装 nfs，这里，我以在Master节点（binghe101服务器）上安装nfs为例。</p>\n<p>在命令行输入如下命令安装并启动nfs。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">yum install nfs-utils -y\nsystemctl start nfs-server\nsystemctl enable nfs-server\n</code></pre></div></figure>\n<h3 id=\"2-创建nfs共享目录\">2.创建nfs共享目录</h3>\n<p>在Master节点（binghe101服务器）上创建 <code>/opt/nfs/jenkins-data</code>目录作为nfs的共享目录，如下所示。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">mkdir -p /opt/nfs/jenkins-data\n</code></pre></div></figure>\n<p>接下来，编辑/etc/exports文件，如下所示。</p>\n<p>在/etc/exports文件文件中添加如下一行配置。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-ini\" data-language=\"ini\"><code class=\"language-ini\">/opt/nfs/jenkins-data 192.168.175.0/24(rw,all_squash)\n</code></pre></div></figure>\n<p>这里的 ip 使用 kubernetes node 节点的 ip 范围，后面的 <code>all_squash</code> 选项会将所有访问的用户都映射成 nfsnobody 用户，不管你是什么用户访问，最终都会压缩成 nfsnobody，所以只要将 <code>/opt/nfs/jenkins-data</code> 的属主改为 nfsnobody，那么无论什么用户来访问都具有写权限。</p>\n<p>这个选项在很多机器上由于用户 uid 不规范导致启动进程的用户不同，但是同时要对一个共享目录具有写权限时很有效。</p>\n<p>接下来，为 <code>/opt/nfs/jenkins-data</code>目录授权，并重新加载nfs，如下所示。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">chown -R 1000 /opt/nfs/jenkins-data/\nsystemctl reload nfs-server\n</code></pre></div></figure>\n<p>在K8S集群中任意一个节点上使用如下命令进行验证：</p>\n<p>如果能够看到 /opt/nfs/jenkins-data 就表示 ok 了。</p>\n<p>具体如下所示。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">[root@binghe101 ~]# showmount -e 192.168.175.101\nExport list for 192.168.175.101:\n/opt/nfs/jenkins-data 192.168.175.0/24\n\n[root@binghe102 ~]# showmount -e 192.168.175.101\nExport list for 192.168.175.101:\n/opt/nfs/jenkins-data 192.168.175.0/24\n</code></pre></div></figure>\n<h3 id=\"3-创建PV\">3.创建PV</h3>\n<p>Jenkins 其实只要加载对应的目录就可以读取之前的数据，但是由于 deployment 无法定义存储卷，因此我们只能使用 StatefulSet。</p>\n<p>首先创建 pv，pv 是给 StatefulSet 使用的，每次 StatefulSet 启动都会通过 volumeClaimTemplates 这个模板去创建 pvc，因此必须得有 pv，才能供 pvc 绑定。</p>\n<p>创建jenkins-pv.yaml文件，文件内容如下所示。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">apiVersion: v1\nkind: PersistentVolume\nmetadata:\n  name: jenkins\nspec:\n  nfs:\n    path: /opt/nfs/jenkins-data\n    server: 192.168.175.101\n  accessModes: [\"ReadWriteOnce\"]\n  capacity:\n    storage: 1Ti\n</code></pre></div></figure>\n<p>我这里给了 1T存储空间，可以根据实际配置。</p>\n<p>执行如下命令创建pv。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">kubectl apply -f jenkins-pv.yaml \n</code></pre></div></figure>\n<h3 id=\"4-创建serviceAccount\">4.创建serviceAccount</h3>\n<p>创建service account，因为 jenkins 后面需要能够动态创建 slave，因此它必须具备一些权限。</p>\n<p>创建jenkins-service-account.yaml文件，文件内容如下所示。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">apiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: jenkins\n\n---\nkind: Role\napiVersion: rbac.authorization.k8s.io/v1beta1\nmetadata:\n  name: jenkins\nrules:\n  - apiGroups: [\"\"]\n    resources: [\"pods\"]\n    verbs: [\"create\", \"delete\", \"get\", \"list\", \"patch\", \"update\", \"watch\"]\n  - apiGroups: [\"\"]\n    resources: [\"pods/exec\"]\n    verbs: [\"create\", \"delete\", \"get\", \"list\", \"patch\", \"update\", \"watch\"]\n  - apiGroups: [\"\"]\n    resources: [\"pods/log\"]\n    verbs: [\"get\", \"list\", \"watch\"]\n  - apiGroups: [\"\"]\n    resources: [\"secrets\"]\n    verbs: [\"get\"]\n\n---\napiVersion: rbac.authorization.k8s.io/v1beta1\nkind: RoleBinding\nmetadata:\n  name: jenkins\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: Role\n  name: jenkins\nsubjects:\n  - kind: ServiceAccount\n    name: jenkins\n</code></pre></div></figure>\n<p>上述配置中，创建了一个 RoleBinding 和一个 ServiceAccount，并且将 RoleBinding 的权限绑定到这个用户上。所以，jenkins 容器必须使用这个 ServiceAccount 运行才行，不然 RoleBinding 的权限它将不具备。</p>\n<p>RoleBinding 的权限很容易就看懂了，因为 jenkins 需要创建和删除 slave，所以才需要上面这些权限。至于 secrets 权限，则是 https 证书。</p>\n<p>执行如下命令创建serviceAccount。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">kubectl apply -f jenkins-service-account.yaml \n</code></pre></div></figure>\n<h3 id=\"5-安装Jenkins\">5.安装Jenkins</h3>\n<p>创建jenkins-statefulset.yaml文件，文件内容如下所示。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">apiVersion: apps/v1\nkind: StatefulSet\nmetadata:\n  name: jenkins\n  labels:\n    name: jenkins\nspec:\n  selector:\n    matchLabels:\n      name: jenkins\n  serviceName: jenkins\n  replicas: 1\n  updateStrategy:\n    type: RollingUpdate\n  template:\n    metadata:\n      name: jenkins\n      labels:\n        name: jenkins\n    spec:\n      terminationGracePeriodSeconds: 10\n      serviceAccountName: jenkins\n      containers:\n        - name: jenkins\n          image: docker.io/jenkins/jenkins:lts\n          imagePullPolicy: IfNotPresent\n          ports:\n            - containerPort: 8080\n            - containerPort: 32100\n          resources:\n            limits:\n              cpu: 4\n              memory: 4Gi\n            requests:\n              cpu: 4\n              memory: 4Gi\n          env:\n            - name: LIMITS_MEMORY\n              valueFrom:\n                resourceFieldRef:\n                  resource: limits.memory\n                  divisor: 1Mi\n            - name: JAVA_OPTS\n              \n              value: -Xmx$(LIMITS_MEMORY)m -XshowSettings:vm -Dhudson.slaves.NodeProvisioner.initialDelay=0 -Dhudson.slaves.NodeProvisioner.MARGIN=50 -Dhudson.slaves.NodeProvisioner.MARGIN0=0.85\n          volumeMounts:\n            - name: jenkins-home\n              mountPath: /var/jenkins_home\n          livenessProbe:\n            httpGet:\n              path: /login\n              port: 8080\n            initialDelaySeconds: 60\n            timeoutSeconds: 5\n            failureThreshold: 12 \n          readinessProbe:\n            httpGet:\n              path: /login\n              port: 8080\n            initialDelaySeconds: 60\n            timeoutSeconds: 5\n            failureThreshold: 12 \n  \n  volumeClaimTemplates:\n    - metadata:\n        name: jenkins-home\n      spec:\n        accessModes: [\"ReadWriteOnce\"]\n        resources:\n          requests:\n            storage: 1Ti\n</code></pre></div></figure>\n<p>jenkins 部署时需要注意它的副本数，你的副本数有多少就要有多少个 pv，同样，存储会有多倍消耗。这里我只使用了一个副本，因此前面也只创建了一个 pv。</p>\n<p>使用如下命令安装Jenkins。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">kubectl apply -f jenkins-statefulset.yaml \n</code></pre></div></figure>\n<h3 id=\"6-创建Service\">6.创建Service</h3>\n<p>创建jenkins-service.yaml文件，文件内容如下所示。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">apiVersion: v1\nkind: Service\nmetadata:\n  name: jenkins\nspec:\n  \n  selector:\n    name: jenkins\n  \n  \n  ports:\n    - name: http\n      port: 80\n      nodePort: 31888\n      targetPort: 8080\n      protocol: TCP\n    - name: jenkins-agent\n      port: 32100\n      nodePort: 32100\n      targetPort: 32100\n      protocol: TCP\n  type: NodePort\n</code></pre></div></figure>\n<p>使用如下命令安装Service。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">kubectl apply -f jenkins-service.yaml \n</code></pre></div></figure>\n<h3 id=\"7-安装-ingress\">7.安装 ingress</h3>\n<p>jenkins 的 web 界面需要从集群外访问，这里我们选择的是使用 ingress。创建jenkins-ingress.yaml文件，文件内容如下所示。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">apiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  name: jenkins\nspec:\n  rules:\n    - http:\n        paths:\n          - path: /\n            backend:\n              serviceName: jenkins\n              servicePort: 31888\n      host: jekins.binghe.com\n</code></pre></div></figure>\n<p><strong>这里，需要注意的是host必须配置为域名或者主机名，否则会报错，如下所示。</strong></p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">The Ingress \"jenkins\" is invalid: spec.rules[0].host: Invalid value: \"192.168.175.101\": must be a DNS name, not an IP address\n</code></pre></div></figure>\n<p>使用如下命令安装ingress。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">kubectl apply -f jenkins-ingress.yaml \n</code></pre></div></figure>\n<p>最后，由于我这里使用的是虚拟机来搭建相关的环境，在本机访问虚拟机映射的jekins.binghe.com时，需要配置本机的hosts文件，在本机的hosts文件中加入如下配置项。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-ini\" data-language=\"ini\"><code class=\"language-ini\">192.168.175.101 jekins.binghe.com\n</code></pre></div></figure>\n<p>注意：在Windows操作系统中，hosts文件所在的目录如下。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-ini\" data-language=\"ini\"><code class=\"language-ini\">C:\\Windows\\System32\\drivers\\etc\n</code></pre></div></figure>\n<p>接下来，就可以在浏览器中通过链接：<a href=\"https://jekins.binghe.com/31888\">http://jekins.binghe.com:31888</a> 来访问Jekins了。</p>\n<h2 id=\"物理机安装SVN\">物理机安装SVN</h2>\n<p>这里，以在Master节点（binghe101服务器）上安装SVN为例。</p>\n<h3 id=\"1-使用yum安装SVN\">1.使用yum安装SVN</h3>\n<p>在命令行执行如下命令安装SVN。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">yum -y install subversion \n</code></pre></div></figure>\n<h3 id=\"2-创建SVN库\">2.创建SVN库</h3>\n<p>依次执行如下命令。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">#创建/data/svn\nmkdir -p /data/svn \n#初始化svn\nsvnserve -d -r /data/svn\n#创建代码仓库\nsvnadmin create /data/svn/test\n</code></pre></div></figure>\n<h3 id=\"3-配置SVN\">3.配置SVN</h3>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">mkdir /data/svn/conf\ncp /data/svn/test/conf/* /data/svn/conf/\ncd /data/svn/conf/\n[root@binghe101 conf]# ll\n总用量 20\n-rw-r--r-- 1 root root 1080 5月  12 02:17 authz\n-rw-r--r-- 1 root root  885 5月  12 02:17 hooks-env.tmpl\n-rw-r--r-- 1 root root  309 5月  12 02:17 passwd\n-rw-r--r-- 1 root root 4375 5月  12 02:17 svnserve.conf\n</code></pre></div></figure>\n<ul>\n<li>配置authz文件，</li>\n</ul>\n<p>配置后的内容如下所示。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-ini\" data-language=\"ini\"><code class=\"language-ini\">[aliases]\n# joe = /C=XZ/ST=Dessert/L=Snake City/O=Snake Oil, Ltd./OU=Research Institute/CN=Joe Average\n\n[groups]\n# harry_and_sally = harry,sally\n# harry_sally_and_joe = harry,sally,&amp;joe\nSuperAdmin = admin\nbinghe = admin,binghe\n\n# [/foo/bar]\n# harry = rw\n# &amp;joe = r\n# * =\n\n# [repository:/baz/fuz]\n# @harry_and_sally = rw\n# * = r\n\n[test:/]\n@SuperAdmin=rw\n@binghe=rw\n</code></pre></div></figure>\n<ul>\n<li>配置passwd文件</li>\n</ul>\n<p>配置后的内容如下所示。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-ini\" data-language=\"ini\"><code class=\"language-ini\">[users]\n# harry = harryssecret\n# sally = sallyssecret\nadmin = admin123\nbinghe = binghe123\n</code></pre></div></figure>\n<ul>\n<li>配置 svnserve.conf</li>\n</ul>\n<p>配置后的文件如下所示。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-ini\" data-language=\"ini\"><code class=\"language-ini\">### This file controls the configuration of the svnserve daemon, if you\n### use it to allow access to this repository.  (If you only allow\n### access through http: and/or file: URLs, then this file is\n### irrelevant.)\n\n### Visit http://subversion.apache.org/ for more information.\n\n[general]\n### The anon-access and auth-access options control access to the\n### repository for unauthenticated (a.k.a. anonymous) users and\n### authenticated users, respectively.\n### Valid values are \"write\", \"read\", and \"none\".\n### Setting the value to \"none\" prohibits both reading and writing;\n### \"read\" allows read-only access, and \"write\" allows complete \n### read/write access to the repository.\n### The sample settings below are the defaults and specify that anonymous\n### users have read-only access to the repository, while authenticated\n### users have read and write access to the repository.\nanon-access = none\nauth-access = write\n### The password-db option controls the location of the password\n### database file.  Unless you specify a path starting with a /,\n### the file's location is relative to the directory containing\n### this configuration file.\n### If SASL is enabled (see below), this file will NOT be used.\n### Uncomment the line below to use the default password file.\npassword-db = /data/svn/conf/passwd\n### The authz-db option controls the location of the authorization\n### rules for path-based access control.  Unless you specify a path\n### starting with a /, the file's location is relative to the\n### directory containing this file.  The specified path may be a\n### repository relative URL (^/) or an absolute file:// URL to a text\n### file in a Subversion repository.  If you don't specify an authz-db,\n### no path-based access control is done.\n### Uncomment the line below to use the default authorization file.\nauthz-db = /data/svn/conf/authz\n### The groups-db option controls the location of the file with the\n### group definitions and allows maintaining groups separately from the\n### authorization rules.  The groups-db file is of the same format as the\n### authz-db file and should contain a single [groups] section with the\n### group definitions.  If the option is enabled, the authz-db file cannot\n### contain a [groups] section.  Unless you specify a path starting with\n### a /, the file's location is relative to the directory containing this\n### file.  The specified path may be a repository relative URL (^/) or an\n### absolute file:// URL to a text file in a Subversion repository.\n### This option is not being used by default.\n# groups-db = groups\n### This option specifies the authentication realm of the repository.\n### If two repositories have the same authentication realm, they should\n### have the same password database, and vice versa.  The default realm\n### is repository's uuid.\nrealm = svn\n### The force-username-case option causes svnserve to case-normalize\n### usernames before comparing them against the authorization rules in the\n### authz-db file configured above.  Valid values are \"upper\" (to upper-\n### case the usernames), \"lower\" (to lowercase the usernames), and\n### \"none\" (to compare usernames as-is without case conversion, which\n### is the default behavior).\n# force-username-case = none\n### The hooks-env options specifies a path to the hook script environment \n### configuration file. This option overrides the per-repository default\n### and can be used to configure the hook script environment for multiple \n### repositories in a single file, if an absolute path is specified.\n### Unless you specify an absolute path, the file's location is relative\n### to the directory containing this file.\n# hooks-env = hooks-env\n\n[sasl]\n### This option specifies whether you want to use the Cyrus SASL\n### library for authentication. Default is false.\n### Enabling this option requires svnserve to have been built with Cyrus\n### SASL support; to check, run 'svnserve --version' and look for a line\n### reading 'Cyrus SASL authentication is available.'\n# use-sasl = true\n### These options specify the desired strength of the security layer\n### that you want SASL to provide. 0 means no encryption, 1 means\n### integrity-checking only, values larger than 1 are correlated\n### to the effective key length for encryption (e.g. 128 means 128-bit\n### encryption). The values below are the defaults.\n# min-encryption = 0\n# max-encryption = 256\n</code></pre></div></figure>\n<p>接下来，将/data/svn/conf目录下的svnserve.conf文件复制到/data/svn/test/conf/目录下。如下所示。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">[root@binghe101 conf]# cp /data/svn/conf/svnserve.conf /data/svn/test/conf/\ncp：是否覆盖'/data/svn/test/conf/svnserve.conf'？ y\n</code></pre></div></figure>\n<h3 id=\"4-启动SVN服务\">4.启动SVN服务</h3>\n<p><strong>（1）创建svnserve.service服务</strong></p>\n<p>创建svnserve.service文件</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">vim /usr/lib/systemd/system/svnserve.service\n</code></pre></div></figure>\n<p>文件的内容如下所示。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-ini\" data-language=\"ini\"><code class=\"language-ini\">[Unit]\nDescription=Subversion protocol daemon\nAfter=syslog.target network.target\nDocumentation=man:svnserve(8)\n\n[Service]\nType=forking\nEnvironmentFile=/etc/sysconfig/svnserve\n#ExecStart=/usr/bin/svnserve --daemon --pid-file=/run/svnserve/svnserve.pid $OPTIONS\nExecStart=/usr/bin/svnserve --daemon $OPTIONS\nPrivateTmp=yes\n\n[Install]\nWantedBy=multi-user.target\n</code></pre></div></figure>\n<p>接下来执行如下命令使配置生效。</p>\n<p>命令执行成功后，修改 /etc/sysconfig/svnserve 文件。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">vim /etc/sysconfig/svnserve \n</code></pre></div></figure>\n<p>修改后的文件内容如下所示。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-ini\" data-language=\"ini\"><code class=\"language-ini\"># OPTIONS is used to pass command-line arguments to svnserve.\n# \n# Specify the repository location in -r parameter:\nOPTIONS=\"-r /data/svn\"\n</code></pre></div></figure>\n<p><strong>（2）启动SVN</strong></p>\n<p>首先查看SVN状态，如下所示。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">[root@itence10 conf]# systemctl status svnserve.service\n● svnserve.service - Subversion protocol daemon\n   Loaded: loaded (/usr/lib/systemd/system/svnserve.service; disabled; vendor preset: disabled)\n   Active: inactive (dead)\n     Docs: man:svnserve(8)\n</code></pre></div></figure>\n<p>可以看到，此时SVN并没有启动，接下来，需要启动SVN。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">systemctl start svnserve.service\n</code></pre></div></figure>\n<p>设置SVN服务开机自启动。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">systemctl enable svnserve.service\n</code></pre></div></figure>\n<p>接下来，就可以下载安装TortoiseSVN，输入链接<a href=\"svn://192.168.0.10/test\">svn://192.168.0.10/test</a> 并输入用户名binghe，密码binghe123来连接SVN了。</p>\n<h2 id=\"物理机安装Jenkins\">物理机安装Jenkins</h2>\n<p><strong>注意：安装Jenkins之前需要安装JDK和Maven，我这里同样将Jenkins安装在Master节点（binghe101服务器）。</strong></p>\n<h3 id=\"1-启用Jenkins库\">1.启用Jenkins库</h3>\n<p>运行以下命令以下载repo文件并导入GPG密钥：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">wget -O /etc/yum.repos.d/jenkins.repo http://pkg.jenkins-ci.org/redhat-stable/jenkins.repo\nrpm --import https://jenkins-ci.org/redhat/jenkins-ci.org.key\n</code></pre></div></figure>\n<h3 id=\"2-安装Jenkins\">2.安装Jenkins</h3>\n<p>执行如下命令安装Jenkis。</p>\n<p>接下来，修改Jenkins默认端口，如下所示。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">vim /etc/sysconfig/jenkins\n</code></pre></div></figure>\n<p>修改后的两项配置如下所示。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-ini\" data-language=\"ini\"><code class=\"language-ini\">JENKINS_JAVA_CMD=\"/usr/local/jdk1.8.0_212/bin/java\"\nJENKINS_PORT=\"18080\"\n</code></pre></div></figure>\n<p>此时，已经将Jenkins的端口由8080修改为18080</p>\n<h3 id=\"3-启动Jenkins\">3.启动Jenkins</h3>\n<p>在命令行输入如下命令启动Jenkins。</p>\n<p>配置Jenkins开机自启动。</p>\n<p>查看Jenkins的运行状态。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">[root@itence10 ~]# systemctl status jenkins\n● jenkins.service - LSB: Jenkins Automation Server\n   Loaded: loaded (/etc/rc.d/init.d/jenkins; generated)\n   Active: active (running) since Tue 2020-05-12 04:33:40 EDT; 28s ago\n     Docs: man:systemd-sysv-generator(8)\n    Tasks: 71 (limit: 26213)\n   Memory: 550.8M\n</code></pre></div></figure>\n<p>说明，Jenkins启动成功。</p>\n<h2 id=\"配置Jenkins运行环境\">配置Jenkins运行环境</h2>\n<h3 id=\"1-登录Jenkins\">1.登录Jenkins</h3>\n<p>首次安装后，需要配置Jenkins的运行环境。首先，在浏览器地址栏访问链接<a href=\"http://192.168.0.10:18080\">http://192.168.0.10:18080</a>，打开Jenkins界面。</p>\n<p><img src=\"https://cimg1.17lai.site/data/2022/04/1620220416011231-11.jpg\" alt=\"\"></p>\n<p>根据提示使用如下命令到服务器上找密码值，如下所示。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">[root@binghe101 ~]# cat /var/lib/jenkins/secrets/initialAdminPassword\n71af861c2ab948a1b6efc9f7dde90776\n</code></pre></div></figure>\n<p>将密码71af861c2ab948a1b6efc9f7dde90776复制到文本框，点击继续。会跳转到自定义Jenkins页面，如下所示。</p>\n<p><img src=\"https://cimg1.17lai.site/data/2022/04/1620220416011231-12.jpg\" alt=\"\"></p>\n<p>这里，可以直接选择“安装推荐的插件”。之后会跳转到一个安装插件的页面，如下所示。</p>\n<p><img src=\"https://cimg1.17lai.site/data/2022/04/1620220416011231-13.jpg\" alt=\"\"></p>\n<p>此步骤可能有下载失败的情况，可直接忽略。</p>\n<h3 id=\"2-安装插件\">2.安装插件</h3>\n<p>需要安装的插件</p>\n<ul>\n<li>\n<p>Kubernetes Cli Plugin：该插件可直接在Jenkins中使用kubernetes命令行进行操作。</p>\n</li>\n<li>\n<p>Kubernetes plugin： 使用kubernetes则需要安装该插件</p>\n</li>\n<li>\n<p>Kubernetes Continuous Deploy Plugin：kubernetes部署插件，可根据需要使用</p>\n</li>\n</ul>\n<p>还有更多的插件可供选择，可点击 系统管理-&gt;管理插件进行管理和添加，安装相应的Docker插件、SSH插件、Maven插件。其他的插件可以根据需要进行安装。如下图所示。</p>\n<p><img src=\"https://cimg1.17lai.site/data/2022/04/1620220416011231-14.jpg\" alt=\"\"></p>\n<p><img src=\"https://cimg1.17lai.site/data/2022/04/1620220416011231-15.jpg\" alt=\"\"></p>\n<h3 id=\"3-配置Jenkins\">3.配置Jenkins</h3>\n<p><strong>（1）配置JDK和Maven</strong></p>\n<p>在Global Tool Configuration中配置JDK和Maven，如下所示，打开Global Tool Configuration界面。</p>\n<p><img src=\"https://cimg1.17lai.site/data/2022/04/1620220416011231-16.jpg\" alt=\"\"></p>\n<p>接下来就开始配置JDK和Maven了。</p>\n<p>由于我在服务器上将Maven安装在/usr/local/maven-3.6.3目录下，所以，需要在“Maven 配置”中进行配置，如下图所示。</p>\n<p><img src=\"https://cimg1.17lai.site/data/2022/04/1620220416011231-17.jpg\" alt=\"\"></p>\n<p>接下来，配置JDK，如下所示。</p>\n<p><img src=\"https://cimg1.17lai.site/data/2022/04/1620220416011231-18.jpg\" alt=\"\"></p>\n<p><strong>注意：不要勾选“Install automatically”</strong></p>\n<p>接下来，配置Maven，如下所示。</p>\n<p><img src=\"https://cimg1.17lai.site/data/2022/04/1620220416011231-19.jpg\" alt=\"\"></p>\n<p><strong>注意：不要勾选“Install automatically”</strong></p>\n<p><strong>（2）配置SSH</strong></p>\n<p>进入Jenkins的Configure System界面配置SSH，如下所示。</p>\n<p><img src=\"https://cimg1.17lai.site/data/2022/04/1620220416011231-20.jpg\" alt=\"\"></p>\n<p>找到 SSH remote hosts 进行配置。</p>\n<p><img src=\"https://cimg1.17lai.site/data/2022/04/1620220416011231-21.jpg\" alt=\"\"></p>\n<p><img src=\"https://cimg1.17lai.site/data/2022/04/1620220416011231-22.jpg\" alt=\"\"></p>\n<p>配置完成后，点击Check connection按钮，会显示 Successfull connection。如下所示。</p>\n<p><img src=\"https://cimg1.17lai.site/data/2022/04/1620220416011231-23.jpg\" alt=\"\"></p>\n<p>至此，Jenkins的基本配置就完成了。</p>\n<h2 id=\"Jenkins发布Docker项目到K8s集群\">Jenkins发布Docker项目到K8s集群</h2>\n<h3 id=\"1-调整SpringBoot项目的配置\">1.调整SpringBoot项目的配置</h3>\n<p>实现，SpringBoot项目中启动类所在的模块的pom.xml需要引入打包成Docker镜像的配置，如下所示。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">  &lt;properties&gt;\n        &lt;docker.repostory&gt;192.168.0.10:1180&lt;/docker.repostory&gt;\n        &lt;docker.registry.name&gt;test&lt;/docker.registry.name&gt;\n        &lt;docker.image.tag&gt;1.0.0&lt;/docker.image.tag&gt;\n        &lt;docker.maven.plugin.version&gt;1.4.10&lt;/docker.maven.plugin.version&gt;\n  &lt;/properties&gt;\n\n&lt;build&gt;\n        &lt;finalName&gt;test-starter&lt;/finalName&gt;\n        &lt;plugins&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;\n            &lt;/plugin&gt;\n            \n            \n            \n            &lt;plugin&gt;\n                &lt;groupId&gt;com.spotify&lt;/groupId&gt;\n                &lt;artifactId&gt;dockerfile-maven-plugin&lt;/artifactId&gt;\n                &lt;version&gt;${docker.maven.plugin.version}&lt;/version&gt;\n                &lt;executions&gt;\n                    &lt;execution&gt;\n                    &lt;id&gt;default&lt;/id&gt;\n                    &lt;goals&gt;\n                        \n                        &lt;goal&gt;build&lt;/goal&gt;\n                        &lt;goal&gt;push&lt;/goal&gt;\n                    &lt;/goals&gt;\n                    &lt;/execution&gt;\n                &lt;/executions&gt;\n                &lt;configuration&gt;\n                    &lt;contextDirectory&gt;${project.basedir}&lt;/contextDirectory&gt;\n                    \n                    &lt;useMavenSettingsForAuth&gt;useMavenSettingsForAuth&gt;true&lt;/useMavenSettingsForAuth&gt;\n                    &lt;repository&gt;${docker.repostory}/${docker.registry.name}/${project.artifactId}&lt;/repository&gt;\n                    &lt;tag&gt;${docker.image.tag}&lt;/tag&gt;\n                    &lt;buildArgs&gt;\n                        &lt;JAR_FILE&gt;target/${project.build.finalName}.jar&lt;/JAR_FILE&gt;\n                    &lt;/buildArgs&gt;\n                &lt;/configuration&gt;\n            &lt;/plugin&gt;\n\n        &lt;/plugins&gt;\n        \n        &lt;resources&gt;\n            \n            &lt;resource&gt;\n                &lt;directory&gt;src/main/resources&lt;/directory&gt;\n                &lt;targetPath&gt;${project.build.directory}/classes&lt;/targetPath&gt;\n                &lt;includes&gt;\n                    &lt;include&gt;**/*&lt;/include&gt;\n                &lt;/includes&gt;\n                &lt;filtering&gt;true&lt;/filtering&gt;\n            &lt;/resource&gt;\n        &lt;/resources&gt;\n    &lt;/build&gt;\n</code></pre></div></figure>\n<p>接下来，在SpringBoot启动类所在模块的根目录创建Dockerfile，内容示例如下所示。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-docker\" data-language=\"docker\"><code class=\"language-docker\">#添加依赖环境，前提是将Java8的Docker镜像从官方镜像仓库pull下来，然后上传到自己的Harbor私有仓库中\nFROM 192.168.0.10:1180/library/java:8\n#指定镜像制作作者\nMAINTAINER binghe\n#运行目录\nVOLUME /tmp\n#将本地的文件拷贝到容器\nADD target/*jar app.jar\n#启动容器后自动执行的命令\nENTRYPOINT [ \"java\", \"-Djava.security.egd=file:/dev/./urandom\", \"-jar\", \"/app.jar\" ]\n</code></pre></div></figure>\n<p>根据实际情况，自行修改。</p>\n<p><strong>注意：FROM 192.168.0.10:1180/library/java:8的前提是执行如下命令。</strong></p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">docker pull java:8\ndocker tag java:8 192.168.0.10:1180/library/java:8\ndocker login 192.168.0.10:1180\ndocker push 192.168.0.10:1180/library/java:8\n</code></pre></div></figure>\n<p>在SpringBoot启动类所在模块的根目录创建yaml文件，录入叫做test.yaml文件，内容如下所示。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: test-starter\n  labels:\n    app: test-starter\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: test-starter\n  template:\n    metadata:\n      labels:\n        app: test-starter\n    spec:\n      containers:\n      - name: test-starter\n        image: 192.168.0.10:1180/test/test-starter:1.0.0\n        ports:\n        - containerPort: 8088\n      nodeSelector:\n        clustertype: node12\n\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: test-starter\n  labels:\n    app: test-starter\nspec:\n  ports:\n    - name: http\n      port: 8088\n      nodePort: 30001\n  type: NodePort\n  selector:\n    app: test-starter\n</code></pre></div></figure>\n<h3 id=\"2-Jenkins配置发布项目\">2.Jenkins配置发布项目</h3>\n<p>将项目上传到SVN代码库，例如地址为<a href=\"svn://192.168.0.1/test\">svn://192.168.0.10/test</a></p>\n<p>接下来，在Jenkins中配置自动发布。步骤如下所示。</p>\n<p>点击新建Item。</p>\n<p>在描述文本框中输入描述信息，如下所示。</p>\n<p>接下来，配置SVN信息。</p>\n<p><strong>注意：配置GitLab的步骤与SVN相同，不再赘述。</strong></p>\n<p>定位到Jenkins的“构建模块”，使用Execute Shell来构建发布项目到K8S集群。</p>\n<p>执行的命令依次如下所示。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">#删除本地原有的镜像,不会影响Harbor仓库中的镜像\ndocker rmi 192.168.0.10:1180/test/test-starter:1.0.0\n#使用Maven编译、构建Docker镜像，执行完成后本地Docker容器中会重新构建镜像文件\n/usr/local/maven-3.6.3/bin/mvn -f ./pom.xml clean install -Dmaven.test.skip=true\n#登录 Harbor仓库\ndocker login 192.168.0.10:1180 -u binghe -p Binghe123\n#上传镜像到Harbor仓库\ndocker push 192.168.0.10:1180/test/test-starter:1.0.0\n#停止并删除K8S集群中运行的\n/usr/bin/kubectl delete -f test.yaml\n#将Docker镜像重新发布到K8S集群\n/usr/bin/kubectl apply -f test.yaml\n</code></pre></div></figure>\n<p>编辑整理 <a href=\"https://www.jianshu.com/u/b1e8818c1241\">冰河团队</a> <a href=\"https://www.jianshu.com/p/86d288ea64c4\">From</a></p>\n<h2 id=\"系列教程\"><strong>系列教程</strong></h2>\n<p><a href=\"/atom.xml\"><i class=\"fas fa-rss\"></i>全部文章RSS订阅</a></p>\n<h3 id=\"Devops系列\"><strong>Devops系列</strong></h3>\n<p><a href=\"/categories/devops/atom.xml\"><i class=\"fas fa-rss\"></i><strong>Devops 分类 RSS 订阅</strong></a></p>\n<ul>\n<li><a href=\"/posts/ab63eb8f/\">自建全套开源Devops开发系统</a></li>\n<li><a href=\"/posts/d32a07a7/\">Git介绍以及分支模型图解</a></li>\n<li><a href=\"/posts/39563241/\">三万字无坑搭建基于Docker+K8S+GitLab/SVN+Jenkins+Harbor持续集成交付环境</a></li>\n<li><a href=\"/posts/3437994a/\">DevOps系列—【Jenkinsfile+Dockerfile+nginx+vue】</a></li>\n<li><a href=\"/posts/f4c3ad41/\">项目开发管理工具推荐</a></li>\n<li><a href=\"/posts/acc13b70/\">Gitlab的安装及使用教程完全版</a></li>\n<li><a href=\"/posts/d08eb7b/\">Gitlab的安装及使用</a></li>\n<li><a href=\"/posts/78c3371/\">那些有用的Github工具介绍！Action、app、workflow等</a></li>\n</ul>\n",
            "tags": [
                "gitlab",
                "docker",
                "k8s",
                "harbor"
            ]
        },
        {
            "id": "https://blog.17lai.site/posts/3437994a/",
            "url": "https://blog.17lai.site/posts/3437994a/",
            "title": "DevOps系列---【Jenkinsfile+Dockerfile+nginx+vue】",
            "date_published": "2022-04-15T10:49:37.000Z",
            "content_html": "<h2 id=\"1-前提：一台装好的jenkins\">1.前提：一台装好的jenkins</h2>\n<p>参考:<a href=\"https://www.cnblogs.com/hujunwei/p/13176994.html\">https://www.cnblogs.com/hujunwei/p/13176994.html</a></p>\n<h2 id=\"2-编写Dockerfile，放在项目根目录下\">2.编写Dockerfile，放在项目根目录下</h2>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-docker\" data-language=\"docker\"><code class=\"language-docker\">FROM nginx\n#修改名字、版本、作者\nLABEL name=\"home-finance-web-dev\" version=\"1.0.0\" author=\"hjw\"\nCOPY dist/ /usr/share/nginx/html/\nCOPY nginx/nginx-dev.conf /etc/nginx/nginx.conf\nEXPOSE 80</code></pre></div></figure>\n<h2 id=\"3-编写Jenkinsfile，放在项目根目录下\">3.编写Jenkinsfile，放在项目根目录下</h2>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">//流水线脚本\npipeline {\n    agent any\n    environment {\n        WS = \"${WORKSPACE}\"\n        TOPIC = \"测试\"\n        TITLE = \"标题\"\n        CONTENT = \"具体内容\"\n    }\n\n    //定义流水线的加工流程\n    stages {\n        stage('环境检查') {\n            steps{\n                sh 'printenv'\n                echo \"正在检测基本信息\"\n                sh 'git --version'\n                sh 'docker version'\n            }\n        }\n\n        stage('编译') {\n            //jenkins不配置任何环境的情况下可以兼容任何场景\n            agent {\n                docker { image 'node:14.17.6-alpine3.13' }\n            }\n            steps{\n                sh 'node -v'\n                sh 'npm -v'\n                sh 'pwd &amp;&amp; ls -alh'\n                sh 'echo \"默认的项目目录:${WS}\"'\n                //注意:cd ${WS} &amp;&amp; npm不能分开写，也不能直接用${WORKSPACE}\n                sh 'cd ${WS}/fast-ui &amp;&amp; npm config set registry=https://registry.npm.taobao.org &amp;&amp; npm install -g cnpm --registry=https://registry.npm.taobao.org &amp;&amp; cnpm install &amp;&amp; cnpm run build'\n            }\n        }\n\n        stage('生成镜像') {\n            steps{\n                sh 'pwd &amp;&amp; ls -alh'\n                echo '生成镜像'\n                sh 'docker version'\n                sh \"echo 默认的项目目录:${WS}\"\n                sh 'cd ${WS}/fast-ui &amp;&amp; docker build -t home-finance-web .'\n            }\n        }\n\n        stage('部署') {\n            steps{\n                echo '部署....'\n                sh 'pwd &amp;&amp; ls -alh'\n                sh 'pwd &amp;&amp; ls -alh'\n                sh 'docker rm -f home-finance-web'\n                sh 'docker run -d -p 8081:80 --restart=always --name home-finance-web home-finance-web'\n            }\n        }\n    }\n}</code></pre></div></figure>\n<h2 id=\"4-编写nginx-dev-conf-放在项目根目录下的nginx目录下\">4.编写nginx-dev.conf,放在项目根目录下的nginx目录下</h2>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-nginx\" data-language=\"nginx\"><code class=\"language-nginx\">user  nginx;\nworker_processes  1;\n\nerror_log  /var/log/nginx/error.log warn;\npid        /var/run/nginx.pid;\n\nevents {\n    worker_connections  1024;\n}\n\nhttp {\n    include       /etc/nginx/mime.types;\n    default_type  application/octet-stream;\n\n    log_format  main  '$remote_addr - $remote_user [$time_local] \"$request\" '\n                      '$status $body_bytes_sent \"$http_referer\" '\n                      '\"$http_user_agent\" \"$http_x_forwarded_for\"';\n\n    access_log  /var/log/nginx/access.log  main;\n\n    sendfile        on;\n    #tcp_nopush     on;\n\n    keepalive_timeout  65;\n\n    #gzip  on;\n\n    # include /etc/nginx/conf.d/*.conf;\n\n    server {\n        listen       80;\n        server_name  101.43.159.8; # 服务器地址或绑定域名\n\n        #charset koi8-r;\n        #access_log  /var/log/nginx/host.access.log  main;\n\n        # =========================================================\n        # ================== ↓↓↓↓↓↓ start ↓↓↓↓↓↓ ==================\n        # =========================================================\n\n        location / {\n            root   /usr/share/nginx/html;\n            #try_files $uri $uri/ @router;\n            index  index.html index.htm;\n            try_files $uri $uri/ /index.html; # 解决页面刷新 404 问题\n            #proxy_pass http://zhengqingya.gitee.io; # 代理的ip地址和端口号\n            #proxy_connect_timeout 600; #代理的连接超时时间（单位：毫秒）\n            #proxy_read_timeout 600; #代理的读取资源超时时间（单位：毫秒）\n        }\n\n        # =========================================================\n        # ================== ↑↑↑↑↑↑ end ↑↑↑↑↑↑ ==================\n        # =========================================================\n\n        #error_page  404              /404.html;\n\n        # redirect server error pages to the static page /50x.html\n        #\n        error_page   500 502 503 504  /50x.html;\n        location = /50x.html {\n            root   /usr/share/nginx/html;\n        }\n\n    }\n}</code></pre></div></figure>\n<p>编辑整理 <a href=\"https://www.cnblogs.com/hujunwei/p/15957956.html\">hujunwei</a></p>\n<h2 id=\"系列教程\"><strong>系列教程</strong></h2>\n<p><a href=\"/atom.xml\"><i class=\"fas fa-rss\"></i>全部文章RSS订阅</a></p>\n<h3 id=\"Devops系列\"><strong>Devops系列</strong></h3>\n<p><a href=\"/categories/devops/atom.xml\"><i class=\"fas fa-rss\"></i><strong>Devops 分类 RSS 订阅</strong></a></p>\n<ul>\n<li><a href=\"/posts/ab63eb8f/\">自建全套开源Devops开发系统</a></li>\n<li><a href=\"/posts/d32a07a7/\">Git介绍以及分支模型图解</a></li>\n<li><a href=\"/posts/39563241/\">三万字无坑搭建基于Docker+K8S+GitLab/SVN+Jenkins+Harbor持续集成交付环境</a></li>\n<li><a href=\"/posts/3437994a/\">DevOps系列—【Jenkinsfile+Dockerfile+nginx+vue】</a></li>\n<li><a href=\"/posts/f4c3ad41/\">项目开发管理工具推荐</a></li>\n<li><a href=\"/posts/acc13b70/\">Gitlab的安装及使用教程完全版</a></li>\n<li><a href=\"/posts/d08eb7b/\">Gitlab的安装及使用</a></li>\n<li><a href=\"/posts/78c3371/\">那些有用的Github工具介绍！Action、app、workflow等</a></li>\n</ul>\n",
            "tags": [
                "nginx",
                "jenkins",
                "devops"
            ]
        },
        {
            "id": "https://blog.17lai.site/posts/f4c3ad41/",
            "url": "https://blog.17lai.site/posts/f4c3ad41/",
            "title": "项目开发管理工具推荐",
            "date_published": "2022-04-15T10:48:59.000Z",
            "content_html": "<blockquote>\n<p>软件开发是复杂的创造性的劳动，需要依赖大量工具才能完成，因此想要提高软件开发的效率和质量，离不开强大、高效、易用、维护成本低的工具，下面我根据自己的经验，推荐一些好用的工具。</p>\n</blockquote>\n<h2 id=\"即时通讯\">即时通讯</h2>\n<blockquote>\n<p>更推荐自建开源替代。</p>\n</blockquote>\n<p>即时通讯和会议系统是项目开发过程中必不可少的，尤其是远程办公时，会议系统更是不可或缺。企业微信拥有和微信一致的沟通体验，简单易用。企业微信可随时随地发起和参与音视频会议，支持300人同时参会，并为主持人提供了管理功能。发言时还可演示文档或电脑屏幕，支持实时标注演示内容。</p>\n<p><img src=\"https://cimg1.17lai.site/data/2022/04/1520220415205156.png\" alt=\"gitea\"></p>\n<p>官方网站：<a href=\"https://work.weixin.qq.com/\">https://work.weixin.qq.com/</a></p>\n<h2 id=\"项目管理\">项目管理</h2>\n<p>目前主流的项目管理通常采用敏捷开发的模式，因此项目管理工具也要选择支持敏捷开发模式的工具，不建议使用禅道这样的重流程的工具，不适合敏捷团队，这里我推荐Taiga，它设计简洁，操作简单，充分体现了敏捷开发的理念。</p>\n<p><img src=\"https://cimg1.17lai.site/data/2022/04/1520220415211820.png\" alt=\"gitea\"></p>\n<p>官方网站：<a href=\"https://taiga.io/\">https://taiga.io</a></p>\n<p>在线体验：<a href=\"https://tree.taiga.io/\">https://tree.taiga.io</a></p>\n<p>体验版服务器在国外，访问可能会有点慢。</p>\n<h2 id=\"代码托管\">代码托管</h2>\n<p>前几年使用的比较多是SVN，近几年基本都使用GIT了，开源项目大都使用Github，虽然免费，但国内访问不稳定，速度慢，因此国内的公司基本都会自己搭建，我先后为公司搭建过两个托管平台，一个是Gitlab，一个是Gitea，Gitlab功能比较全面，但对硬件资源要求比较高，而且性能一般。所以推荐使用另一个开源的git托管平台——Gitea。</p>\n<p><img src=\"https://cimg1.17lai.site/data/2022/04/1520220415212537.png\" alt=\"gitea\"></p>\n<p>官方网站：<a href=\"https://gitea.io/\">https://gitea.io</a></p>\n<p>在线体验：<a href=\"https://gitea.com/\">https://gitea.com</a></p>\n<h2 id=\"持续交付\">持续交付</h2>\n<p>最知名、使用最广泛的开源的持续集成、交付平台当属Jenkins，主要的优势在于有大量免费的插件可以使用，但实际使用发现，很多插件质量很差，配置项很多，真正想要落地，其实需要自己编写shell脚本。这里我推荐基于docker技术的一款现代化的持续交付平台DroneCI，它使用简单，可以和主流的Git代码托管平台无缝对接，并且不需要编写代码就可以满足大多数持续构建、交付的需求。</p>\n<p><img src=\"https://cimg1.17lai.site/data/2022/04/1520220415212440.png\" alt=\"gitea\"></p>\n<p>官方网站：<a href=\"https://drone.io/\">https://drone.io</a></p>\n<p>在线体验：<a href=\"https://cloud.drone.io/\">https://cloud.drone.io</a></p>\n<p>体验版服务器在国外，访问可能会有点慢。</p>\n<h2 id=\"制品库-本地仓库\">制品库(本地仓库)</h2>\n<p>Maven 仓库是项目中依赖的第三方库，这个库所在的位置叫做仓库。Maven 仓库能帮助我们管理构件（主要是JAR），它就是放置所有JAR文件（WAR，ZIP，POM等等）的地方。</p>\n<p>后来，除了Maven仓库，还有npm、nuget、pypi、docker等仓库也需要本地仓库。</p>\n<p>市面上可选的通用的本地仓库有：nexus、ARTIFACTORY，ARTIFACTORY是收费的，nexus是免费的，同时nexus以其易用性和可靠性，成为目前市场上最主流的本地仓库。</p>\n<p>官方网站：<a href=\"https://www.sonatype.com/product-nexus-repository\">https://www.sonatype.com/product-nexus-repository</a></p>\n<h2 id=\"文件存储\">文件存储</h2>\n<p>在公司中，文件分享是一个很常用的功能，不同于云盘，他对性能和安全性没有那么高的要求，简单易用才是大家最关心的，这里推荐chfs，chfs是一个免费的、HTTP协议的文件共享服务器，使用浏览器可以快速访问。与其他常用文件共享方式（如FTP，飞秋，网盘，自己建站）相比，具有使用简单，适用场景更多的优点，在个人使用以及共享给他人的场景中非常方便快捷。</p>\n<p>官方网站：<a href=\"http://iscute.cn/chfs\">http://iscute.cn/chfs</a></p>\n<h2 id=\"绘图-流程图、UML、思维导图\">绘图(流程图、UML、思维导图)</h2>\n<p><a href=\"http://draw.io\">draw.io</a> 是一个强大简洁的在线的绘图网站，支持流程图，UML图，架构图，原型图等。支持Github，Google Drive, One drive等网盘同步，并且永久免费。如果觉得使用Web版不方便，<a href=\"http://draw.io\">draw.io</a> 也提供了多平台的离线桌面版可供下载。</p>\n<p><img src=\"https://cimg1.17lai.site/data/2022/04/1520220415205300.png\" alt=\"img\"></p>\n<p>在线版：<a href=\"https://www.draw.io/\">https://www.draw.io</a></p>\n<p>本地部署版：<a href=\"https://github.com/jgraph/drawio/releases/latest\">https://github.com/jgraph/drawio/releases/latest</a></p>\n<p>PC 安装版：<a href=\"https://github.com/jgraph/drawio-desktop/releases/latest\">https://github.com/jgraph/drawio-desktop/releases/latest</a></p>\n<h2 id=\"接口管理\">接口管理</h2>\n<p>维护不同工具之间数据一致性非常困难、低效。并且这里不仅仅是工作量的问题，更大的问题是多个系统之间数据不一致，导致协作低效、频繁出问题，开发测试人员痛苦不堪。</p>\n<p>Apifox 是接口管理、开发、测试全流程集成工具，定位 Postman + Swagger + Mock + JMeter。通过一套系统、一份数据，解决多个系统之间的数据同步问题。只要定义好接口文档，接口调试、数据 Mock、接口测试就可以直接使用，无需再次定义；接口文档和接口开发调试使用同一个工具，接口调试完成后即可保证和接口文档定义完全一致。高效、及时、准确！</p>\n<p><img src=\"https://cimg1.17lai.site/data/2022/04/1520220415205213.svg+xml\" alt=\"gitea\"></p>\n<p>官方网站：<a href=\"https://www.apifox.cn/\">https://www.apifox.cn</a></p>\n<h2 id=\"安全测试\">安全测试</h2>\n<p>在今天，网站的安全是容易被忽视的，黑客具备广泛的攻击手段，例如SQL注入，XSS，文件包含，目录遍历，参数篡改，认证攻击等，虽然你配置了正确的防火墙和WAF，但是这些安全防御软件仍然存在策略性的绕过。因此，需要您定期的扫描你的web应用，但是手动检测你所有的web应用是否存在安全漏洞比较复杂和费时，所以您需要一款自动化的web漏洞扫描工具来检测您的web应用是否存在安全漏洞。</p>\n<p>Acunetix Web Vulnerability Scanner（简称AWVS）是一款知名的Web网络漏洞扫描工具，它通过网络爬虫测试你的网站安全，检测流行安全漏洞。</p>\n<p><img src=\"https://cimg1.17lai.site/data/2022/04/1520220415205220.svg+xml\" alt=\"awvs\"></p>\n<p>官方网站：<a href=\"https://www.acunetix.com/\">https://www.acunetix.com</a></p>\n<h2 id=\"性能测试\">性能测试</h2>\n<p>Locust是一个用于可扩展的，分布式的，性能测试的，开源的，用Python编写框架/工具，它非常容易使用，也非常好学。</p>\n<p>它的主要思想就是模拟一群用户将访问你的网站。每个用户的行为由你编写的python代码定义，同时可以从Web界面中实时观察到用户的行为。</p>\n<p>Locust完全是事件驱动的，因此在单台机器上能够支持几千并发用户访问。</p>\n<p>与其它许多基于事件的应用相比，Locust并不使用回调，而是使用gevent，而gevent是基于协程的，可以用同步的方式来编写异步执行的代码。</p>\n<p><img src=\"https://cimg1.17lai.site/data/2022/04/1520220415205227.png\" alt=\"awvs\"></p>\n<p>官方网站：<a href=\"https://www.locust.io/\">https://www.locust.io</a></p>\n<h2 id=\"代码静态分析平台\">代码静态分析平台</h2>\n<p>SonarQube 是一款用于代码质量管理的开源工具，它主要用于管理源代码的质量。 通过插件形式，可以支持众多计算机语言，比如 java, C#, go，C/C++, PL/SQL, Cobol, JavaScrip, Groovy 等。sonar可以通过PMD,CheckStyle,Findbugs等等代码规则检测工具来检测你的代码，帮助你发现代码的漏洞，Bug，异味等信息。</p>\n<p>Sonar 不仅提供了对 IDE 的支持，可以在 Eclipse和 IntelliJ IDEA 这些工具里联机查看结果；同时 Sonar 还对大量的持续集成工具提供了接口支持，可以很方便地在持续集成中使用 Sonar</p>\n<p><img src=\"https://cimg1.17lai.site/data/2022/04/1520220415205228.svg\" alt=\"awvs\"></p>\n<p>官方网站：<a href=\"https://www.sonarqube.org/\">https://www.sonarqube.org</a></p>\n<h2 id=\"系列教程\"><strong>系列教程</strong></h2>\n<p><a href=\"/atom.xml\"><i class=\"fas fa-rss\"></i>全部文章RSS订阅</a></p>\n<h3 id=\"Devops系列\"><strong>Devops系列</strong></h3>\n<p><a href=\"/categories/devops/atom.xml\"><i class=\"fas fa-rss\"></i><strong>Devops 分类 RSS 订阅</strong></a></p>\n<ul>\n<li><a href=\"/posts/ab63eb8f/\">自建全套开源Devops开发系统</a></li>\n<li><a href=\"/posts/d32a07a7/\">Git介绍以及分支模型图解</a></li>\n<li><a href=\"/posts/39563241/\">三万字无坑搭建基于Docker+K8S+GitLab/SVN+Jenkins+Harbor持续集成交付环境</a></li>\n<li><a href=\"/posts/3437994a/\">DevOps系列—【Jenkinsfile+Dockerfile+nginx+vue】</a></li>\n<li><a href=\"/posts/f4c3ad41/\">项目开发管理工具推荐</a></li>\n<li><a href=\"/posts/acc13b70/\">Gitlab的安装及使用教程完全版</a></li>\n<li><a href=\"/posts/d08eb7b/\">Gitlab的安装及使用</a></li>\n<li><a href=\"/posts/78c3371/\">那些有用的Github工具介绍！Action、app、workflow等</a></li>\n</ul>\n",
            "tags": [
                "ci/cd",
                "devops"
            ]
        },
        {
            "id": "https://blog.17lai.site/posts/acc13b70/",
            "url": "https://blog.17lai.site/posts/acc13b70/",
            "title": "Gitlab的安装及使用教程完全版",
            "date_published": "2021-08-02T08:25:00.000Z",
            "content_html": "<h2 id=\"1-Gitlab概述\">1. Gitlab概述</h2>\n<hr>\n<h3 id=\"1-1-GitLab介绍\">1.1 GitLab介绍</h3>\n<p>GitLab是利用Ruby on Rails一个开源的版本管理系统，实现一个自托管的Git项目仓库，可通过Web界面进行访问公开的或者私人项目。</p>\n<p>GitLab能够浏览源代码，管理缺陷和注释。可以管理团队对仓库的访问，它非常易于浏览提交过的版本并提供一个文件历史库。团队成员可以利用内置的简单聊天程序(Wall)进行交流。</p>\n<p>它还提供一个代码片段收集功能可以轻松实现代码复用，便于日后有需要的时候进行查找</p>\n<h3 id=\"1-2-Gitlab服务构成\">1.2 Gitlab服务构成</h3>\n<p>Nginx：静态web服务器。</p>\n<p>gitlab-shell：用于处理Git命令和修改authorized keys列表。</p>\n<p>gitlab-workhorse: 轻量级的反向代理服务器。</p>\n<p>logrotate：日志文件管理工具。</p>\n<p>postgresql：数据库。</p>\n<p>redis：缓存数据库。</p>\n<p>sidekiq：用于在后台执行队列任务（异步执行）。</p>\n<p>unicorn：An HTTP server for Rack applications，GitLab Rails应用是托管在这个服务器上面的。</p>\n<h3 id=\"1-3-Gitlab工作流程\">1.3 Gitlab工作流程</h3>\n<p><img src=\"https://cimg1.17lai.site/data/2021/05/2820210528222044.png\" alt=\"\"></p>\n<h3 id=\"1-4-GitLab-Shell\">1.4 GitLab Shell</h3>\n<p>GitLab Shell有两个作用：为GitLab处理Git命令、修改authorized keys列表</p>\n<p>当通过SSH访问GitLab Server时，GitLab Shell会：</p>\n<ul>\n<li>限制执行预定义好的Git命令（git push，git pull，git annex）</li>\n<li>调用GitLab Rails API检查权限</li>\n<li>执行pre-receive钩子（在企业版中叫做Git钩子）</li>\n<li>执行用户请求的动作，处理GitLab的post-receive动作</li>\n<li>处理自定义的post-receive动作</li>\n</ul>\n<p>当通过http(s)访问GitLab Server时，工作流程取决于你是从Git仓库拉取(pull)代码还是向git仓库推送(push)代码：</p>\n<p>如果是从Git仓库拉取(pull)代码，GitLab Rails应用会全权负责处理用户鉴权和执行Git命令的工作</p>\n<p>如果是向Git仓库推送(push)代码，GitLab Rails应用既不会进行用户鉴权也不会执行Git命令，它会把以下工作交由GitLab Shell进行处理：</p>\n<ul>\n<li>调用GitLab Rails API 检查权限</li>\n<li>执行pre-receive钩子（在GitLab企业版中叫做Git钩子）</li>\n<li>执行你请求的动作</li>\n<li>处理GitLab的post-receive动作</li>\n<li>处理自定义的post-receive动作</li>\n</ul>\n<h3 id=\"1-5-GitLab-Workhorse\">1.5 GitLab Workhorse</h3>\n<p>GitLab Workhorse是一个敏捷的反向代理。它会处理一些大的HTTP请求，比如文件上传、文件下载、Git push/pull和Git包下载。其它请求会反向代理到GitLab Rails应用，即反向代理给后端的unicorn。</p>\n<h2 id=\"2-Gitlab的安装部署\">2. Gitlab的安装部署</h2>\n<ul>\n<li>Gitlab要求服务器内存2G以上</li>\n</ul>\n<h3 id=\"2-1-方式一-下载gitlab-ce的rpm包\">2.1 方式一:下载gitlab-ce的rpm包</h3>\n<ul>\n<li><a href=\"https://packages.gitlab.com/gitlab/gitlab-ce\">gitlab官方rpm包下载</a></li>\n<li><a href=\"https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el7/\">清华的源</a></li>\n</ul>\n<p>将对应版本的gitlab-ce下载到本地后，直接yum安装即可</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"># 要先将这个rpm包下载到本地\nyum install -y gitlab-ce-13.6.1-ce.0.el7.x86_64.rpm</code></pre></div></figure>\n<h3 id=\"2-2-方式二-配置yum源\">2.2 方式二:配置yum源</h3>\n<p>在 /etc/yum.repos.d/ 下新建 gitlab-ce.repo，写入如下内容：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">[gitlab-ce]\nname=gitlab-ce\nbaseurl=https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el7/\nRepo_gpgcheck=0\nEnabled=1\nGpgkey=https://packages.gitlab.com/gpg.key</code></pre></div></figure>\n<p>然后创建cache，再直接安装gitlab-ce</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">yum makecache  # 这一步会创建大量的数据\n \n# 直接安装最新版\nyum install -y gitlab-ce\n \n# 如果要安装指定的版本，在后面填上版本号即可\nyum install -y  gitlab-ce-13.6.1\n \n# 如果安装时出现gpgkey验证错误，只需在安装时明确指明不进行gpgkey验证\nyum install gitlab-ce -y --nogpgcheck</code></pre></div></figure>\n<h3 id=\"2-2-1-单服务启动模式\"><strong>2.2.1. 单服务启动模式</strong></h3>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">docker run -d --name gitlab --hostname gitlab.example.com \\\n-e GITLAB_OMNIBUS_CONFIG=\"\n    external_url 'https://gitlab.example.com'\n    gitlab_rails['gitlab_shell_ssh_port'] = 22\n    nginx['redirect_http_to_https'] = true\n    nginx['ssl_dhparam'] = '/etc/gitlab/ssl/dhparam.pem'\n    nginx['ssl_certificate'] = '/etc/gitlab/ssl/domain.crt'\n    nginx['ssl_certificate_key'] = '/etc/gitlab/ssl/domain.key'\n    nginx['custom_gitlab_server_config'] = 'location ^~ /.well-known {\\n alias /var/opt/gitlab/letsencrypt/.well-known;\\n}\\n'\n    high_availability['mountpoint'] = ['/etc/gitlab', '/var/log/gitlab' '/var/opt/gitlab'  # 严格限定gitlab服务启动前，指定文件系统挂完毕\n\" \\\n-p 22:22 -p 80:80 -p 443:443 \\\n-v /srv/gitlab/config:/etc/gitlab \\\n-v /srv/gitlab/logs:/var/log/gitlab \\\n-v /srv/gitlab/data:/var/opt/gitlab \\\n-v /etc/certs:/etc/gitlab/ssl \\\n--restart=always gitlab/gitlab-ce:latest\n </code></pre></div></figure>\n<h3 id=\"2-2-1-Compose服务编排模式-推荐方式\"><strong>2.2.1. Compose服务编排模式(推荐方式)</strong></h3>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">docker pull gitlab/gitlab-ce:latest\n \n############################ 多行命令开始 ##########################\ncat &gt; docker-compose.yaml &lt;&lt;EOF\nversion: '2'\n \nservices:\n \n  Gitlab:\n    image: 'gitlab/gitlab-ce:latest'\n    container_name: 'gitlab'\n    hostname: 'gitlab.example.com'\n    restart: always\n    ports:\n      - '22:22'\n      - '80:80'\n      - '443:443'\n    environment:\n      GITLAB_OMNIBUS_CONFIG: |\n        # Add any other gitlab.rb configuration here, each on its own line\n        external_url 'https://gitlab.example.com'\n        gitlab_rails['gitlab_shell_ssh_port'] = 22\n        nginx['redirect_http_to_https'] = true\n        nginx['ssl_dhparam'] = \"/etc/gitlab/ssl/dhparam.pem\"\n        nginx['ssl_certificate'] = \"/etc/gitlab/ssl/domain.crt\"\n        nginx['ssl_certificate_key'] = \"/etc/gitlab/ssl/domain.key\"\n        nginx['custom_gitlab_server_config'] = \"location ^~ /.well-known {\\n alias /var/opt/gitlab/letsencrypt/.well-known;\\n}\\n\"\n        high_availability['mountpoint'] = [\"/etc/gitlab\", \"/var/log/gitlab\", \"/var/opt/gitlab\"]  # 严格限定gitlab服务启动前，指定文件系统挂完毕\n    volumes:\n      - /srv/gitlab/config:/etc/gitlab\n      - /srv/gitlab/logs:/var/log/gitlab\n      - /srv/gitlab/data:/var/opt/gitlab\n      - /etc/certs:/etc/gitlab/ssl\nEOF\n############################ 多行命令结束 ##########################\n \n# 启动服务\ndocker-compose -f docker-compose.yaml up -d\n </code></pre></div></figure>\n<h3 id=\"2-3-gitlab的配置\">2.3 gitlab的配置</h3>\n<p>配置文件位置  /etc/gitlab/gitlab.rb</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">[root@centos7 test]# vim /etc/gitlab/gitlab.rb\n \n[root@centos7 test]# grep \"^[a-Z]\" /etc/gitlab/gitlab.rb\n \nexternal_url 'http://10.0.0.51'  # 这里一定要加上http://\n \n# 配置邮件服务\ngitlab_rails['smtp_enable'] = true\ngitlab_rails['smtp_address'] = \"smtp.qq.com\"\ngitlab_rails['smtp_port'] = 25\ngitlab_rails['smtp_user_name'] = \"hgzerowzh@qq.com\"  # 自己的qq邮箱账号\ngitlab_rails['smtp_password'] = \"xxx\"  # 开通smtp时返回的授权码\ngitlab_rails['smtp_domain'] = \"qq.com\"\ngitlab_rails['smtp_authentication'] = \"login\"\ngitlab_rails['smtp_enable_starttls_auto'] = true\ngitlab_rails['smtp_tls'] = false\ngitlab_rails['gitlab_email_from'] = \"hgzerowzh@qq.com\"  # 指定发送邮件的邮箱地址\nuser[\"git_user_email\"] = \"shit@qq.com\"   # 指定接收邮件的邮箱地址</code></pre></div></figure>\n<p><strong>修改好配置文件后，要使用 gitlab-ctl reconfigure 命令重载一下配置文件，否则不生效。</strong></p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">gitlab-ctl reconfigure # 重载配置文件\ngitlab-ctl restart</code></pre></div></figure>\n<h4 id=\"测试邮件服务器\">测试邮件服务器</h4>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">gitlab-rails console\nNotify.test_email('rollinghell@foxmail.com','testbiaoti','testzhegnwen1').deliver_now</code></pre></div></figure>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">[root@test102 ~]# gitlab-rails console\n--------------------------------------------------------------------------------\n GitLab:       12.5.0 (1f0ab8978ef)\nGitLab Shell: 10.2.0\n PostgreSQL:   10.9\n--------------------------------------------------------------------------------\nLoading production environment (Rails 5.2.3)\nirb(main):001:0&gt; Notify.test_email('andycrusoe@gmail.com','test','test').deliver_now\nNotify#test_email: processed outbound mail in 1.4ms\nSent mail to anliven@126.com (73.0ms)\nDate: Wed, 27 Nov 2019 15:12:58 +0800\nFrom: GitLab &lt;gitlab@192.168.16.102&gt;\nReply-To: GitLab &lt;noreply@192.168.16.102&gt;\nTo: anliven@126.com\nMessage-ID: &lt;5dde21fa612d4_3a1b3fcb38fcf9c0651b@test102.mail&gt;\nSubject: test\nMime-Version: 1.0\nContent-Type: text/html;\ncharset=UTF-8\nContent-Transfer-Encoding: 7bit\nAuto-Submitted: auto-generated\nX-Auto-Response-Suppress: All\n&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\" \"http://www.w3.org/TR/REC-html40/loose.dtd\"&gt;\n&lt;html&gt;&lt;body&gt;&lt;p&gt;test&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;\n=&gt; #&lt;Mail::Message:70141649239780, Multipart: false, Headers: &lt;Date: Wed, 27 Nov 2019 15:12:58 +0800&gt;, &lt;From: GitLab &lt;gitlab@192.168.16.102&gt;&gt;, &lt;Reply-To: GitLab &lt;noreply@192.168.16.102&gt;&gt;, &lt;To: anliven@126.com&gt;, &lt;Message-ID: &lt;5dde21fa612d4_3a1b3fcb38fcf9c0651b@test102.mail&gt;&gt;, &lt;Subject: test&gt;, &lt;Mime-Version: 1.0&gt;, &lt;Content-Type: text/html; charset=UTF-8&gt;, &lt;Content-Transfer-Encoding: 7bit&gt;, &lt;Auto-Submitted: auto-generated&gt;, &lt;X-Auto-Response-Suppress: All&gt;&gt;\nirb(main):002:0&gt;\nirb(main):003:0&gt; exit\n[root@test102 ~]#\n </code></pre></div></figure>\n<h4 id=\"配置gitlab代理\">配置gitlab代理</h4>\n<blockquote>\n<ul>\n<li><a href=\"https://docs.gitlab.com/omnibus/settings/environment-variables.html\">Setting custom environment variables | GitLab</a></li>\n<li><a href=\"https://docs.gitlab.com/ee/administration/logs/index.html#update_mirror_service_jsonlog\">Log system | GitLab</a></li>\n</ul>\n</blockquote>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-ruby\" data-language=\"ruby\"><code class=\"language-ruby\">gitaly['env'] = {\n    \"http_proxy\" =&gt; \"http://USERNAME:PASSWORD@example.com:8080\",\n    \"https_proxy\" =&gt; \"http://USERNAME:PASSWORD@example.com:8080\"\n}</code></pre></div></figure>\n<p>也可以使用单独模块代理</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-ruby\" data-language=\"ruby\"><code class=\"language-ruby\"># Needed for proxying Git clones\ngitaly['env'] = {\n    \"http_proxy\" =&gt; \"http://USERNAME:PASSWORD@example.com:8080\",\n    \"https_proxy\" =&gt; \"http://USERNAME:PASSWORD@example.com:8080\"\n}\n\ngitlab_workhorse['env'] = {\n    \"http_proxy\" =&gt; \"http://USERNAME:PASSWORD@example.com:8080\",\n    \"https_proxy\" =&gt; \"http://USERNAME:PASSWORD@example.com:8080\"\n}\n\ngitlab_pages['env'] = {\n    \"http_proxy\" =&gt; \"http://USERNAME:PASSWORD@example.com:8080\",\n    \"https_proxy\" =&gt; \"http://USERNAME:PASSWORD@example.com:8080\"\n}\n\n# If you use the docker registry\nregistry['env'] = {\n    \"http_proxy\" =&gt; \"http://USERNAME:PASSWORD@example.com:8080\",\n    \"https_proxy\" =&gt; \"http://USERNAME:PASSWORD@example.com:8080\"\n}</code></pre></div></figure>\n<p>应用生效 <code>gitlab-ctl reconfigure</code></p>\n<h3 id=\"2-4-Gitlab常用命令\">2.4 Gitlab常用命令</h3>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">gitlab-ctl start         # 启动所有 gitlab 组件\ngitlab-ctl stop          # 停止所有 gitlab 组件\ngitlab-ctl restart       # 重启所有 gitlab 组件\ngitlab-ctl status        # 查看服务状态\n \ngitlab-ctl reconfigure   # 启动服务\ngitlab-ctl show-config   # 验证配置文件\n \ngitlab-ctl tail          # 查看日志\n \ngitlab-rake gitlab:check SANITIZE=true --trace    # 检查gitlab\n \nvim /etc/gitlab/gitlab.rb # 修改默认的配置文件</code></pre></div></figure>\n<h3 id=\"2-5-gitlab-ctl常用命令介绍\">2.5 gitlab-ctl常用命令介绍</h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:right\">命令</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:right\">check-config</td>\n<td>检查在gitlab中是否有任何配置。在指定版本中删除的rb</td>\n</tr>\n<tr>\n<td style=\"text-align:right\">deploy-page</td>\n<td>安装部署页面</td>\n</tr>\n<tr>\n<td style=\"text-align:right\">diff-config</td>\n<td>将用户配置与包可用配置进行比较</td>\n</tr>\n<tr>\n<td style=\"text-align:right\">remove-accounts</td>\n<td>删除所有用户和组</td>\n</tr>\n<tr>\n<td style=\"text-align:right\">upgrade</td>\n<td>升级</td>\n</tr>\n<tr>\n<td style=\"text-align:right\">service-list</td>\n<td>查看所有服务</td>\n</tr>\n<tr>\n<td style=\"text-align:right\">once</td>\n<td>如果GitLab服务停止了就启动服务，如果已启动就不做任何操作</td>\n</tr>\n<tr>\n<td style=\"text-align:right\">restart</td>\n<td>重启GitLab服务</td>\n</tr>\n<tr>\n<td style=\"text-align:right\">start</td>\n<td>如果GitLab服务停止了就启动服务，如果已启动就重启服务</td>\n</tr>\n<tr>\n<td style=\"text-align:right\">stop</td>\n<td>停止GitLab服务</td>\n</tr>\n<tr>\n<td style=\"text-align:right\">status</td>\n<td>查看GitLab服务状态</td>\n</tr>\n<tr>\n<td style=\"text-align:right\">reconfigure</td>\n<td>重新配置GitLab并启动</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"3-Gitlab的使用\">3. Gitlab的使用</h2>\n<ul>\n<li>Gitlab安装好后，设置密码，管理账户为root</li>\n</ul>\n<h3 id=\"3-1-创建Group\"><strong>3.1 创建Group</strong></h3>\n<ul>\n<li>填上组名即可，这里组名为java</li>\n</ul>\n<p><img src=\"https://cimg1.17lai.site/data/2021/05/2820210528222105.png\" alt=\"\"></p>\n<p><img src=\"https://cimg1.17lai.site/data/2021/08/0220210802164637.png\" alt=\"\"></p>\n<h3 id=\"3-2-创建User\"><strong>3.2 创建User</strong></h3>\n<ul>\n<li>创建四个User：pm、dev1、dev2、dev3</li>\n</ul>\n<p><img src=\"https://cimg1.17lai.site/data/2021/05/2820210528222131.png\" alt=\"\"></p>\n<p><img src=\"https://cimg1.17lai.site/data/2021/05/2820210528222120.png\" alt=\"\"></p>\n<h3 id=\"3-3-添加User到Group中并授权\"><strong>3.3 添加User到Group中并授权</strong></h3>\n<p><img src=\"https://cimg1.17lai.site/data/2021/05/2820210528222140.png\" alt=\"\"></p>\n<h3 id=\"3-4-创建Project并配置SSH\"><strong>3.4 创建Project并配置SSH</strong></h3>\n<p><img src=\"https://cimg1.17lai.site/data/2021/05/2820210528222147.png\" alt=\"\"></p>\n<p><img src=\"https://cimg1.17lai.site/data/2021/05/2820210528222154.png\" alt=\"\"></p>\n<p><img src=\"https://cimg1.17lai.site/data/2021/05/2820210528222201.png\" alt=\"\"></p>\n<p><img src=\"https://cimg1.17lai.site/data/2021/05/2820210528222233.png\" alt=\"\"></p>\n<h3 id=\"3-5-在项目中添加成员\"><strong>3.5 在项目中添加成员</strong></h3>\n<p><img src=\"https://cimg1.17lai.site/data/2021/08/0220210802164730.png\" alt=\"\"></p>\n<p><img src=\"https://cimg1.17lai.site/data/2021/08/0220210802164804.png\" alt=\"\"></p>\n<h3 id=\"3-6-将本地文件推送到Gitlab\">3.6 将本地文件推送到Gitlab</h3>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"># 将app01项目克隆下来\ngit clone git@10.0.0.51:java/app01.git\n \n# 初始化配置\ngit config --global user.name \"hgzero\"\ngit config --global user.email \"hgzero@qq.com\"\n \n# 在app01目录下新建一些文件\n \n# 推送到gitlab\ngit add .\ngit commit -m \"first edition\"\ngit push origin master</code></pre></div></figure>\n<p><img src=\"https://cimg1.17lai.site/data/2021/08/0220210802164823.png\" alt=\"\"></p>\n<h2 id=\"4-制定开发计划\">4. 制定开发计划</h2>\n<h3 id=\"4-1-创建开发计划\"><strong>4.1 创建开发计划</strong></h3>\n<ul>\n<li>项目：app01</li>\n<li>版本：v1.0</li>\n</ul>\n<p><img src=\"https://cimg1.17lai.site/data/2021/08/0220210802173643.png\" alt=\"\"></p>\n<h3 id=\"4-2-创建里程碑Milestones\"><strong>4.2 创建里程碑Milestones</strong></h3>\n<ul>\n<li>用pm账号登录gitlab后操作（先要在admin中设置pm账号的密码）</li>\n<li>要根据开发计划来创建Milestones</li>\n</ul>\n<p><img src=\"https://cimg1.17lai.site/data/2021/08/0220210802164839.png\" alt=\"\"></p>\n<p><img src=\"https://cimg1.17lai.site/data/2021/08/0220210802164935.png\" alt=\"\"></p>\n<p><img src=\"https://cimg1.17lai.site/data/2021/08/0220210802164956.png\" alt=\"\"></p>\n<p><img src=\"https://cimg1.17lai.site/data/2021/08/0220210802165053.png\" alt=\"\"></p>\n<h3 id=\"4-3-根据开发计划创建issue\">4.3 根据开发计划创建issue</h3>\n<ul>\n<li>创建4个issue，分派给dev1和dev2这两个开发人员</li>\n</ul>\n<p><img src=\"https://cimg1.17lai.site/data/2021/08/0220210802165109.png\" alt=\"\"></p>\n<p><img src=\"https://cimg1.17lai.site/data/2021/08/0220210802165138.png\" alt=\"\"></p>\n<p><img src=\"https://cimg1.17lai.site/data/2021/08/0220210802165158.png\" alt=\"\"></p>\n<p><img src=\"https://cimg1.17lai.site/data/2021/08/0220210802165215.png\" alt=\"\"></p>\n<p><img src=\"https://cimg1.17lai.site/data/2021/08/0220210802165238.png\" alt=\"\"></p>\n<p><img src=\"https://cimg1.17lai.site/data/2021/08/0220210802165257.png\" alt=\"\"></p>\n<h3 id=\"4-4-开发者登录账号查看分派的任务\">**4.4 开发者登录账号查看分派的任务 **</h3>\n<ul>\n<li>然后开发dev1登录gitlab，就能看到任务已经分配过来了</li>\n</ul>\n<p><img src=\"https://cimg1.17lai.site/data/2021/08/0220210802165316.png\" alt=\"\"></p>\n<h3 id=\"4-5-开发流程\"><strong>4.5 开发流程</strong></h3>\n<ul>\n<li>公司里的开发开始任务</li>\n</ul>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"># 1. 先从仓库把项目拉下来\ngit clone git@10.0.0.51:java/app01.git\ncd app01/\n \n# 2.先创建一个自己的分支，然后进行开发\ngit checkout -b index   # 创建一个叫index的分支，并切换到这个分支\ngit status\n \n# 3. 开始开发首页\necho \"&lt;h1&gt;welcome to this app&lt;/h1&gt;\" &gt; index.html  # 假设就开发了一个index页面\n \n# 4. 开发完成后，把项目传到仓库\ngit add .\ngit commit -m \"index\"\n# 如果写成 git commit -m \"close #2\" ，则表示merge请求允许且merge成功之后，自动删除编号为#2的issue\n \n# 传到index分支\ngit push origin index</code></pre></div></figure>\n<h3 id=\"4-6-合并分支\"><strong>4.6 合并分支</strong></h3>\n<p><strong>1）开发dev1发送合并分支请求给pm</strong></p>\n<p><img src=\"https://cimg1.17lai.site/data/2021/08/0220210802165333.png\" alt=\"\"></p>\n<p><img src=\"https://cimg1.17lai.site/data/2021/08/0220210802165341.png\" alt=\"\"></p>\n<p><img src=\"https://cimg1.17lai.site/data/2021/08/0220210802165350.png\" alt=\"\"></p>\n<p><strong>2）pm收到开发的Merge请求后进行处理</strong></p>\n<ul>\n<li>使用pm登录，就可以看到pm已经收到了合并请求merge request</li>\n</ul>\n<p><img src=\"https://cimg1.17lai.site/data/2021/08/0220210802165452.png\" alt=\"\"></p>\n<p><img src=\"https://cimg1.17lai.site/data/2021/08/0220210802165505.png\" alt=\"\"></p>\n<p><img src=\"https://cimg1.17lai.site/data/2021/08/0220210802165423.png\" alt=\"\"></p>\n<p><img src=\"https://cimg1.17lai.site/data/2021/08/0220210802164313.png\" alt=\"\"></p>\n<p><strong>3）开发dev1确认任务完成</strong></p>\n<ul>\n<li>退出pm账户，登入dev1账户：</li>\n</ul>\n<p><img src=\"https://cimg1.17lai.site/data/2021/08/0220210802164301.png\" alt=\"\"></p>\n<ul>\n<li>或者点进去后，在侧边栏进行标识Done，然后已经完成的issue，可以将其Close</li>\n</ul>\n<p><img src=\"https://cimg1.17lai.site/data/2021/08/0220210802164248.png\" alt=\"\"></p>\n<ul>\n<li>这个时候Milestones的进度已经往前进了一些了：</li>\n</ul>\n<p><img src=\"https://cimg1.17lai.site/data/2021/08/0220210802164237.png\" alt=\"\"></p>\n<h3 id=\"4-7-开发其他功能\">4.7 开发其他功能</h3>\n<ul>\n<li>然后其他开发者或者自己再次进行开发时，先要把刚刚更新后的内容（master主干）拉回来，然后再进行开发</li>\n</ul>\n<p>git checkout master  # 切换到master<br>\ngit pull             # 从远端仓库拉取数据<br>\n# 然后再进行其他操作</p>\n<h2 id=\"5-Gitlab备份恢复\">5. Gitlab备份恢复</h2>\n<h3 id=\"5-1-备份gitlab\">5.1 备份gitlab</h3>\n<p><strong>1）修改配置文件</strong></p>\n<ul>\n<li><strong>/etc/gitlab/gitlab.rb</strong></li>\n</ul>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"># 备份保存的位置，这里是默认位置，可修改成指定的位置\ngitlab_rails['backup_path'] = \"/var/opt/gitlab/backups\"\n \n# 设置备份保存的时间，超过此时间的日志将会被新覆盖\ngitlab_rails['backup_keep_time'] = 604800  # 这里是默认设置，保存7天\n \n# 特别注意：\n#     如果自定义了备份保存位置，则要修改备份目录的权限，比如：\n#     chown -R git.git /data/backup/gitlab</code></pre></div></figure>\n<ul>\n<li>配置完成后要重启以使配置生效</li>\n</ul>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"># 重读配置文件\ngitlab-ctl reconfigure\n \n# 重启gitlab\ngitlab-ctl restart</code></pre></div></figure>\n<p><strong>2）设置定时任务</strong></p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"># 每天凌晨2点定时创建备份\n# 将一下内容写入到定时任务中 crontab -e\n0 2 * * * /usr/bin/gitlab-rake gitlab:backup:create\n \n# 备份策略建议：\n#     本地保留3到7天，在异地备份永久保存</code></pre></div></figure>\n<p><strong>3）备份时间的识别</strong></p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"># 备份后的文件类似这样的形式：1494170842_gitlab_backup.tar，可以根据前面的时间戳确认备份生成的时间\n \ndata  -d  @1494170842</code></pre></div></figure>\n<h3 id=\"5-2-恢复gitlab\">5.2 恢复gitlab</h3>\n<h4 id=\"1）停止停止相关数据连接-数据写入服务\"><strong>1）停止停止相关数据连接,数据写入服务</strong></h4>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"># 停止数据写入服务\ngitlab-ctl stop puma\ngitlab-ctl stop sidekiq</code></pre></div></figure>\n<h4 id=\"2）进行数据恢复并重启\"><strong>2）进行数据恢复并重启</strong></h4>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"># 进行恢复\ngitlab-rake gitlab:backup:restore BACKUP=1627839447_2021_08_01_14.1.1-ee  # 这个时间戳就是刚刚备份的文件前面的时间戳\n \n# 重启\ngitlab-ctl restart</code></pre></div></figure>\n<h2 id=\"6-gitlab邮件通知配置\">6. gitlab邮件通知配置</h2>\n<ul>\n<li>vim  /etc/gitlab/gitlab.rb</li>\n</ul>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">gitlab_rails['time_zone'] = 'Asia/Shanghai'\n \ngitlab_rails['gitlab_email_enabled'] = true\ngitlab_rails['gitlab_email_from'] = 'example@163.com' # 填写发件人的邮箱地址\ngitlab_rails['gitlab_email_display_name'] = 'gitlab'\n \ngitlab_rails['smtp_enable'] = true\ngitlab_rails['smtp_address'] = \"smtp.163.com\"  # smtp服务器的地址,如网易的地址\ngitlab_rails['smtp_port'] = 25                 # 要注意如果使用了SSL/TLS的话,端口可能不是25\ngitlab_rails['smtp_user_name'] = \"smtp用户名\"\ngitlab_rails['smtp_password'] = \"smtp用户密码\"\ngitlab_rails['smtp_domain'] = \"163.com\"\ngitlab_rails['smtp_authentication'] = \"login\"</code></pre></div></figure>\n<p><strong>启用邮件功能</strong><br>\nGitlab 的 Compose 配置 <code>GITLAB_OMNIBUS_CONFIG</code> 节点下增加如下几行：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">########## 邮件服务配置 ##########\ngitlab_rails['smtp_enable'] = true\ngitlab_rails['smtp_address'] = \"smtp.exmail.qq.com\"\ngitlab_rails['smtp_port'] = 465\ngitlab_rails['smtp_tls'] = true\ngitlab_rails['smtp_user_name'] = \"账号\"\ngitlab_rails['smtp_password'] = \"密码\"\ngitlab_rails['smtp_authentication'] = \"login\"\ngitlab_rails['smtp_enable_starttls_auto'] = true \ngitlab_rails['gitlab_email_from'] = \"发件人邮箱\"\n </code></pre></div></figure>\n<h2 id=\"7-使用SourceTree进行项目开发\">7. 使用SourceTree进行项目开发</h2>\n<hr>\n<h3 id=\"7-1-项目拉取\">7.1 项目拉取</h3>\n<ul>\n<li>先把项目克隆下来</li>\n</ul>\n<p><img src=\"https://cimg1.17lai.site/data/2021/08/0220210802164210.png\" alt=\"\"></p>\n<p><img src=\"https://cimg1.17lai.site/data/2021/08/0220210802164157.png\" alt=\"\"></p>\n<ul>\n<li>如果ssh的方式克隆失败，可能是因为SSH Key没找到，可以在这里添加</li>\n</ul>\n<p><img src=\"https://cimg1.17lai.site/data/2021/08/0220210802164146.png\" alt=\"\"></p>\n<p><img src=\"https://cimg1.17lai.site/data/2021/08/0220210802164132.png\" alt=\"\"></p>\n<h3 id=\"7-2-创建分支进行功能开发\">7.2 创建分支进行功能开发</h3>\n<p><strong>1）新建立一个叫“pay”的分支</strong></p>\n<p><img src=\"https://cimg1.17lai.site/data/2021/08/0220210802164122.png\" alt=\"\"></p>\n<p><img src=\"https://cimg1.17lai.site/data/2021/08/0220210802164113.png\" alt=\"\"></p>\n<p><strong>2）进行功能开发</strong></p>\n<p><img src=\"https://cimg1.17lai.site/data/2021/08/0220210802164103.png\" alt=\"\"></p>\n<h3 id=\"7-3-提交项目\">7.3 提交项目</h3>\n<p><strong>1）开发pay功能完成后进行提交</strong></p>\n<ul>\n<li>可以看到SourceTree中已经有“未提交的更改”</li>\n</ul>\n<p><img src=\"https://cimg1.17lai.site/data/2021/08/0220210802164054.png\" alt=\"\"></p>\n<p><img src=\"https://cimg1.17lai.site/data/2021/08/0220210802164042.png\" alt=\"\"></p>\n<p><strong>2）添加“用户信息”</strong></p>\n<p><img src=\"https://cimg1.17lai.site/data/2021/08/0220210802164029.png\" alt=\"\"></p>\n<p>** 3）进行提交**</p>\n<p><img src=\"https://cimg1.17lai.site/data/2021/08/0220210802164014.png\" alt=\"\"></p>\n<ul>\n<li>注释也可以写成  close #3    ，作用是提交完成后关闭3号issue</li>\n</ul>\n<h3 id=\"7-4-推送到仓库\"><strong>7.4 推送到仓库</strong></h3>\n<p><img src=\"https://cimg1.17lai.site/data/2021/08/0220210802164002.png\" alt=\"\"></p>\n<p><img src=\"https://cimg1.17lai.site/data/2021/08/0220210802163947.png\" alt=\"\"></p>\n<ul>\n<li>然后就可以在gitlab上进行发送merge请求了，后面就可以进行其他操作了</li>\n</ul>\n<h3 id=\"7-5-项目上线\">7.5 项目上线</h3>\n<p><strong>1）当所有工作完成之后，就可以进行上线了</strong></p>\n<p><img src=\"https://cimg1.17lai.site/data/2021/08/0220210802163932.png\" alt=\"\"></p>\n<p><strong>2）打标签</strong></p>\n<ul>\n<li>上线先打个标签</li>\n</ul>\n<p><img src=\"https://cimg1.17lai.site/data/2021/08/0220210802163916.png\" alt=\"\"></p>\n<p><img src=\"https://cimg1.17lai.site/data/2021/08/0220210802163907.png\" alt=\"\"></p>\n<p><img src=\"https://cimg1.17lai.site/data/2021/05/2820210528225256.png\" alt=\"\"></p>\n<p>** 3）删除无用分支**</p>\n<ul>\n<li>然后删除已经合并到主干中的不必要的分支，如index、pay等</li>\n<li>最后一定要注意时间一定要同步，不然会错乱</li>\n</ul>\n<h2 id=\"8-Gitlab调优\"><strong>8. Gitlab调优</strong></h2>\n<p>gitlab对内存资源的消耗比较厉害<br>\n其中尤以 sidekiq队列 及 unicorn服务 两个组件对内存消耗最多<br>\n可以再容器启动时对相关参数进行微调：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">unicorn['worker_processes'] = 1\nunicorn['worker_memory_limit_min'] = \"300 * 1 &lt;&lt; 20\"\nunicorn['worker_memory_limit_max'] = \"400 * 1 &lt;&lt; 20\"\nunicorn['worker_timeout'] = 15\nsidekiq['concurrency'] = 10\nsidekiq_cluster['enable'] = false\nsidekiq_cluster['ha'] = false\nredis['maxclients'] = \"100\"\nnginx['worker_processes'] = 2\nnginx['worker_connections'] = 512\nnginx['keepalive_timeout'] = 300\nnginx['cache_max_size'] = '200m'\nmattermost['enable'] = false\nmattermost_nginx['enable'] = false\ngitlab_pages['enable'] = false\npages_nginx['enable'] = false\npostgresql['shared_buffers'] = \"256MB\"\npostgresql['max_connections'] = 30\npostgresql['work_mem'] = \"8MB\"\npostgresql['maintenance_work_mem'] = \"16MB\"\npostgresql['effective_cache_size'] = \"1MB\"\npostgresql['checkpoint_timeout'] = \"5min\"\npostgresql['checkpoint_warning'] = \"30s\"\n </code></pre></div></figure>\n<p>配置调整后需要重载一下</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">docker exec gitlab gitlab-ctl reconfigure\ndocker-compose down\ndocker-compose up -d\n </code></pre></div></figure>\n<hr>\n<h2 id=\"9-Gitlab-启用-ContainerRegistry\">9. Gitlab 启用 ContainerRegistry</h2>\n<ul>\n<li><code>ContainerRegistry</code>是<code>Gitlab</code>内置的<code>Docker Registry</code>集成组件</li>\n<li>集成后每个项目可获得私有的 <code>Docker</code> 镜像存储空间</li>\n<li><code>ContainerRegistry</code> 可以复用 <code>Gitlab</code> 域名 或者 独立域名</li>\n<li>这里配置为复用域名（此时<code>ContainerRegistry</code> 将复用 <code>Gitlab</code> 的 <code>TLS</code> 证书）</li>\n</ul>\n<ol>\n<li><code>docker-compose.yaml</code>中Gitlab服务的 <code>GITLAB_OMNIBUS_CONFIG</code> 节点下增加如下配置：</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">registry_external_url \"https://gitlab.example.com:4567\"  # ContainerRegistry的外部访问地址\nregistry_nginx['ssl_certificate'] = \"/etc/gitlab/ssl/domain.crt\"\nregistry_nginx['ssl_certificate_key'] = \"/etc/gitlab/ssl/domain.key\"\ngitlab_rails['registry_host'] = \"gitlab.example.com\"\ngitlab_rails['registry_port'] = \"4567\"\ngitlab_rails['registry_api_url'] = \"http://localhost:5000\"\ngitlab_rails['gitlab_default_projects_features_builds'] = false\ngitlab_rails['gitlab_default_projects_features_container_registry'] = false\n </code></pre></div></figure>\n<ol start=\"2\">\n<li>端口开放增加 <code>- 4567:4567</code></li>\n<li>服务重启 <code>docker-compose restart Gitlab</code></li>\n</ol>\n<p><code>ContainerRegistry</code> 集成后可以通过 <code>Gitlab</code> 账户登录： <code>docker login gitlab.example.com:4567</code></p>\n<hr>\n<h2 id=\"日常维护命令\">日常维护命令</h2>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"># Gitlab维护\ndocker exec gitlab gitlab-ctl status  # gitlab各组件服务状态\ndocker exec gitlab gitlab-ctl start/restart/stop [组件名]  # gitlab所有组件的统一控制（其中Unicorn组件重启完成前GitLab会报502）\ndocker exec gitlab gitlab-ctl tail [/var/log/gitlab下的某子目录]  # 实时查看日志\n \ndocker exec gitlab update-permissions  # 修复gitlab版本升级后出现的权限问题\ndocker exec gitlab gitlab-ctl reconfigure  # 重载配置\ndocker exec -t gitlab gitlab-rake gitlab:backup:create  # 创建备份\n \n# ContainerRegistry维护\ndocker exec gitlab gitlab-ctl registry-garbage-collect  # 垃圾回收，清理废弃layer（registry停机）\n </code></pre></div></figure>\n<hr>\n<h3 id=\"Import-Repository-Repo-By-Url\">Import Repository(Repo By Url)</h3>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"># 账号密码若存在特殊字符则需要url编码\nhttps://username:password@host:port/group/project.git\n </code></pre></div></figure>\n<h2 id=\"10-GitLab重置用户名密码\"><strong>10. GitLab重置用户名密码</strong></h2>\n<p>打开终端，访问：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">gitlab-rails console</code></pre></div></figure>\n<p>输入：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">user = User.where(id: 1).first\nuser.password='123456'\nuser.password_confirmation = '123456'\nuser.save! #注意加上 “！”</code></pre></div></figure>\n<p>然后退出命令行即可。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">quit</code></pre></div></figure>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"> gitlab-rails console production 命令 开始初始化密码\n# 在irb(main):001:0&gt; 后面通过 u=User.where(id:1).first 来查找与切换账号（User.all 可以查看所有用户）\n# 通过u.password='12345678'设置密码为12345678(这里的密码看自己喜欢)：\n# 通过u.password_confirmation='12345678' 再次确认密码\n# 通过 u.save!进行保存</code></pre></div></figure>\n<h2 id=\"11-HTTPS-SSL-支持\"><strong>11. HTTPS SSL 支持</strong></h2>\n<ul>\n<li>\n<p>nginx反向代理方式</p>\n<ul>\n<li>注意docker 内部没有ca支持， 需要手动添加</li>\n</ul>\n</li>\n<li>\n<p>域名提供商提供的免费证书</p>\n<ul>\n<li>这种证书直接用，如果是自签名证书，需要添加自己的ca root证书到服务器</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"12-Gitlab恢复数据出现must-be-owner-of解决方法\">12. Gitlab恢复数据出现must be owner of解决方法</h2>\n<p>按正常Gitlab备份数据gitlab-rake gitlab:backup:create</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">ERROR: must be owner of extension plpgsql\nERROR: must be owner of schema public\nERROR: schema “public” already exists\nERROR: must be owner of schema public\nERROR: must be owner of extension plpgsql\nWARNING: no privileges could be revoked for “public”\nWARNING: no privileges could be revoked for “public”\nWARNING: no privileges were granted for “public”\nWARNING: no privileges were granted for “public”</code></pre></div></figure>\n<p>解决方法：</p>\n<h4 id=\"1-修改postgresql配置\">**1. 修改postgresql配置 **</h4>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">cd /var/opt/gitlab/postgresql/data\n$ vi /var/opt/gitlab/postgresql/data/postgresql.conf\nlisten_addresses = '*'</code></pre></div></figure>\n<p>找到listen_addresses = ” 改为listen_addresses = ‘*’</p>\n<p>修改 /var/opt/gitlab/postgresql/data/pg_hba.conf<br>\n在这个文件最后面加入</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ vi /var/opt/gitlab/postgresql/data/pg_hba.conf\nlocal   all         all                               trust\nhost    all         all                               127.0.0.1/32 trust\nhost    all         all                               ::1/128 trust    #ipv6 可以不配置</code></pre></div></figure>\n<h4 id=\"2-重启gitlab生效\"><strong>2. 重启gitlab生效</strong></h4>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">gitlab-ctl restart</code></pre></div></figure>\n<h4 id=\"3-修改gitlab账号为超级用户\"><strong>3. 修改gitlab账号为超级用户</strong></h4>\n<p>进入postgresql命令行</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">cd /opt/gitlab/embedded/bin\nsu gitlab-psql\n./psql -h 127.0.0.1 gitlabhq_production</code></pre></div></figure>\n<p>查看账户权限</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">\\du</code></pre></div></figure>\n<p>执行修改gitlab用户为超级权限</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">ALTER USER gitlab WITH SUPERUSER;</code></pre></div></figure>\n<p>退出</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">\\q</code></pre></div></figure>\n<p><img src=\"https://cimg1.17lai.site/data/2021/08/0220210802135016.png\" alt=\"\"></p>\n<h5 id=\"4-从1462989681编号备份中恢复\">4. 从1462989681编号备份中恢复</h5>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">gitlab-rake gitlab:backup:restore BACKUP=1462989681</code></pre></div></figure>\n<p>这样Gitlab恢复数据就不会再报must be owner of extension plpgsql错误。</p>\n<h4 id=\"4-重启gitlab\"><strong>4. 重启gitlab</strong></h4>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">gitlab-ctl restart</code></pre></div></figure>\n<h2 id=\"13-Gitlab-Pages\">13. Gitlab Pages</h2>\n<blockquote>\n<p>官方文档：<a href=\"https://docs.gitlab.com/ee/user/project/pages/\">https://docs.gitlab.com/ee/user/project/pages/</a> 。</p>\n</blockquote>\n<p>Gitlab Pages 使用 <a href=\"https://gitlab.com/gitlab-org/gitlab-pages\">GitLab Pages daemon</a> 服务，它是用 GO 语言实现的简单 HTTP 服务，并且可以监听外部 IP 地址以及为自定义域名和自定义证书提供支持。它通过 SNI 支持动态证书并且默认通过 HTTP2 协议发送页面。最后推荐你去看官方文档 <a href=\"https://gitlab.com/gitlab-org/gitlab-pages/blob/master/README.md\">README</a> 以便全面了解它的工作原理。</p>\n<h3 id=\"启用-Pages\">启用 Pages</h3>\n<p>打开 <code>gitlab.rb</code>：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-none\"><code class=\"language-none\">sudo vim /etc/gitlab/gitlab.rb</code></pre></div></figure>\n<p>修改 <code>Pages</code> 配置：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"># Pages 服务地址\npages_external_url \"http://git.17lai.io\"\n# 启用 pages\ngitlab_pages['enable'] = true\n# fails to start in Docker\ngitlab_pages['inplace_chroot'] = true</code></pre></div></figure>\n<p>让 <code>Gitlab</code> 使用当前配置：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">sudo gitlab-ctl reconfigure\n\n# stdout\n&gt; gitlab Reconfigured!</code></pre></div></figure>\n<p>如果没有域名怎么办呢？可以参考 <a href=\"https://www.imooc.com/learn/634\">Linux智能DNS服务搭建之Bind服务</a>。</p>\n<h3 id=\"使用-Pages\">使用 Pages</h3>\n<blockquote>\n<p>官方的案例库：<a href=\"https://gitlab.com/pages\">https://gitlab.com/pages</a></p>\n</blockquote>\n<p><strong>用户文档</strong></p>\n<p>一般有两种类型的Pages可以创建</p>\n<ul>\n<li>对于用户（<a href=\"http://username.example.io\">username.example.io</a>）或组（<a href=\"http://groupname.example.io\">groupname.example.io</a>）</li>\n<li>对于Project（<a href=\"http://username.example.io/projectname\">username.example.io/projectname</a> 或 <a href=\"http://groupname.example.io/projectname\">groupname.example.io/projectname</a> ）</li>\n</ul>\n<p>在GitLab中，usernames或groupnames是唯一的，我们经常把他们称为namespaces。在一个GitLab实例中只能有一个namespace。</p>\n<p>下面是Gitlab Pages类型、Project Name和 website URL对照表：</p>\n<p><img src=\"https://cimg1.17lai.site/data/2022/04/0820220408205156.png\" alt=\"img\"></p>\n<p>GitLab Pages前提条件：</p>\n<p>简而言之，这是上传web站点到GitLab Pages需要的：</p>\n<ol>\n<li>Gitlab Pages使用的域名（向管理员询问）。</li>\n<li>创建一个Project。</li>\n<li>仓库的根目录放一个.gitlab-ci.yml，其中有个叫做pages的job。</li>\n<li>设置一个GitLab Runner构建web站点。</li>\n</ol>\n<h4 id=\"部署简单的-html-项目\">部署简单的 html 项目</h4>\n<ol>\n<li>我们在自己的 <code>gitlab</code> 上面创建一个测试项目：<code>plain-html</code></li>\n<li>把项目拉取到本地：</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-none\"><code class=\"language-none\"># 换成你自己的仓库地址\ngit clone git@git.17lai.io:pages/plain-html.git</code></pre></div></figure>\n<ol>\n<li>在项目中新建 <code>public</code> 目录，然后添加 <code>index.html</code> 、 <code>style.css</code> 文件:</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;meta charset=\"utf-8\"&gt;\n    &lt;meta name=\"generator\" content=\"GitLab Pages\"&gt;\n    &lt;title&gt;Plain HTML site using GitLab Pages&lt;/title&gt;\n    &lt;link rel=\"stylesheet\" href=\"style.css\"&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;div class=\"navbar\"&gt;\n      &lt;a href=\"https://pages.gitlab.io/plain-html/\"&gt;Plain HTML Example&lt;/a&gt;\n      &lt;a href=\"https://gitlab.com/pages/plain-html/\"&gt;Repository&lt;/a&gt;\n      &lt;a href=\"https://gitlab.com/pages/\"&gt;Other Examples&lt;/a&gt;\n    &lt;/div&gt;\n\n    &lt;h1&gt;Hello World!&lt;/h1&gt;\n\n    &lt;p&gt;\n      This is a simple plain-HTML website on GitLab Pages, without any fancy static site generator.\n    &lt;/p&gt;\n  &lt;/body&gt;\n&lt;/html&gt;</code></pre></div></figure>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-css\" data-language=\"css\"><code class=\"language-css\">body {\n  font-family: sans-serif;\n  margin: auto;\n  max-width: 1280px;\n}\n\n.navbar {\n  background-color: #313236;\n  border-radius: 2px;\n  max-width: 800px;\n}\n\n.navbar a {\n  color: #aaa;\n  display: inline-block;\n  font-size: 15px;\n  padding: 10px;\n  text-decoration: none;\n}\n\n.navbar a:hover {\n  color: #ffffff;\n}</code></pre></div></figure>\n<ol>\n<li>在项目根目录添加 <code>.gitlab-ci.yml</code> 文件：</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\"># This file is a template, and might need editing before it works on your project.\n# Full project: https://gitlab.com/pages/plain-html\npages:\n  tags:\n    - html\n  stage: deploy\n  script:\n    - mkdir .public\n    - cp -r * .public\n    - mv .public public\n  artifacts:\n    paths:\n      - public\n  only:\n    - master</code></pre></div></figure>\n<ol>\n<li>提交代码：</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-none\"><code class=\"language-none\">git add .\ngit commit -m\"feat(pages):  开启 pages 服务\"\ngit push</code></pre></div></figure>\n<p>最后我们回到 gitlab 服务，在 <code>plain-html</code> 仓库中的 <code>Settings / pages</code> 页面可以看到已经有对应的服务地址了：</p>\n<p><img src=\"https://cimg1.17lai.site/data/2022/04/0820220408203643.png\" alt=\"img\"></p>\n<blockquote>\n<p>gitlab 服务的域名跟 pages 的不要使用同一个，防止 XSS 攻击。</p>\n</blockquote>\n<ul>\n<li>\n<p>管理员文档：<a href=\"https://docs.gitlab.com/ce/administration/pages/\">https://docs.gitlab.com/ce/administration/pages/</a></p>\n</li>\n<li>\n<p>用户文档：<a href=\"https://docs.gitlab.com/ce/user/project/pages/index.html\">https://docs.gitlab.com/ce/user/project/pages/index.html</a></p>\n</li>\n<li>\n<p>gitlab pages：<a href=\"https://pages.gitlab.io/\">https://pages.gitlab.io/</a></p>\n</li>\n</ul>\n<h2 id=\"Container-Registry\">Container Registry</h2>\n<blockquote>\n<p>官方文档：<a href=\"https%25://docs.gitlab.com/ee/user/packages/container_registry/\">https://docs.gitlab.com/ee/user/packages/container_registry/</a></p>\n<p>本节修改中</p>\n</blockquote>\n<h3 id=\"开启-Container-Registry\">开启 Container Registry</h3>\n<p>修改gitlab配置文件： vim /etc/gitlab/gitlab.rb</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">//外部访问地址，此处被nginx代理，暴露给外部访问\nregistry_external_url 'http://xxx.com'\n//启用\ngitlab_rails['registry_enabled'] = true\n//registry 服务ip\ngitlab_rails['registry_host'] = \"172.29.1.70\"\n//registry 服务真正端口\ngitlab_rails['registry_port'] = \"5000\"</code></pre></div></figure>\n<p>这里需要注意的是，registry_external_url是外部访问的url，如docker需要pull和push，都是访问该路径。然后，刷新配置，重启：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">gitlab-ctl reconfigure\ngitlab-ctl restart</code></pre></div></figure>\n<h3 id=\"访问Docker\">访问Docker</h3>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"># docker login https://xxx.com -u root -p xxx\nLogin Succeeded</code></pre></div></figure>\n<p>默认<mark>需要SSL</mark>，请使用反向代理</p>\n<p>官方文档有说明，如果启用了双重验证（Two-Factor Authentication）则不应该输入密码，而是token：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">docker login xxx.com -u &lt;username&gt; -p &lt;token&gt;</code></pre></div></figure>\n<h2 id=\"CI\">CI</h2>\n<p>GitLab Continuous Integration (GitLab CI/CD)</p>\n<blockquote>\n<ul>\n<li>CI: Continuous Integration：持续集成。</li>\n<li>CD: Coninuous delivery and deployment：持续交付和部署。</li>\n</ul>\n<p>Gitlab CI/CD 是以可持续方法论进行软件开发的内建工具（<a href=\"https://about.gitlab.com/gitlab-ci/\">continuous integration service</a> ）。</p>\n</blockquote>\n<p>在使用 Gitlab CI 之前，我们需要先了解几个概念：</p>\n<h3 id=\"Stage\">Stage</h3>\n<p>阶段：通俗的讲就是步骤（把一件事分解成多个步骤来完成）。 从最上面的图中可以看到在 <code>CI</code> 中可能会有：<code>Build</code>、<code>Unit Test</code> 、<code>Integration Tests</code> 等多个阶段。</p>\n<h3 id=\"Job\">Job</h3>\n<p>任务：就是我们在每个阶段具体要做的事情，而一个阶段可能会有多个任务。</p>\n<h3 id=\"Pipelines\">Pipelines</h3>\n<p>一条流水线 （ <code>pipeline</code>）就是 <strong>一组</strong> 在各个阶段执行的任务。在同一阶段的多个任务是可以并行的（如果 <code>Runner</code> 足够多的话），当全部的任务都执行成功之后流水线将会进入下一个阶段。反之，如果其中有一个任务失败，流水线的下一个阶段将不再执行。</p>\n<h3 id=\"Runners\">Runners</h3>\n<p>在 Gitlab CI 中，<code>Runner</code> 负责运行定义在 <code>.gitlab-ci.yml</code> 中的代码。<code>Runner</code> 为三种：<code>Shared Runners</code>、<code>Group Runners</code>、<code>Specific Runners</code>，分别表示全局共用 Runner、组共用 Runner、单个项目指定的 Runner。</p>\n<h3 id=\"gitlab-ci-yml\">.gitlab-ci.yml</h3>\n<p>Gitlab CI 的配置文件，该文件声明了流水线的结构和顺序，以任务为最小单元。</p>\n<p>文件中允许定义的元素：</p>\n<ol>\n<li><a href=\"https://docs.gitlab.com/ce/ci/yaml/README.html#image\"><code>image</code></a>：docker 镜像，当 Gitlab-Runner 的类型为 docker 时，会根据该属性指定的镜像为脚本执行容器。</li>\n<li><a href=\"https://docs.gitlab.com/ce/ci/yaml/README.html#services\"><code>services</code></a>: 指定另一个 docker 镜像，主要用于提供服务层的能力，比如 <code>mysql</code> 。</li>\n<li><a href=\"https://docs.gitlab.com/ce/ci/yaml/README.html#before_script-and-after_script\"><code>before_script</code></a>：任务执行前的钩子事件，比如一个 node 项目，我们可以在这里安装依赖。</li>\n<li><a href=\"https://docs.gitlab.com/ce/ci/yaml/README.html#before_script-and-after_script\"><code>after_script</code></a>：任务执行后的钩子事件，当所有的任务都执行完毕之后被调用，不管任务是否执行成功。</li>\n<li><a href=\"https://docs.gitlab.com/ce/ci/yaml/README.html#stages\"><code>stages</code></a>：定义流水线中的阶段，默认的为 <code>build</code> 、<code>test</code>、<code>deploy</code>。如果我们要在任务中指定其他的 <code>stage</code>，则需要使用该属性先申明。</li>\n<li><a href=\"https://docs.gitlab.com/ce/ci/yaml/README.html#cache\"><code>cache</code></a>：需要缓存的文件，比如 node 项目可以把 node_modules 缓存起来。提示：可以定义在 <code>.gitlab-ci.yml</code> 顶级表示项目级别的，也可以申明在单个任务中。</li>\n<li><a href=\"https://docs.gitlab.com/ce/ci/yaml/README.html#variables\"><code>variables</code></a>：变量，同样可以在顶级或者单个任务中申明。</li>\n<li><a href=\"https://docs.gitlab.com/ce/ci/yaml/README.html#pages\"><code>pages</code></a>：内置的一个任务，用于上传任务执行的结果到 <a href=\"https://docs.gitlab.com/ce/user/project/pages/index.html\">Gitlab Pages</a>。</li>\n<li><a href=\"https://docs.gitlab.com/ce/ci/yaml/README.html#include\"><code>include</code></a>：合并其他的 <code>.gitlab-ci.yml</code> 文件配置。</li>\n<li>在单个任务中申明的元素：\n<ol>\n<li><a href=\"https://docs.gitlab.com/ce/ci/yaml/README.html#script\"><code>script</code></a>：需要执行的脚本。</li>\n<li><a href=\"https://docs.gitlab.com/ce/ci/yaml/README.html#stage\"><code>stage</code></a>：标识该任务所属的阶段。</li>\n<li><a href=\"https://docs.gitlab.com/ce/ci/yaml/README.html#tags\"><code>tags</code></a>：为任务打上标签，用于选择特定的 <code>Runner</code>。</li>\n<li><a href=\"https://docs.gitlab.com/ce/ci/yaml/README.html#onlyexcept-basic\"><code>only</code></a>：用于表明何时<strong>创建</strong>该任务。</li>\n<li><a href=\"https://docs.gitlab.com/ce/ci/yaml/README.html#onlyexcept-basic\"><code>except</code></a>：用于表明何时<strong>不创建</strong>该任务。</li>\n<li><a href=\"https://docs.gitlab.com/ce/ci/yaml/README.html#when\"><code>when</code></a>：用于表明何时<strong>运行</strong>该任务。</li>\n<li><a href=\"https://docs.gitlab.com/ce/ci/yaml/README.html#allow_failure\"><code>allow_failure</code></a>：允许失败，该任务失败时不会影响整个流水线的结果。</li>\n<li><a href=\"https://docs.gitlab.com/ce/ci/yaml/README.html#artifacts\"><code>artifacts</code></a>：任务执行的结果，比如执行 <code>打包任务</code> 后的产出资源。</li>\n<li><a href=\"https://docs.gitlab.com/ce/ci/yaml/README.html#dependencies\"><code>dependencies</code></a>：依赖的其他任务。</li>\n<li><a href=\"https://docs.gitlab.com/ce/ci/yaml/README.html#retry\"><code>retry</code></a>：当任务失败时最多重试的次数。</li>\n<li><a href=\"https://docs.gitlab.com/ce/ci/yaml/README.html#coverage\"><code>coverage</code></a>：指定如何从任务结果中提取代码覆盖率。</li>\n<li><a href=\"https://docs.gitlab.com/ce/ci/yaml/README.html#parallel\"><code>parallel</code></a>：允许并行的任务实例个数。</li>\n</ol>\n</li>\n</ol>\n<blockquote>\n<p>请注意版本问题，每个属性对版本的要求并不一致，具体的可以点击属性查看官方文档。</p>\n</blockquote>\n<h3 id=\"使用-Gitlab-CI\">使用 Gitlab CI</h3>\n<p>使用 Gitlab CI 服务的两种方式： 1. <a href=\"https://docs.gitlab.com/ce/topics/autodevops/index.html\">Auto DevOps</a> 2. 手动配置 CI/CD</p>\n<h4 id=\"Auto-DevOps\"><a href=\"https://docs.gitlab.com/ce/topics/autodevops/index.html\">Auto DevOps</a></h4>\n<p>Auto DevOps 是 Gitlab 11.0 推出的新功能，它提供了预定义的 CI/CD 配置，允许我们自动检测、构建、测试、发布以及监控应用。</p>\n<p>暂未使用，待补充。</p>\n<h4 id=\"手动配置-CI-CD\">手动配置 CI/CD</h4>\n<p>手动配置主要就 2 个步骤，配置 <code>.gitlab-ci.yml</code> 文件，添加 Gitlab Runner 运行该文件。</p>\n<hr>\n<p>下面，我们看看如何配置 Gitlab Runner：</p>\n<h4 id=\"Gitlab-Runner\">Gitlab Runner</h4>\n<p>Gitlab Runner 是一个开源项目，用来运行 <code>.gitlab-ci.yml</code> 中定义的任务并把结果返给 Gitlab。</p>\n<h5 id=\"安装\">安装</h5>\n<blockquote>\n<p>官方文档：<a href=\"https://docs.gitlab.com/runner/install/linux-repository.html\">https://docs.gitlab.com/runner/install/linux-repository.html</a></p>\n</blockquote>\n<p>首先，添加离线仓库：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-none\"><code class=\"language-none\">curl -L https://packages.gitlab.com/install/repositories/runner/gitlab-runner/script.deb.sh | sudo bash</code></pre></div></figure>\n<p>然后，安装最新版本：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-none\"><code class=\"language-none\">sudo apt-get install gitlab-runner</code></pre></div></figure>\n<h5 id=\"注册\">注册</h5>\n<blockquote>\n<p>官方文档：<a href=\"https://docs.gitlab.com/runner/register/index.html\">https://docs.gitlab.com/runner/register/index.html</a></p>\n</blockquote>\n<p>首先，我们进入要配置 Runner 的 Gitlab 仓库，在 <code>Settings -&gt; CI / CD</code> 页面展开 <code>Runners</code> 配置面板可以看到已经分配的 Runner 以及注册 Runner 需要的参数：<img src=\"https://cimg1.17lai.site/data/2022/04/0820220408170943.png\" alt=\"img\"></p>\n<p>然后，我们使用 Gitlab-Runner 命名开始注册：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-none\"><code class=\"language-none\">gitlab-runner register</code></pre></div></figure>\n<p>执行完会该命令，终端会有交互，要求我们输入以下参数：</p>\n<ol>\n<li>gitlab-ci coordinator url ：gitlab 服务地址</li>\n<li>gitlab-ci token：上图中的 token</li>\n<li>description：描述信息</li>\n<li>tags：标签，对应 <code>.gitlab-ci.yml</code> 任务中配置的 tags，只有 tags 匹配的任务才会被该 Runner 执行。</li>\n<li>executor：<a href=\"https://docs.gitlab.com/runner/executors/README.html\">执行器</a>，即任务脚本执行的环境</li>\n</ol>\n<blockquote>\n<p>如果使用 docker 执行，则需要事先安装 <a href=\"https://docs.docker.com/install/linux/docker-ce/ubuntu/\">Docker</a> 环境。</p>\n</blockquote>\n<p>参数填写完毕之后，一个 Runner 便被注册成功了：</p>\n<p><img src=\"https://cimg1.17lai.site/data/2022/04/0820220408170946.png\" alt=\"img\"></p>\n<p>我们回到 gitlab 仓库页面，然后刷新便可以看到 <code>_fzBq4PN</code> 这个 Runner 已经被注册到该项目：</p>\n<p><img src=\"https://cimg1.17lai.site/data/2022/04/0820220408170952.png\" alt=\"img\"></p>\n<blockquote>\n<p>我们可以点击 <code>编辑图标</code> 对该 Runner 进行修改。我比较喜欢把 <code>Run untagged jobs</code> 选项勾上，这样就不用每个任务都添加对应的 tags 了（因为现在涉及到的都是一些简单的流程）。</p>\n</blockquote>\n<h3 id=\"总结\">总结</h3>\n<p>首先，CI/CD 是一种软件开发流程，Gitlab CI/CD 是 Gitlab 为实现该流程而提供的一个内置工具（服务）。 其次，我们有 <a href=\"https://docs.gitlab.com/ce/topics/autodevops/index.html\">Auto DevOps</a> 与 <code>手动配置</code> 两种方式使用，本文讲解的主要是 <code>手动配置</code> 方式。</p>\n<h2 id=\"加速Gitlab-Runner\">加速Gitlab Runner</h2>\n<blockquote>\n<p>gitlab runner构建镜像每次RUN 安装依赖包，都远程下载?可以缓存加速吗？ 可以的！</p>\n</blockquote>\n<p>在将GitLab Runner注册到GitLab page上，让GitLab page可以和你的Runner通信时，有一步是填写使用的executor</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-none\"><code class=\"language-none\">输入Runner的executor：\nPlease enter the executor: ssh, docker+machine, docker-ssh+machine, kubernetes, docker, parallels, virtualbox, docker-ssh, shell:</code></pre></div></figure>\n<p>如果你选择Docker作为Runner的executor，你还要选择默认的docker image来运行job(当然，你也可以在.gitlab-ci.yml里指明你需要用的image),这句话就跟文章使用gitlab-runner往k8s上发送curl命令实现pod中容器使用的镜像版本更新，地址： 开头讲述的那样，不过.gitlab-ci.yml里指明的image优先级高。</p>\n<p>注册完成后你可以在/etc/gitlab-runner里发现 config.toml文件，该文件是Runner的配置文件</p>\n<p>接下来就牵涉到一个重要的话题 —— Executor</p>\n<ol>\n<li>Shell Executor<br>\n以宿主机作为Runner的所有jobs的执行器。Runner将会从远程仓库pull你的工程，工程的目录为：/builds。如果你使用了cache，那么cache将会存在/cache/。<br>\n但是，它需要将构建所需的所有依赖手动安装到安装了Runner的同一台计算机上，比如使用到的git,jdk,maven,docekr等</li>\n<li>Docker Executor<br>\n所有jobs的执行环境为指定的docker image所生成的container，每个job都会生成一个container并且在job结束后立即销毁。这个说的就是config.toml文件和.gitlab-ci.yml中指定的image<br>\nDocker executor默认将所有的builds存储在/builds/(这里的路径是container里的路径，Runner配置文件config.toml里的build_dir字段可以重新指明build的目录，默认对应于宿主机的目录是在宿主机的docker volume下：/var/lib/docker/volumes//_data/)，默认将所有的caches存储在container里的/cache目录(config.toml里的cache_dir字段可以重新指明cache的目录)，注意build_dir和cache_dir指向的均是container里的目录，要想将container里的数据持久化，需要用到volumes字段，这个字段的使用和docker volume的使用是类似的，只需在config.toml的[runner.docker]部分添加volumes = [“/cache”, “:rw”]即可实现container里/cache目录数据的永久保存以及将host目录挂载到相应的container目录并具有读写的功能。<br>\n比如：</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-none\"><code class=\"language-none\"># 仅作展示，未显示完整\n[runners.docker]\n  image = \"jdd.io/jre:1.8.275\"\n  volumes = [\"/cache\",\"/run/docker.sock:/run/docker.sock\"]</code></pre></div></figure>\n<p>当你使用docker 或 docker+machine executors时，你可以通过设置pull_policy来决定Runner如何pull docker image。pull_policy有三种值：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-none\"><code class=\"language-none\">always —— Runner始终从远程pull docker image。\nif-not-present —— Runner会首先检查本地是否有该image，如果有则用本地的，如果没有则从远程拉取。\nnever —— Runner始终使用本地的image。</code></pre></div></figure>\n<blockquote>\n<p>注意：这一步就是本文开头提到的，使用本地镜像，不用再从dockerhub上拉取了</p>\n</blockquote>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-none\"><code class=\"language-none\"># 仅作展示，未显示完整\n[runners.docker]\n  image = \"jdd.io/jre:1.8.275\"\n  pull_policy=\"if-not-present\" # 添加这个选项就可以了\n  volumes = [\"/cache\",\"/run/docker.sock:/run/docker.sock\"]</code></pre></div></figure>\n<p>当你使用docker, docker+machine 或 kubernetes作为executor时，GitLab Runner将会使用特定的container来处理Git、artifacts 和cache 操作。</p>\n<h2 id=\"权限管理\">权限管理</h2>\n<p>以管理员的身份登入gitlab，点击Settings，然后选择Members，可以通过输入名字选择要分配权限的小组成员，然后分配角色，选择权限有效时间，点击Add to Project就把人员拉近到项目中。</p>\n<p>GitLab的角色有以下四种：</p>\n<ul>\n<li>Guest：可以创建issue、发表评论，不能读写版本库</li>\n<li>Reporter：可以克隆代码，不能提交，可以赋予测试、产品经理此权限</li>\n<li>Developer：可以克隆代码、开发、提交、push，可以赋予开发人员此权限</li>\n<li>MainMaster：可以创建项目、添加tag、保护分支、添加项目成员、编辑项目，一般GitLab管理员或者CTO才有此权限</li>\n</ul>\n<p>访问权限 - Visibility Level：</p>\n<p>这个是在建立项目时就需要选定的，主要用于决定哪些人可以访问此项目，包含3种</p>\n<ul>\n<li>Private - 私有，只有属于该项目成员才有原先查看</li>\n<li>Internal - 内部，用个Gitlab账号的人都可以clone</li>\n<li>Public - 公开，任何人可以clone</li>\n</ul>\n<p>本文作者：夜法之书       写作不易，转载请注明来源地址！</p>\n<h2 id=\"参考链接：\">参考链接：</h2>\n<ol>\n<li><a href=\"https://www.cnblogs.com/hgzero/p/14088215.html\">https://www.cnblogs.com/hgzero/p/14088215.html</a></li>\n<li><a href=\"http://www.51blogs.net/2017/11/10/1110113243.html\">http://www.51blogs.net/2017/11/10/1110113243.html</a></li>\n<li><a href=\"https://my.oschina.net/u/2400083/blog/808097\">https://my.oschina.net/u/2400083/blog/808097</a></li>\n</ol>\n<hr>\n<h2 id=\"系列教程\"><strong>系列教程</strong></h2>\n<p><a href=\"/atom.xml\"><i class=\"fas fa-rss\"></i>全部文章RSS订阅</a></p>\n<h3 id=\"Gitlab-使用系列\"><strong>Gitlab 使用系列</strong></h3>\n<p><a href=\"/categories/gitlab/atom.xml\"><i class=\"fas fa-rss\"></i><strong>Gitlab RSS 分类订阅</strong></a></p>\n<ul>\n<li><a href=\"/posts/acc13b70/\"><strong>Gitlab的安装及使用教程完全版</strong></a></li>\n<li><a href=\"/posts/29a820b3/\">破解Gitlab EE</a></li>\n<li><a href=\"/posts/d08eb7b/\">Gitlab的安装及使用</a></li>\n<li><a href=\"/posts/1879721e/\">CI/CD与Git Flow与GitLab</a></li>\n</ul>\n<h3 id=\"Devops系列\"><strong>Devops系列</strong></h3>\n<p><a href=\"/categories/devops/atom.xml\"><i class=\"fas fa-rss\"></i><strong>Devops 分类 RSS 订阅</strong></a></p>\n<ul>\n<li><a href=\"/posts/ab63eb8f/\">自建全套开源Devops开发系统</a></li>\n<li><a href=\"/posts/d32a07a7/\">Git介绍以及分支模型图解</a></li>\n<li><a href=\"/posts/39563241/\">三万字无坑搭建基于Docker+K8S+GitLab/SVN+Jenkins+Harbor持续集成交付环境</a></li>\n<li><a href=\"/posts/3437994a/\">DevOps系列—【Jenkinsfile+Dockerfile+nginx+vue】</a></li>\n<li><a href=\"/posts/f4c3ad41/\">项目开发管理工具推荐</a></li>\n<li><a href=\"/posts/acc13b70/\">Gitlab的安装及使用教程完全版</a></li>\n<li><a href=\"/posts/d08eb7b/\">Gitlab的安装及使用</a></li>\n<li><a href=\"/posts/78c3371/\">那些有用的Github工具介绍！Action、app、workflow等</a></li>\n</ul>\n<h2 id=\"项目管理系列介绍锦集\">项目管理系列介绍锦集</h2>\n<blockquote>\n<p>快速全面的介绍现代企业中项目管理相关知识！</p>\n</blockquote>\n\n    <div class=\"vkr-url-wrapper\">\n        <a href=\"/posts/d8b1e381/\"><img class=\"avatar\" src=\"/medias_webp/cover/guanli.webp\"></a>\n        <div class=\"desc-wrapper\">\n            <a href=\"/posts/d8b1e381/\">如何做一个完整的硬件项目的项目管理之简明教程</a>\n            <hr>\n            <div class=\"desc\">以一个硬件项目开发为例，介绍现代公司项目管理的一些基本工具和方法，给行业内外朋友一个初步印象，为广大从业者入门相关管理打下一个初步的，全局的基础！最后给出一个IPD端到端管理项目示例</div>\n        </div>\n    </div>\n    \n\n    <div class=\"vkr-url-wrapper\">\n        <a href=\"/posts/ca630feb/\"><img class=\"avatar\" src=\"/medias_webp/cover/5w2h.webp\"></a>\n        <div class=\"desc-wrapper\">\n            <a href=\"/posts/ca630feb/\">几种常用管理模型和方法</a>\n            <hr>\n            <div class=\"desc\">几种常用管理模型和方法：PDCA, 5W2H, SMART, SWOT, GROW, OKR, WBS 等，职场人员需要了解的知识。</div>\n        </div>\n    </div>\n    \n\n    <div class=\"vkr-url-wrapper\">\n        <a href=\"/posts/ac0df556/\"><img class=\"avatar\" src=\"/medias_webp/cover/guanli.webp\"></a>\n        <div class=\"desc-wrapper\">\n            <a href=\"/posts/ac0df556/\">PMBOK指南（第6版）</a>\n            <hr>\n            <div class=\"desc\">PMBOK 只是一套悬在空中的方法论，要想具体落地还需要具体的行业知识。两条腿，缺一不可！PMBOK 是基础中的基础知识，了解总是没有坏处的。是常识，不懂就没法做，但要做项目管理，光靠PMBOK远远不够。</div>\n        </div>\n    </div>\n    \n\n    <div class=\"vkr-url-wrapper\">\n        <a href=\"/posts/99be6dfb/\"><img class=\"avatar\" src=\"/medias_webp/cover/guanli.webp\"></a>\n        <div class=\"desc-wrapper\">\n            <a href=\"/posts/99be6dfb/\">如何做好竞品分析</a>\n            <hr>\n            <div class=\"desc\">竞品分析可以帮助我们更好地找准自身产品定位，发现自己产品的优劣所在，进而推动产品的优化迭代。</div>\n        </div>\n    </div>\n    \n\n    <div class=\"vkr-url-wrapper\">\n        <a href=\"/posts/a6477052/\"><img class=\"avatar\" src=\"/medias_webp/cover/guanli.webp\"></a>\n        <div class=\"desc-wrapper\">\n            <a href=\"/posts/a6477052/\">一大堆寓意深刻的管理故事锦集</a>\n            <hr>\n            <div class=\"desc\">几十个关于管理，经营的故事。寓教于乐，寓意深刻，在自己遗忘之前，记录保存下来。包括 扁鹊三兄弟，曲突徒薪，猎人与狗等等</div>\n        </div>\n    </div>\n    \n\n    <div class=\"vkr-url-wrapper\">\n        <a href=\"/posts/ec34b111/\"><img class=\"avatar\" src=\"/medias_webp/cover/renxing.webp\"></a>\n        <div class=\"desc-wrapper\">\n            <a href=\"/posts/ec34b111/\">人格类型分类总结归纳</a>\n            <hr>\n            <div class=\"desc\">本文介绍了什么是人格特质，怎么分类，并介绍了主流分析方法。后面着重介绍了敏感型人格和内向人格的优势，最后介绍了人格缺陷的一些分类和特点。与人打交道，这些了解不可或缺</div>\n        </div>\n    </div>\n    \n",
            "tags": [
                "gitlab",
                "git",
                "docker",
                "ssl",
                "registry",
                "教程",
                "email",
                "https"
            ]
        },
        {
            "id": "https://blog.17lai.site/posts/d08eb7b/",
            "url": "https://blog.17lai.site/posts/d08eb7b/",
            "title": "Gitlab的安装及使用",
            "date_published": "2021-07-09T08:25:00.000Z",
            "content_html": "<h2 id=\"Gitlab概述\">Gitlab概述</h2>\n<h3 id=\"1-1-GitLab介绍\">1.1 GitLab介绍</h3>\n<p>GitLab是利用Ruby on Rails一个开源的版本管理系统，实现一个自托管的Git项目仓库，可通过Web界面进行访问公开的或者私人项目。</p>\n<p>GitLab能够浏览源代码，管理缺陷和注释。可以管理团队对仓库的访问，它非常易于浏览提交过的版本并提供一个文件历史库。团队成员可以利用内置的简单聊天程序(Wall)进行交流。</p>\n<p>它还提供一个代码片段收集功能可以轻松实现代码复用，便于日后有需要的时候进行查找</p>\n<h3 id=\"1-2-Gitlab服务构成\">1.2 Gitlab服务构成</h3>\n<ul>\n<li>\n<p>Nginx：静态web服务器。</p>\n</li>\n<li>\n<p>gitlab-shell：用于处理Git命令和修改authorized keys列表。</p>\n</li>\n<li>\n<p>gitlab-workhorse: 轻量级的反向代理服务器。</p>\n</li>\n<li>\n<p>logrotate：日志文件管理工具。</p>\n</li>\n<li>\n<p>postgresql：数据库。</p>\n</li>\n<li>\n<p>redis：缓存数据库。</p>\n</li>\n<li>\n<p>sidekiq：用于在后台执行队列任务（异步执行）。</p>\n</li>\n<li>\n<p>unicorn：An HTTP server for Rack applications，GitLab Rails应用是托管在这个服务器上面的。</p>\n</li>\n</ul>\n<h3 id=\"1-3-Gitlab工作流程\">1.3 Gitlab工作流程</h3>\n<p><img src=\"https://cimg1.17lai.site/data/2021/05/2820210528222044.png\" alt=\"\"></p>\n<h3 id=\"1-4-GitLab-Shell\">1.4 GitLab Shell</h3>\n<p>GitLab Shell有两个作用：为GitLab处理Git命令、修改authorized keys列表</p>\n<p>当通过SSH访问GitLab Server时，GitLab Shell会：</p>\n<ul>\n<li>限制执行预定义好的Git命令（git push，git pull，git annex）</li>\n<li>调用GitLab Rails API检查权限</li>\n<li>执行pre-receive钩子（在企业版中叫做Git钩子）</li>\n<li>执行用户请求的动作，处理GitLab的post-receive动作</li>\n<li>处理自定义的post-receive动作</li>\n</ul>\n<p>当通过http(s)访问GitLab Server时，工作流程取决于你是从Git仓库拉取(pull)代码还是向git仓库推送(push)代码：</p>\n<p>如果是从Git仓库拉取(pull)代码，GitLab Rails应用会全权负责处理用户鉴权和执行Git命令的工作</p>\n<p>如果是向Git仓库推送(push)代码，GitLab Rails应用既不会进行用户鉴权也不会执行Git命令，它会把以下工作交由GitLab Shell进行处理：</p>\n<ul>\n<li>调用GitLab Rails API 检查权限</li>\n<li>执行pre-receive钩子（在GitLab企业版中叫做Git钩子）</li>\n<li>执行你请求的动作</li>\n<li>处理GitLab的post-receive动作</li>\n<li>处理自定义的post-receive动作</li>\n</ul>\n<h3 id=\"1-5-GitLab-Workhorse\">1.5 GitLab Workhorse</h3>\n<p>GitLab Workhorse是一个敏捷的反向代理。它会处理一些大的HTTP请求，比如文件上传、文件下载、Git push/pull和Git包下载。其它请求会反向代理到GitLab Rails应用，即反向代理给后端的unicorn。</p>\n<h2 id=\"Gitlab的安装部署\">Gitlab的安装部署</h2>\n<hr>\n<ul>\n<li>Gitlab要求服务器内存2G以上</li>\n</ul>\n<h3 id=\"2-1-方式一-下载gitlab-ce的rpm包\">2.1 方式一:下载gitlab-ce的rpm包</h3>\n<ul>\n<li><a href=\"https://packages.gitlab.com/gitlab/gitlab-ce\">gitlab官方rpm包下载</a></li>\n<li><a href=\"https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el7/\">清华的源</a></li>\n</ul>\n<p>将对应版本的gitlab-ce下载到本地后，直接yum安装即可</p>\n<h4 id=\"要先将这个rpm包下载到本地\">要先将这个rpm包下载到本地</h4>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">yum install -y gitlab-ce-13.6.1-ce.0.el7.x86_64.rpm</code></pre></div></figure>\n<h3 id=\"2-2-方式二-配置yum源\">2.2 方式二:配置yum源</h3>\n<p>在 /etc/yum.repos.d/ 下新建 gitlab-ce.repo，写入如下内容：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-ruby\" data-language=\"ruby\"><code class=\"language-ruby\">[gitlab-ce]\nname=gitlab-ce\nbaseurl=https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el7/ Repo_gpgcheck=0\nEnabled=1 Gpgkey=https://packages.gitlab.com/gpg.key</code></pre></div></figure>\n<p>然后创建cache，再直接安装gitlab-ce</p>\n<p>yum makecache  # 这一步会创建大量的数据</p>\n<h4 id=\"直接安装最新版\">直接安装最新版</h4>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">yum install -y gitlab-ce # 如果要安装指定的版本，在后面填上版本号即可\nyum install -y  gitlab-ce-13.6.1</code></pre></div></figure>\n<h4 id=\"如果安装时出现gpgkey验证错误，只需在安装时明确指明不进行gpgkey验证\">如果安装时出现gpgkey验证错误，只需在安装时明确指明不进行gpgkey验证</h4>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">yum install gitlab-ce -y --nogpgcheck</code></pre></div></figure>\n<h3 id=\"2-3-gitlab的配置\">2.3 gitlab的配置</h3>\n<p>配置文件位置  /etc/gitlab/gitlab.rb</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">[root@centos7 test]# vim /etc/gitlab/gitlab.rb\n[root@centos7 test]# grep \"^[a-Z]\" /etc/gitlab/gitlab.rb\nexternal_url 'http://10.0.0.51'  # 这里一定要加上http://</code></pre></div></figure>\n<h4 id=\"配置邮件服务\">配置邮件服务</h4>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-ruby\" data-language=\"ruby\"><code class=\"language-ruby\">gitlab_rails['smtp_enable'] = true\ngitlab_rails['smtp_address'] = \"smtp.qq.com\" gitlab_rails['smtp_port'] = 25 gitlab_rails['smtp_user_name'] = \"hgzerowzh@qq.com\"  # 自己的qq邮箱账号\ngitlab_rails['smtp_password'] = \"xxx\"  # 开通smtp时返回的授权码\ngitlab_rails['smtp_domain'] = \"qq.com\" gitlab_rails['smtp_authentication'] = \"login\" gitlab_rails['smtp_enable_starttls_auto'] = true\ngitlab_rails['smtp_tls'] = false\ngitlab_rails['gitlab_email_from'] = \"hgzerowzh@qq.com\"  # 指定发送邮件的邮箱地址\nuser[\"git_user_email\"] = \"shit@qq.com\"   # 指定接收邮件的邮箱地址</code></pre></div></figure>\n<p><strong>修改好配置文件后，要使用 gitlab-ctl reconfigure 命令重载一下配置文件，否则不生效。</strong></p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-none\"><code class=\"language-none\">gitlab-ctl reconfigure # 重载配置文件</code></pre></div></figure>\n<h3 id=\"2-4-Gitlab常用命令\">2.4 Gitlab常用命令</h3>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-ruby\" data-language=\"ruby\"><code class=\"language-ruby\">gitlab-ctl start         # 启动所有 gitlab 组件\ngitlab-ctl stop          # 停止所有 gitlab 组件\ngitlab-ctl restart       # 重启所有 gitlab 组件\ngitlab-ctl status        # 查看服务状态\ngitlab-ctl reconfigure   # 启动服务\ngitlab-ctl show-config   # 验证配置文件\ngitlab-ctl tail          # 查看日志\ngitlab-rake gitlab:check SANITIZE=true --trace    # 检查gitlab\nvim /etc/gitlab/gitlab.rb # 修改默认的配置文件</code></pre></div></figure>\n<h2 id=\"Gitlab的使用\">Gitlab的使用</h2>\n<hr>\n<ul>\n<li>Gitlab安装好后，设置密码，管理账户为root</li>\n</ul>\n<h3 id=\"3-1-创建Group\"><strong>3.1 创建Group</strong></h3>\n<ul>\n<li>填上组名即可，这里组名为java</li>\n</ul>\n<p><img src=\"https://cimg1.17lai.site/data/2021/05/2820210528222105.png\" alt=\"\"></p>\n<p><img src=\"https://cimg1.17lai.site/data/2021/09/1320210913211347.png\" alt=\"\"></p>\n<h3 id=\"3-2-创建User\"><strong>3.2 创建User</strong></h3>\n<ul>\n<li>创建四个User：pm、dev1、dev2、dev3</li>\n</ul>\n<p><img src=\"https://cimg1.17lai.site/data/2021/05/2820210528222131.png\" alt=\"\"></p>\n<p><img src=\"https://cimg1.17lai.site/data/2021/05/2820210528222120.png\" alt=\"\"></p>\n<h3 id=\"3-3-添加User到Group中并授权\"><strong>3.3 添加User到Group中并授权</strong></h3>\n<p><img src=\"https://cimg1.17lai.site/data/2021/05/2820210528222140.png\" alt=\"\"></p>\n<h3 id=\"3-4-创建Project并配置SSH\"><strong>3.4 创建Project并配置SSH</strong></h3>\n<p><img src=\"https://cimg1.17lai.site/data/2021/05/2820210528222147.png\" alt=\"\"></p>\n<p><img src=\"https://cimg1.17lai.site/data/2021/05/2820210528222154.png\" alt=\"\"></p>\n<p><img src=\"https://cimg1.17lai.site/data/2021/05/2820210528222201.png\" alt=\"\"></p>\n<p><img src=\"https://cimg1.17lai.site/data/2021/05/2820210528222233.png\" alt=\"\"></p>\n<h3 id=\"3-5-在项目中添加成员\"><strong>3.5 在项目中添加成员</strong></h3>\n<p><img src=\"https://cimg1.17lai.site/data/2021/09/1320210913211335.png\" alt=\"\"></p>\n<p><img src=\"https://cimg1.17lai.site/data/2021/09/1320210913211726.png\" alt=\"\"></p>\n<h3 id=\"3-6-将本地文件推送到Gitlab\">3.6 将本地文件推送到Gitlab</h3>\n<h4 id=\"将app01项目克隆下来\">将app01项目克隆下来</h4>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">git clone git@10.0.0.51:java/app01.git # 初始化配置\ngit config --global user.name \"hgzero\" git config --global user.email \"hgzero@qq.com\"</code></pre></div></figure>\n<h4 id=\"在app01目录下新建一些文件\">在app01目录下新建一些文件</h4>\n<h4 id=\"推送到gitlab\">推送到gitlab</h4>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">git add .\ngit commit -m \"first edition\" git push origin master</code></pre></div></figure>\n<p><img src=\"https://cimg1.17lai.site/data/2021/09/1320210913211546.png\" alt=\"\"></p>\n<ol start=\"4\">\n<li>制定开发计划</li>\n</ol>\n<hr>\n<h3 id=\"4-1-创建开发计划\"><strong>4.1 创建开发计划</strong></h3>\n<ul>\n<li>项目：app01</li>\n<li>版本：v1.0</li>\n</ul>\n<p><img src=\"https://cimg1.17lai.site/data/2021/09/1320210913211325.png\" alt=\"\"></p>\n<h3 id=\"4-2-创建里程碑Milestones\"><strong>4.2 创建里程碑Milestones</strong></h3>\n<ul>\n<li>用pm账号登录gitlab后操作（先要在admin中设置pm账号的密码）</li>\n<li>要根据开发计划来创建Milestones</li>\n</ul>\n<p><img src=\"https://cimg1.17lai.site/data/2021/09/1320210913211538.png\" alt=\"\"></p>\n<p><img src=\"https://cimg1.17lai.site/data/2021/09/1320210913211719.png\" alt=\"\"></p>\n<p><img src=\"https://cimg1.17lai.site/data/2021/09/1320210913211315.png\" alt=\"\"></p>\n<p><img src=\"https://cimg1.17lai.site/data/2021/09/1320210913211303.png\" alt=\"\"></p>\n<h3 id=\"4-3-根据开发计划创建issue\">4.3 根据开发计划创建issue</h3>\n<ul>\n<li>创建4个issue，分派给dev1和dev2这两个开发人员</li>\n</ul>\n<p><img src=\"https://cimg1.17lai.site/data/2021/09/1320210913211529.png\" alt=\"\"></p>\n<p><img src=\"https://cimg1.17lai.site/data/2021/09/1320210913211304.png\" alt=\"\"></p>\n<p><img src=\"https://cimg1.17lai.site/data/2021/09/1320210913211711.png\" alt=\"\"></p>\n<p><img src=\"https://cimg1.17lai.site/data/2021/09/1320210913211520.png\" alt=\"\"></p>\n<p><img src=\"https://cimg1.17lai.site/data/2021/09/1320210913211514.png\" alt=\"\"></p>\n<p><img src=\"https://cimg1.17lai.site/data/2021/09/1320210913211252.png\" alt=\"\"></p>\n<h3 id=\"4-4-开发者登录账号查看分派的任务\">**4.4 开发者登录账号查看分派的任务 **</h3>\n<ul>\n<li>然后开发dev1登录gitlab，就能看到任务已经分配过来了</li>\n</ul>\n<p><img src=\"https://cimg1.17lai.site/data/2021/09/1320210913211513.png\" alt=\"\"></p>\n<h3 id=\"4-5-开发流程\"><strong>4.5 开发流程</strong></h3>\n<ul>\n<li>公司里的开发开始任务</li>\n</ul>\n<h4 id=\"1-先从仓库把项目拉下来\">1. 先从仓库把项目拉下来</h4>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">git clone git@10.0.0.51:java/app01.git\ncd app01/</code></pre></div></figure>\n<h4 id=\"2-先创建一个自己的分支，然后进行开发\">2.先创建一个自己的分支，然后进行开发</h4>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">git checkout -b index   # 创建一个叫index的分支，并切换到这个分支\ngit status # 3. 开始开发首页\necho \"&lt;h1&gt;welcome to this app&lt;/h1&gt;\" &gt; index.html  # 假设就开发了一个index页面</code></pre></div></figure>\n<h2 id=\"4-开发完成后，把项目传到仓库\">4. 开发完成后，把项目传到仓库</h2>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">git add .\ngit commit -m \"index\"</code></pre></div></figure>\n<h4 id=\"如果写成-git-commit-m-“close-2”-，则表示merge请求允许且merge成功之后，自动删除编号为-2的issue\">如果写成 git commit -m “close #2” ，则表示merge请求允许且merge成功之后，自动删除编号为#2的issue</h4>\n<h4 id=\"传到index分支\">传到index分支</h4>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">git push origin index</code></pre></div></figure>\n<h3 id=\"4-6-合并分支\"><strong>4.6 合并分支</strong></h3>\n<p><strong>1）开发dev1发送合并分支请求给pm</strong></p>\n<p><img src=\"https://cimg1.17lai.site/data/2021/09/1320210913211242.png\" alt=\"\"></p>\n<p><img src=\"https://cimg1.17lai.site/data/2021/09/1320210913211503.png\" alt=\"\"></p>\n<p><img src=\"https://cimg1.17lai.site/data/2021/09/1320210913211701.png\" alt=\"\"></p>\n<p><strong>2）pm收到开发的Merge请求后进行处理</strong></p>\n<ul>\n<li>使用pm登录，就可以看到pm已经收到了合并请求merge request</li>\n</ul>\n<p><img src=\"https://cimg1.17lai.site/data/2021/09/1320210913211231.png\" alt=\"\"></p>\n<p><img src=\"https://cimg1.17lai.site/data/2021/09/1320210913211502.png\" alt=\"\"></p>\n<p><img src=\"https://cimg1.17lai.site/data/2021/09/1320210913211647.png\" alt=\"\"></p>\n<p><img src=\"https://cimg1.17lai.site/data/2021/09/1320210913211221.png\" alt=\"\"></p>\n<p><strong>3）开发dev1确认任务完成</strong></p>\n<ul>\n<li>退出pm账户，登入dev1账户：</li>\n</ul>\n<p><img src=\"https://cimg1.17lai.site/data/2021/09/1320210913211220.png\" alt=\"\"></p>\n<ul>\n<li>或者点进去后，在侧边栏进行标识Done，然后已经完成的issue，可以将其Close</li>\n</ul>\n<p><img src=\"https://cimg1.17lai.site/data/2021/09/1320210913211454.png\" alt=\"\"></p>\n<ul>\n<li>这个时候Milestones的进度已经往前进了一些了：</li>\n</ul>\n<p><img src=\"https://cimg1.17lai.site/data/2021/09/1320210913211446.png\" alt=\"\"></p>\n<h3 id=\"4-7-开发其他功能\">4.7 开发其他功能</h3>\n<ul>\n<li>然后其他开发者或者自己再次进行开发时，先要把刚刚更新后的内容（master主干）拉回来，然后再进行开发</li>\n</ul>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">git checkout master  # 切换到master\ngit pull             # 从远端仓库拉取数据</code></pre></div></figure>\n<p>然后再进行其他操作</p>\n<h2 id=\"Gitlab备份恢复\">Gitlab备份恢复</h2>\n<hr>\n<h3 id=\"5-1-备份gitlab\">5.1 备份gitlab</h3>\n<p><strong>1）修改配置文件</strong></p>\n<ul>\n<li><strong>/etc/gitlab/gitlab.rb</strong></li>\n</ul>\n<h4 id=\"备份保存的位置，这里是默认位置，可修改成指定的位置\">备份保存的位置，这里是默认位置，可修改成指定的位置</h4>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-ruby\" data-language=\"ruby\"><code class=\"language-ruby\">gitlab_rails['backup_path'] = \"/var/opt/gitlab/backups\"</code></pre></div></figure>\n<h4 id=\"设置备份保存的时间，超过此时间的日志将会被新覆盖\">设置备份保存的时间，超过此时间的日志将会被新覆盖</h4>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-ruby\" data-language=\"ruby\"><code class=\"language-ruby\">gitlab_rails['backup_keep_time'] = 604800  # 这里是默认设置，保存7天</code></pre></div></figure>\n<h4 id=\"特别注意：-如果自定义了备份保存位置，则要修改备份目录的权限，比如：-chown-R-git-git-data-backup-gitlab\">特别注意： # 如果自定义了备份保存位置，则要修改备份目录的权限，比如： # chown -R git.git /data/backup/gitlab</h4>\n<ul>\n<li>配置完成后要重启以使配置生效</li>\n</ul>\n<h4 id=\"重读配置文件\">重读配置文件</h4>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-ruby\" data-language=\"ruby\"><code class=\"language-ruby\">gitlab-ctl reconfigure # 重启gitlab\ngitlab-ctl restart</code></pre></div></figure>\n<p><strong>2）设置定时任务</strong></p>\n<h4 id=\"每天凌晨2点定时创建备份-将一下内容写入到定时任务中-crontab-e\">每天凌晨2点定时创建备份 # 将一下内容写入到定时任务中 crontab -e</h4>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">0 2 * * * /usr/bin/gitlab-rake gitlab:backup:create # 备份策略建议： # 本地保留3到7天，在异地备份永久保存</code></pre></div></figure>\n<p><strong>3）备份时间的识别</strong></p>\n<h4 id=\"备份后的文件类似这样的形式：1494170842-gitlab-backup-tar，可以根据前面的时间戳确认备份生成的时间\">备份后的文件类似这样的形式：1494170842_gitlab_backup.tar，可以根据前面的时间戳确认备份生成的时间</h4>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">data -d  @1494170842</code></pre></div></figure>\n<h3 id=\"5-2-恢复gitlab\">5.2 恢复gitlab</h3>\n<p><strong>1）停止数据写入服务</strong></p>\n<h4 id=\"停止数据写入服务\">停止数据写入服务</h4>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">gitlab-ctl stop unicorn\ngitlab-ctl stop sidekiq</code></pre></div></figure>\n<p><strong>2）进行数据恢复并重启</strong></p>\n<h4 id=\"进行恢复\">进行恢复</h4>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">gitlab-rake gitlab:backup:restore BACKUP=1494170842  # 这个时间戳就是刚刚备份的文件前面的时间戳</code></pre></div></figure>\n<h4 id=\"重启\">重启</h4>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-ruby\" data-language=\"ruby\"><code class=\"language-ruby\">gitlab-ctl restart</code></pre></div></figure>\n<h2 id=\"gitlab邮件通知配置\">gitlab邮件通知配置</h2>\n<hr>\n<ul>\n<li>vim  /etc/gitlab/gitlab.rb</li>\n</ul>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-ruby\" data-language=\"ruby\"><code class=\"language-ruby\">gitlab_rails['time_zone'] = 'Asia/Shanghai' gitlab_rails['gitlab_email_enabled'] = true\ngitlab_rails['gitlab_email_from'] = 'example@163.com' # 填写发件人的邮箱地址\ngitlab_rails['gitlab_email_display_name'] = 'gitlab' gitlab_rails['smtp_enable'] = true\ngitlab_rails['smtp_address'] = \"smtp.163.com\"  # smtp服务器的地址,如网易的地址\ngitlab_rails['smtp_port'] = 25                 # 要注意如果使用了SSL/TLS的话,端口可能不是25\ngitlab_rails['smtp_user_name'] = \"smtp用户名\" gitlab_rails['smtp_password'] = \"smtp用户密码\" gitlab_rails['smtp_domain'] = \"163.com\" gitlab_rails['smtp_authentication'] = \"login\"</code></pre></div></figure>\n<ol start=\"7\">\n<li>\n<h2 id=\"使用SourceTree进行项目开发\">使用SourceTree进行项目开发</h2>\n</li>\n</ol>\n<hr>\n<h3 id=\"7-1-项目拉取\">7.1 项目拉取</h3>\n<ul>\n<li>先把项目克隆下来</li>\n</ul>\n<p><img src=\"https://cimg1.17lai.site/data/2021/09/1320210913211633.png\" alt=\"\"></p>\n<p><img src=\"https://cimg1.17lai.site/data/2021/09/1320210913211438.png\" alt=\"\"></p>\n<ul>\n<li>如果ssh的方式克隆失败，可能是因为SSH Key没找到，可以在这里添加</li>\n</ul>\n<p><img src=\"https://cimg1.17lai.site/data/2021/09/1320210913211211.png\" alt=\"\"></p>\n<p><img src=\"https://cimg1.17lai.site/data/2021/09/1320210913211201.png\" alt=\"\"></p>\n<h3 id=\"7-2-创建分支进行功能开发\">7.2 创建分支进行功能开发</h3>\n<p><strong>1）新建立一个叫“pay”的分支</strong></p>\n<p><img src=\"https://cimg1.17lai.site/data/2021/09/1320210913211618.png\" alt=\"\"></p>\n<p><img src=\"https://cimg1.17lai.site/data/2021/09/1320210913211430.png\" alt=\"\"></p>\n<p><strong>2）进行功能开发</strong></p>\n<p><img src=\"https://cimg1.17lai.site/data/2021/09/1320210913211152.png\" alt=\"\"></p>\n<h3 id=\"7-3-提交项目\">7.3 提交项目</h3>\n<p><strong>1）开发pay功能完成后进行提交</strong></p>\n<ul>\n<li>可以看到SourceTree中已经有“未提交的更改”</li>\n</ul>\n<p><img src=\"https://cimg1.17lai.site/data/2021/09/1320210913211422.png\" alt=\"\"></p>\n<p><img src=\"https://cimg1.17lai.site/data/2021/09/1320210913211144.png\" alt=\"\"></p>\n<p><strong>2）添加“用户信息”</strong></p>\n<p><img src=\"https://cimg1.17lai.site/data/2021/09/1320210913211143.png\" alt=\"\"></p>\n<p>** 3）进行提交**</p>\n<p><img src=\"https://cimg1.17lai.site/data/2021/09/1320210913211415.png\" alt=\"\"></p>\n<ul>\n<li>注释也可以写成  close #3    ，作用是提交完成后关闭3号issue</li>\n</ul>\n<h3 id=\"7-4-推送到仓库\"><strong>7.4 推送到仓库</strong></h3>\n<p><img src=\"https://cimg1.17lai.site/data/2021/09/1320210913211136.png\" alt=\"\"></p>\n<p><img src=\"https://cimg1.17lai.site/data/2021/09/1320210913211407.png\" alt=\"\"></p>\n<ul>\n<li>然后就可以在gitlab上进行发送merge请求了，后面就可以进行其他操作了</li>\n</ul>\n<h3 id=\"7-5-项目上线\">7.5 项目上线</h3>\n<p><strong>1）当所有工作完成之后，就可以进行上线了</strong></p>\n<p><img src=\"https://cimg1.17lai.site/data/2021/09/1320210913211135.png\" alt=\"\"></p>\n<p><strong>2）打标签</strong></p>\n<ul>\n<li>上线先打个标签</li>\n</ul>\n<p><img src=\"https://cimg1.17lai.site/data/2021/09/1320210913211127.png\" alt=\"\"></p>\n<p><img src=\"https://cimg1.17lai.site/data/2021/09/1320210913211124.png\" alt=\"\"></p>\n<p><img src=\"https://cimg1.17lai.site/data/2021/05/2820210528225256.png\" alt=\"\"></p>\n<p>** 3）删除无用分支**</p>\n<ul>\n<li>然后删除已经合并到主干中的不必要的分支，如index、pay等</li>\n<li>最后一定要注意时间一定要同步，不然会错乱</li>\n</ul>\n<h2 id=\"参考\">参考</h2>\n<ul>\n<li><a href=\"https://www.cnblogs.com/hgzero/p/14088215.html\">Praywu</a></li>\n</ul>\n<h2 id=\"系列教程\"><strong>系列教程</strong></h2>\n<p><a href=\"/atom.xml\"><i class=\"fas fa-rss\"></i>全部文章RSS订阅</a></p>\n<h3 id=\"Gitlab-使用系列\"><strong>Gitlab 使用系列</strong></h3>\n<p><a href=\"/categories/gitlab/atom.xml\"><i class=\"fas fa-rss\"></i><strong>Gitlab RSS 分类订阅</strong></a></p>\n<ul>\n<li><a href=\"/posts/acc13b70/\"><strong>Gitlab的安装及使用教程完全版</strong></a></li>\n<li><a href=\"/posts/29a820b3/\">破解Gitlab EE</a></li>\n<li><a href=\"/posts/d08eb7b/\">Gitlab的安装及使用</a></li>\n<li><a href=\"/posts/1879721e/\">CI/CD与Git Flow与GitLab</a></li>\n</ul>\n<h3 id=\"Devops系列\"><strong>Devops系列</strong></h3>\n<p><a href=\"/categories/devops/atom.xml\"><i class=\"fas fa-rss\"></i><strong>Devops 分类 RSS 订阅</strong></a></p>\n<ul>\n<li><a href=\"/posts/ab63eb8f/\">自建全套开源Devops开发系统</a></li>\n<li><a href=\"/posts/d32a07a7/\">Git介绍以及分支模型图解</a></li>\n<li><a href=\"/posts/39563241/\">三万字无坑搭建基于Docker+K8S+GitLab/SVN+Jenkins+Harbor持续集成交付环境</a></li>\n<li><a href=\"/posts/3437994a/\">DevOps系列—【Jenkinsfile+Dockerfile+nginx+vue】</a></li>\n<li><a href=\"/posts/f4c3ad41/\">项目开发管理工具推荐</a></li>\n<li><a href=\"/posts/acc13b70/\">Gitlab的安装及使用教程完全版</a></li>\n<li><a href=\"/posts/d08eb7b/\">Gitlab的安装及使用</a></li>\n<li><a href=\"/posts/78c3371/\">那些有用的Github工具介绍！Action、app、workflow等</a></li>\n</ul>\n<h2 id=\"项目管理系列介绍锦集\">项目管理系列介绍锦集</h2>\n<blockquote>\n<p>快速全面的介绍现代企业中项目管理相关知识！</p>\n</blockquote>\n\n    <div class=\"vkr-url-wrapper\">\n        <a href=\"/posts/d8b1e381/\"><img class=\"avatar\" src=\"/medias_webp/cover/guanli.webp\"></a>\n        <div class=\"desc-wrapper\">\n            <a href=\"/posts/d8b1e381/\">如何做一个完整的硬件项目的项目管理之简明教程</a>\n            <hr>\n            <div class=\"desc\">以一个硬件项目开发为例，介绍现代公司项目管理的一些基本工具和方法，给行业内外朋友一个初步印象，为广大从业者入门相关管理打下一个初步的，全局的基础！最后给出一个IPD端到端管理项目示例</div>\n        </div>\n    </div>\n    \n\n    <div class=\"vkr-url-wrapper\">\n        <a href=\"/posts/ca630feb/\"><img class=\"avatar\" src=\"/medias_webp/cover/5w2h.webp\"></a>\n        <div class=\"desc-wrapper\">\n            <a href=\"/posts/ca630feb/\">几种常用管理模型和方法</a>\n            <hr>\n            <div class=\"desc\">几种常用管理模型和方法：PDCA, 5W2H, SMART, SWOT, GROW, OKR, WBS 等，职场人员需要了解的知识。</div>\n        </div>\n    </div>\n    \n\n    <div class=\"vkr-url-wrapper\">\n        <a href=\"/posts/ac0df556/\"><img class=\"avatar\" src=\"/medias_webp/cover/guanli.webp\"></a>\n        <div class=\"desc-wrapper\">\n            <a href=\"/posts/ac0df556/\">PMBOK指南（第6版）</a>\n            <hr>\n            <div class=\"desc\">PMBOK 只是一套悬在空中的方法论，要想具体落地还需要具体的行业知识。两条腿，缺一不可！PMBOK 是基础中的基础知识，了解总是没有坏处的。是常识，不懂就没法做，但要做项目管理，光靠PMBOK远远不够。</div>\n        </div>\n    </div>\n    \n\n    <div class=\"vkr-url-wrapper\">\n        <a href=\"/posts/99be6dfb/\"><img class=\"avatar\" src=\"/medias_webp/cover/guanli.webp\"></a>\n        <div class=\"desc-wrapper\">\n            <a href=\"/posts/99be6dfb/\">如何做好竞品分析</a>\n            <hr>\n            <div class=\"desc\">竞品分析可以帮助我们更好地找准自身产品定位，发现自己产品的优劣所在，进而推动产品的优化迭代。</div>\n        </div>\n    </div>\n    \n\n    <div class=\"vkr-url-wrapper\">\n        <a href=\"/posts/a6477052/\"><img class=\"avatar\" src=\"/medias_webp/cover/guanli.webp\"></a>\n        <div class=\"desc-wrapper\">\n            <a href=\"/posts/a6477052/\">一大堆寓意深刻的管理故事锦集</a>\n            <hr>\n            <div class=\"desc\">几十个关于管理，经营的故事。寓教于乐，寓意深刻，在自己遗忘之前，记录保存下来。包括 扁鹊三兄弟，曲突徒薪，猎人与狗等等</div>\n        </div>\n    </div>\n    \n\n    <div class=\"vkr-url-wrapper\">\n        <a href=\"/posts/ec34b111/\"><img class=\"avatar\" src=\"/medias_webp/cover/renxing.webp\"></a>\n        <div class=\"desc-wrapper\">\n            <a href=\"/posts/ec34b111/\">人格类型分类总结归纳</a>\n            <hr>\n            <div class=\"desc\">本文介绍了什么是人格特质，怎么分类，并介绍了主流分析方法。后面着重介绍了敏感型人格和内向人格的优势，最后介绍了人格缺陷的一些分类和特点。与人打交道，这些了解不可或缺</div>\n        </div>\n    </div>\n    \n",
            "tags": [
                "gitlab",
                "git",
                "crack"
            ]
        }
    ]
}