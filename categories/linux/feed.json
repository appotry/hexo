{
    "version": "https://jsonfeed.org/version/1",
    "title": "夜法之书 • All posts by \"linux\" category",
    "description": "~软件驱动世界~个人独立技术博客，关于Linux,开源，Nas，Docker，嵌入式，理财，健身等主题！",
    "home_page_url": "https://blog.17lai.site",
    "items": [
        {
            "id": "https://blog.17lai.site/posts/43780ce1/",
            "url": "https://blog.17lai.site/posts/43780ce1/",
            "title": "Linux Bash Shell 使用技巧归纳整理",
            "date_published": "2023-12-21T11:41:13.000Z",
            "content_html": "<blockquote>\n<p>Linux就是未来！在Linux下，Bash的地位无可忽视，日常工作中涉及到Linux下的管理与操作基本都是在Bash中进行，因此，为了提高Linux下工作效率，自然而然的就变成了如何高效使用Bash的问题。</p>\n</blockquote>\n<span id=\"more\"></span>\n<h2 id=\"快捷键\">快捷键</h2>\n<blockquote>\n<p>常用快查指南，也可以看这里 <a href=\"/cheatsheets/Bash_Shortcuts.docset/Contents/Resources/Documents/\">Bash Shortcuts</a></p>\n</blockquote>\n<h3 id=\"编辑命令\">编辑命令</h3>\n<ul>\n<li>Ctrl + a ：移到命令行首</li>\n<li>Ctrl + e ：移到命令行尾</li>\n<li>Ctrl + f ：按字符前移（右向）</li>\n<li>Ctrl + b ：按字符后移（左向）</li>\n<li>Alt + f ：按单词前移（右向）</li>\n<li>Alt + b ：按单词后移（左向）</li>\n<li>Ctrl + xx：在命令行首和光标之间移动</li>\n<li>Ctrl + u ：从光标处删除至命令行首</li>\n<li>Ctrl + k ：从光标处删除至命令行尾</li>\n<li>Ctrl + w ：从光标处删除至字首</li>\n<li>Alt + d ：从光标处删除至字尾</li>\n<li>Ctrl + d ：删除光标处的字符</li>\n<li>Ctrl + h ：删除光标前的字符</li>\n<li>Ctrl + y ：粘贴至光标后</li>\n<li>Alt + c ：从光标处更改为首字母大写的单词</li>\n<li>Alt + u ：从光标处更改为全部大写的单词</li>\n<li>Alt + l ：从光标处更改为全部小写的单词</li>\n<li>Ctrl + t ：交换光标处和之前的字符</li>\n<li>Alt + t ：交换光标处和之前的单词</li>\n<li>Alt + Backspace：与 Ctrl + w <s>相同</s>类似，分隔符有些差别 [感谢 rezilla 指正]</li>\n</ul>\n<h3 id=\"重新执行命令\">重新执行命令</h3>\n<ul>\n<li>Ctrl + r：逆向搜索命令历史</li>\n<li>Ctrl + g：从历史搜索模式退出</li>\n<li>Ctrl + p：历史中的上一条命令</li>\n<li>Ctrl + n：历史中的下一条命令</li>\n<li>Alt + .：使用上一条命令的最后一个参数</li>\n</ul>\n<h3 id=\"控制命令\">控制命令</h3>\n<ul>\n<li>Ctrl + l：清屏</li>\n<li>Ctrl + o：执行当前命令，并选择上一条命令</li>\n<li>Ctrl + s：阻止屏幕输出</li>\n<li>Ctrl + q：允许屏幕输出</li>\n<li>Ctrl + c：终止命令</li>\n<li>Ctrl + z：挂起命令</li>\n</ul>\n<h3 id=\"Bang-命令\">Bang (!) 命令</h3>\n<ul>\n<li>!!：执行上一条命令</li>\n<li>!blah：执行最近的以 blah 开头的命令，如 !ls</li>\n<li>!blah:p：仅打印输出，而不执行</li>\n<li>!$：上一条命令的最后一个参数，与 Alt + . 相同</li>\n<li>!\n    <span id=\"mjx-104d771\">\n      <style>\n      #mjx-104d771{\n        display:contents;\n        mjx-assistive-mml {\n          user-select: text !important;\n          clip: auto !important;\n          color: rgba(0,0,0,0);\n        }\n        \nmjx-container[jax=\"SVG\"] {\n  direction: ltr;\n}\n\nmjx-container[jax=\"SVG\"] > svg {\n  overflow: visible;\n  min-height: 1px;\n  min-width: 1px;\n}\n\nmjx-container[jax=\"SVG\"] > svg a {\n  fill: blue;\n  stroke: blue;\n}\n\nmjx-assistive-mml {\n  position: absolute !important;\n  top: 0px;\n  left: 0px;\n  clip: rect(1px, 1px, 1px, 1px);\n  padding: 1px 0px 0px 0px !important;\n  border: 0px !important;\n  display: block !important;\n  width: auto !important;\n  overflow: hidden !important;\n  -webkit-touch-callout: none;\n  -webkit-user-select: none;\n  -khtml-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n}\n\nmjx-assistive-mml[display=\"block\"] {\n  width: 100% !important;\n}\n\nmjx-container[jax=\"SVG\"][display=\"true\"] {\n  display: block;\n  text-align: center;\n  margin: 1em 0;\n}\n\nmjx-container[jax=\"SVG\"][display=\"true\"][width=\"full\"] {\n  display: flex;\n}\n\nmjx-container[jax=\"SVG\"][justify=\"left\"] {\n  text-align: left;\n}\n\nmjx-container[jax=\"SVG\"][justify=\"right\"] {\n  text-align: right;\n}\n\ng[data-mml-node=\"merror\"] > g {\n  fill: red;\n  stroke: red;\n}\n\ng[data-mml-node=\"merror\"] > rect[data-background] {\n  fill: yellow;\n  stroke: none;\n}\n\ng[data-mml-node=\"mtable\"] > line[data-line], svg[data-table] > g > line[data-line] {\n  stroke-width: 70px;\n  fill: none;\n}\n\ng[data-mml-node=\"mtable\"] > rect[data-frame], svg[data-table] > g > rect[data-frame] {\n  stroke-width: 70px;\n  fill: none;\n}\n\ng[data-mml-node=\"mtable\"] > .mjx-dashed, svg[data-table] > g > .mjx-dashed {\n  stroke-dasharray: 140;\n}\n\ng[data-mml-node=\"mtable\"] > .mjx-dotted, svg[data-table] > g > .mjx-dotted {\n  stroke-linecap: round;\n  stroke-dasharray: 0,140;\n}\n\ng[data-mml-node=\"mtable\"] > g > svg {\n  overflow: visible;\n}\n\n[jax=\"SVG\"] mjx-tool {\n  display: inline-block;\n  position: relative;\n  width: 0;\n  height: 0;\n}\n\n[jax=\"SVG\"] mjx-tool > mjx-tip {\n  position: absolute;\n  top: 0;\n  left: 0;\n}\n\nmjx-tool > mjx-tip {\n  display: inline-block;\n  padding: .2em;\n  border: 1px solid #888;\n  font-size: 70%;\n  background-color: #F8F8F8;\n  color: black;\n  box-shadow: 2px 2px 5px #AAAAAA;\n}\n\ng[data-mml-node=\"maction\"][data-toggle] {\n  cursor: pointer;\n}\n\nmjx-status {\n  display: block;\n  position: fixed;\n  left: 1em;\n  bottom: 1em;\n  min-width: 25%;\n  padding: .2em .4em;\n  border: 1px solid #888;\n  font-size: 90%;\n  background-color: #F8F8F8;\n  color: black;\n}\n\nforeignObject[data-mjx-xml] {\n  font-family: initial;\n  line-height: normal;\n  overflow: visible;\n}\n\nmjx-container[jax=\"SVG\"] path[data-c], mjx-container[jax=\"SVG\"] use[data-c] {\n  stroke-width: 3;\n}\n\ng[data-mml-node=\"xypic\"] path {\n  stroke-width: inherit;\n}\n\n.MathJax g[data-mml-node=\"xypic\"] path {\n  stroke-width: inherit;\n}\n\n      }\n      </style>\n      <mjx-container class=\"MathJax\" jax=\"SVG\" style=\"position: relative;\"><svg style=\"vertical-align: -0.452ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"14.337ex\" height=\"2.149ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -750 6336.8 950\" aria-hidden=\"true\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mo\"><path data-c=\"3A\" d=\"M78 370Q78 394 95 412T138 430Q162 430 180 414T199 371Q199 346 182 328T139 310T96 327T78 370ZM78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(555.8,0)\"><path data-c=\"1D45D\" d=\"M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(1058.8,0)\"><text data-variant=\"italic\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\" font-style=\"italic\">：</text></g><g data-mml-node=\"mi\" transform=\"translate(2058.8,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">打</text></g><g data-mml-node=\"mi\" transform=\"translate(3058.8,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">印</text></g><g data-mml-node=\"mi\" transform=\"translate(4058.8,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">输</text></g><g data-mml-node=\"mi\" transform=\"translate(5058.8,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">出</text></g><g data-mml-node=\"mo\" transform=\"translate(6058.8,0)\"><path data-c=\"21\" d=\"M78 661Q78 682 96 699T138 716T180 700T199 661Q199 654 179 432T158 206Q156 198 139 198Q121 198 119 206Q118 209 98 431T78 661ZM79 61Q79 89 97 105T141 121Q164 119 181 104T198 61Q198 31 181 16T139 1Q114 1 97 16T79 61Z\"></path></g></g></g></svg><mjx-assistive-mml unselectable=\"on\" display=\"inline\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mo>:</mo><mi>p</mi><mi>：</mi><mi mathvariant=\"normal\">打</mi><mi mathvariant=\"normal\">印</mi><mi mathvariant=\"normal\">输</mi><mi mathvariant=\"normal\">出</mi><mo>!</mo></math></mjx-assistive-mml></mjx-container>\n    </span>\n   的内容</li>\n<li>!*：上一条命令的所有参数</li>\n<li>!<em>:p：打印输出 !</em> 的内容</li>\n<li><code>^blah</code>：删除上一条命令中的 blah</li>\n<li><code>^blah^foo</code>：将上一条命令中的 blah 替换为 foo</li>\n<li><code>^blah^foo^</code>：将上一条命令中所有的 blah 都替换为 foo</li>\n</ul>\n<blockquote>\n<p>详细介绍</p>\n</blockquote>\n<p>快捷键的一些说明：</p>\n<ol>\n<li>CTRL=C：这个键是指PC键盘上的Ctrl键</li>\n<li>ALT=M：这个键是PC键盘上的ALT键，如果你键盘上没有这个键，可以尝试使用ESC键代替</li>\n<li>SHIFT=S：此键是PC上的Shift键</li>\n<li>ESC=E：这个键是PC键盘上的ESC键，此键一般在键盘的左上角</li>\n<li>BACKSPACE=DEL：此键是是PC键盘上的Backspace键，一般位于主键盘区的右上角</li>\n<li>文中”[]“括住的为快捷键内容，”-”两边的内容是按住左边键，再按右边键获得，”,”逗号两边的内容是先按左边键，松开后再按右边键。如：[CTRL-v]是表示按下Ctrl键之后，不要松开，再按下v键。</li>\n<li>默认的情况下，快捷键的组成格式是：&lt;CTRL | ALT | ESC &gt;-[SHIFT-]<char>。即由Ctrl、Alt、Esc之一开头，中划线，Shift，中划线，和一个字符组成。其中，中括号内的Shift和”-”有时可省略。</li>\n<li>默认情况下，快捷键只有最后一个为字符，其他的键值均为功能键</li>\n<li>出现[CTRL-?]这类快捷键，由于”?”是需要使用Shift按键才能获得的字符，因此此类快捷键默认使用的是[CTRL-SHIFT-?]</li>\n</ol>\n<p>要注意，在Bash里面，快捷键可能会被写成八进制或者十六进制的形式（跟在转义符后面）; 脚本文件中的快捷键并不是总能起作用的。另外快捷键有个规律，<em>Ctrl开头的快捷键一般是针对字符的，而Alt开头的快捷键一般是针对词的</em>。</p>\n<p>Bash下，如果使用的是shell脚本文件，快捷键不一定是一样的，有的时候会出现同一个快捷键有不同的表现，这种情况一般是由于Bash所处的模式不同而引起的，你可以通过set命令来调整模式：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">set -o emacs\n##切到emacs模式\nset -o vi\n##切到vi模式\nset -o\n## 查看当前选项的设置状态</code></pre></div></figure>\n<p>这个是Bash的option选项，你可以根据具体情况进行设置，本文使用的是emacs模式。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">快捷键</th>\n<th style=\"text-align:left\">快捷键说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">CTRL-A</td>\n<td style=\"text-align:left\">将光标移到行首（在命令行下）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">CTRL-B</td>\n<td style=\"text-align:left\">退格 (非破坏性的)，这个只是将光标位置往回移动一个位置。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">CTRL-C</td>\n<td style=\"text-align:left\">中断，终结一个前台作业。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">CTRL-D</td>\n<td style=\"text-align:left\">“EOF” (文件结尾：end of file)。它用于表示标准输入（stdin）的结束。在控制台或xterm 窗口输入文本时，CTRL-D 删除在光标下的字符。从一个shell中退出 (类似于exit)。如果没有字符存在，CTRL-D 则会登出该会话。在一个xterm窗口中，则会产生关闭此窗口的效果。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">CTRL-E</td>\n<td style=\"text-align:left\">将光标移动到行尾（在命令行下）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">CTRL-F</td>\n<td style=\"text-align:left\">将光标向前移动一个字符（在命令行下）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">CTRL-G</td>\n<td style=\"text-align:left\">BEL。在一些老式打印机终端上，这会引发一个响铃。在xterm终端上可能是哔的一声。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">CTRL-H</td>\n<td style=\"text-align:left\">擦除(Rubout)(破坏性的退格)。在光标往回移动的时候，同时擦除光标前的一个字符。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">CTRL-I</td>\n<td style=\"text-align:left\">水平制表符。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">CTRL-J</td>\n<td style=\"text-align:left\">新行(换行[line feed]并到行首)。在脚本中，也可能表示为八进制形式(‘/012′)或十六进制形式(‘/x0a’)。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">CTRL-K</td>\n<td style=\"text-align:left\">垂直制表符(Vertical tab)。在控制台或 xterm 窗口输入文本时，CTRL-K会删除从光标所在处到行尾的所有字符。在脚本中，也可能表示为八进制形式(‘/013′)或十六进制形式(‘/x0b’)。在脚本中，CTRL-K可能会有不一样的行为，下面的例子给出其不一样的行为：<code>#!/bin/bash ## 一个CTRL-K垂直制表符的例子 var=$'/x0aBottom Line/x0bTop line/x0a' ## 直接输出 echo &quot;$var&quot; ## 使用col来过滤控制字符 echo &quot;$var&quot; | col ## 上面的显示将会不一样 exit 0</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">CTRL-L</td>\n<td style=\"text-align:left\">跳纸，换页(Formfeed)，清屏。清空终端屏幕。在终端上，这个命令的作用和clear命令一样。但当这个命令发送到打印机时，Ctrl-L会直接跳到纸张(Paper sheet)的末尾。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">CTRL-M</td>\n<td style=\"text-align:left\">回车(Carriage return)。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">CTRL-N</td>\n<td style=\"text-align:left\">擦除从history缓冲区召回的一行文本（在命令行下）。如果当前输入是历史记录中选择的时候，这个是从这个历史记录开始，每按一次，是更接近的一条命令。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">CTRL-O</td>\n<td style=\"text-align:left\">产生一个新行（在命令行下）。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">CTRL-P</td>\n<td style=\"text-align:left\">从history缓冲区召回上一次的命令（在命令行下）。此快捷键召回的顺序是由近及远的召回，即按一次，召回的是前一次的命令，再按一次，是召回上一次之前的命令，这和CTRL-N都是以当前的输入为起点，但是两个命令操作刚好相反，CTRL-N是从起点开始由远及近（如果起点是历史命令的话）。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">CTRL-Q</td>\n<td style=\"text-align:left\">Resume (XON)。恢复/解冻，这个命令是恢复终端的stdin用的，可参见CTRL-S。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">CTRL-R</td>\n<td style=\"text-align:left\">回溯搜索(Backwards search)history缓冲区内的文本（在命令行下）。注意：按下之后，提示符会变成(reverse-i-search)”:输入的搜索内容出现在单引号内，同时冒号后面出现最近最匹配的历史命令。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">CTRL-S</td>\n<td style=\"text-align:left\">Suspend(XOFF)，挂起。这个是冻结终端的stdin。要恢复可以按CTRL-Q。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">CTRL-T</td>\n<td style=\"text-align:left\">交换光标位置与光标的前一个位置的字符内容（在命令行下）。比如：echo $var;，假设光标在a上，那么，按下C-T之后，v和a将会交换位置：echo $avr;。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">CTRL-U</td>\n<td style=\"text-align:left\">擦除从光标位置开始到行首的所有字符内容。在某些设置下，CTRL-U会不以光标位置为参考而删除整行的输入。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">CTRL-V</td>\n<td style=\"text-align:left\">在输入文本的时候，按下C-V之后，可以插入控制字符。比如：echo -e '/x0a’;和echo <CTRL-V><CTRL-J>;这两种效果一样。这点功能在文本编辑器内非常有效。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">CTRL-W</td>\n<td style=\"text-align:left\">当在控制台或一个xterm窗口敲入文本时, CTRL-W 会删除从在光标处往后（回）的第一个空白符之间的内容。在某些设置里, CTRL-W 删除光标往后（回）到第一个非文字和数字之间的字符。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">CTRL-X</td>\n<td style=\"text-align:left\">在某些文字处理程序中，这个控制字符将会剪切高亮的文本并且将它复制到剪贴板中。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">CTRL-Y</td>\n<td style=\"text-align:left\">将之前已经清除的文本粘贴回来（主要针对CTRL-U或CTRL-W）。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">CTRL-Z</td>\n<td style=\"text-align:left\">暂停一个前台的作业；在某些文本处理程序中也作为替换操作；在MSDOS文件系统中作为EOF（End-of-file)字符。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">CTRL-/</td>\n<td style=\"text-align:left\">退出。和CTRL-C差不多，也可能dump一个”core”文件到你的工作目录下(这个文件可能对你没用)。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">CTRL-/</td>\n<td style=\"text-align:left\">撤消操作，Undo。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">CTRL-_</td>\n<td style=\"text-align:left\">撤消操作。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">CTRL-xx</td>\n<td style=\"text-align:left\">在行首和光标两个位置间进行切换，此处是两个”x”字符。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ALT-B</td>\n<td style=\"text-align:left\">光标往回跳一个词，词以非字母为界(跳动到当前光标所在词的开头)。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ALT-F</td>\n<td style=\"text-align:left\">光标往前跳一个词(移动到光标所在词的末尾)。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ALT-D</td>\n<td style=\"text-align:left\">删除光标所在位置到光标所在词的结尾位置的所有内容(如果光标是在词开头，则删除整个词)。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ALT-BASKSPACE</td>\n<td style=\"text-align:left\">删除光标所在位置到词开头的所有内容。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ALT-C</td>\n<td style=\"text-align:left\">将光标所在位置的字母转为大写(如果光标在一个词的起始位置或之前，则词首字母大写)。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ALT-U</td>\n<td style=\"text-align:left\">将光标所在位置到词尾的所有字母转为大写。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ALT-L</td>\n<td style=\"text-align:left\">将光标位置到词尾的所有字母转为小写。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ALT-R</td>\n<td style=\"text-align:left\">取消所有变更，并将当前行恢复到在历史记录中的原始状态(前提是当前命令是从历史记录中来的，如果是手动输入，则会清空行)。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ALT-T</td>\n<td style=\"text-align:left\">当光标两侧都存在词的时候，交换光标两侧词的位置。如：abc <ALT-T>bcd -&gt; bcd abc</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ALT-.</td>\n<td style=\"text-align:left\">使用前一次命令的最后一个词(命令本身也是一个词，参见后一篇的Bang命令中的词指示符概念)。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ALT-_</td>\n<td style=\"text-align:left\">同ALT-.。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ALT-数值</td>\n<td style=\"text-align:left\">这个数值可以是正或者是负，这个键单独没有作用，必须后面再接其他内容，如果后面是字符，则表示重复次数。如：[ALT-10,k]则光标位置会插入10个k字符(负值在这种情况下无效)；如果后面接的是命令，则数字会影响后面命令的执行结果，如：[ALT–10,CTRL-D]则向CTRL-D默认方向相反(负数)的方向执行10次操作。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ALT-&lt;</td>\n<td style=\"text-align:left\">移动到历史记录中的第一行命令。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ALT-&gt;</td>\n<td style=\"text-align:left\">移动到历史的最后一行，即当前正在输入的行(没有输入的情况下为空)。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ALT-P</td>\n<td style=\"text-align:left\">从当前行开始向前搜索，有必要则向”上”移动，移动时，使用非增量搜索查找用户提供的字符串。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ALT-N</td>\n<td style=\"text-align:left\">从当前行开始向后搜索，如果有必要向”下”移动，移动时，使用非增量搜索查找用户提供的字符串。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ALT-CTRL-Y</td>\n<td style=\"text-align:left\">在标志点上插入前一个命令的第一个参数(一般是前一行的第二个词)。如果有参数n，则插入前一个命令的第n个词(前一行的词编号从0开始，见历史扩展)。负的参数将插入冲前一个命令的结尾开始的第n个词。参数n通过M-No.的方式传递，如：[ALT-0,ALT-CTRL-Y]插入前一个命令的第0个词(命令本身)。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ALT-Y</td>\n<td style=\"text-align:left\">轮询到删除环，并复制新的顶端文本。只能在yank[CTRL-Y]或者yank-pop[M-Y]之后使用这个命令。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ALT-?</td>\n<td style=\"text-align:left\">列出能够补全标志点前的条目。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ALT-*</td>\n<td style=\"text-align:left\">把能够补全[ALT-?]命令能生成的所有文本条目插入到标志点前。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ALT-/</td>\n<td style=\"text-align:left\">试图对标志点前的文本进行文件名补全。[CTRL-X,/]把标志点前的文本当成文件名并列出可以补全的条目。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ALT-~</td>\n<td style=\"text-align:left\">把标志点前的文本当成用户名并试图进行补全。[CTRL-X,~]列出可以作为用户名补全标志点前的条目。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ALT-$</td>\n<td style=\"text-align:left\">把标志点前的文本当成Shell变量并试图进行补全。[CTRL-X,$]列出可以作为变量补全标志点前的条目。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ALT-@</td>\n<td style=\"text-align:left\">把标志点前的文本当成主机名并试图进行补全。[CTRL-X,@]列出可以作为主机补全标志点前的条目。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ALT-!</td>\n<td style=\"text-align:left\">把标志点前的文本当成命令名并试图进行补全。进行命令名补全时会依次使用别名、保留字、Shell函数、shell内部命令，最后是可执行文件名。[CTRL-X,!]把标志点前的文本当成命令名并列出可补全的条目。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ALT-TAB</td>\n<td style=\"text-align:left\">把标志点前的文本与历史记录中的文本进行比较以寻找匹配的并试图进行补全。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ALT-{</td>\n<td style=\"text-align:left\">进行文件名补全，把可以补全的条目列表放在大括号之间，让shell可以使用。</td>\n</tr>\n</tbody>\n</table>\n<p>在Bash下，如果能够妥善的使用快捷键，在Linux系统的操作会变得非常快捷，比如我们在使用cat创建一个文件时，我们可以使用快捷键[CTRL-D]：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">## 不用快捷键\ncat &gt;&gt;&#x2F;tmp&#x2F;test&lt;&lt;_EOF\n##这里是内容\n##最后我们要在新行里面输入_EOF\n##cat见到_EOF才会将内容写到文件中\n\n##使用快捷键\ncat &gt;&gt;&#x2F;tmp&#x2F;test\n##这里输入内容\n##输入完毕之后，直接[CTRL-D]结束</code></pre></div></figure>\n<p>有的时候我们需要创建一个文件，而后对这个文件进行操作：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">touch &#x2F;tmp&#x2F;a-test-file-from-blog.useasp.net\n\n## 不使用快捷键，文件名要重新输入\nchmod u+x &#x2F;tmp&#x2F;a-test-file-from-blog.useasp.net\n\n##使用快捷键\nchmod u+x &lt;ALT-.&gt;\n## 快捷键[M-.]自动会将上面的最后一个参数附加</code></pre></div></figure>\n<p>怎么样，有没有更有效率？</p>\n<p>当然，Bash的快捷键只有在不断的使用中，才能达到真正的高效，在开始连要用那个快捷键都要思考半天的情况下，高效是很难的——但磨刀不误砍材工，前期的投入是值得的。</p>\n<p>如果你想自己的Bash有那么一些不同，你也可以自己自定义快捷键，使用bind命令即可，Bash中的快捷键其实是Readline来提供的，因此，这里快捷键的设置其实就是配置Readline，Readline中分两种快捷键，一种是Readline内部的函数快捷键，另外一种是执行Shell命令，设置的时候稍有不同：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">##查看Readline中可以使用的函数名称\nbind -l\n##查看当前绑定的案件配置与其对应的功能\nbind -v\n##已经绑定的快捷键\nbind -p\n\n##绑定自定义执行命令shell命令的快捷键\nbind -x &#39;&quot;&#x2F;C-x&#x2F;C-l&quot;:ls -al&#39;\n## 绑定后，按[C-x,C-L]就能执行ls -al\n\n## 绑定内置函数功能\nbind &quot;&#x2F;C-x&quot;:backword-delte-char\n##这个是这行Readline库中的函数backword-delte-char</code></pre></div></figure>\n<p>这种设置只是针对当前的会话有效，一旦会话丢失，这样设置的快捷键就会丢失，为了能够让设置的快捷键永久有效，我们就需要将快捷键的配置写入文件。在Linux系统中，能永久保存快捷键的地方有两个，全局和用户的配置文件，全局的是/etc/inputrc，而用户的是在用户的根目录下~/.inputrc，全局的会影响所有的用户，而用户根目录下的只会对相应的用户产生影响。inputrc文件的大概样子像下面这样：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">## 本例来自CentOS6.4的默认配置文件\n$if mode&#x3D;emacs\n\n# for linux console and RH&#x2F;Debian xterm\n&quot;&#x2F;e[1~&quot;: beginning-of-line\n&quot;&#x2F;e[4~&quot;: end-of-line\n# commented out keymappings for pgup&#x2F;pgdown to reach begin&#x2F;end of history\n#&quot;&#x2F;e[5~&quot;: beginning-of-history\n#&quot;&#x2F;e[6~&quot;: end-of-history\n&quot;&#x2F;e[5~&quot;: history-search-backward\n&quot;&#x2F;e[6~&quot;: history-search-forward\n&quot;&#x2F;e[3~&quot;: delete-char\n&quot;&#x2F;e[2~&quot;: quoted-insert\n&quot;&#x2F;e[5C&quot;: forward-word\n&quot;&#x2F;e[5D&quot;: backward-word\n&quot;&#x2F;e[1;5C&quot;: forward-word\n&quot;&#x2F;e[1;5D&quot;: backward-word\n\n# for rxvt\n&quot;&#x2F;e[8~&quot;: end-of-line\n&quot;&#x2F;eOc&quot;: forward-word\n&quot;&#x2F;eOd&quot;: backward-word\n\n# for non RH&#x2F;Debian xterm, can&#39;t hurt for RH&#x2F;DEbian xterm\n&quot;&#x2F;eOH&quot;: beginning-of-line\n&quot;&#x2F;eOF&quot;: end-of-line\n\n# for freebsd console\n&quot;&#x2F;e[H&quot;: beginning-of-line\n&quot;&#x2F;e[F&quot;: end-of-line\n$endif</code></pre></div></figure>\n<p>说明：</p>\n<ol>\n<li>\n<p>在配置文件中，/C代表CTRL，/M代表ALT，/e代表ESC，//是反斜杠/，/'是单引号，/&quot;是双引号；</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">&#x2F;C-    control prefix\n&#x2F;M-    meta prefix\n&#x2F;e     an escape character\n&#x2F;&#x2F;     backslash\n&#x2F;&quot;     literal &quot;, a double quote\n&#x2F;’     literal ’, a single quote</code></pre></div></figure>\n</li>\n<li>\n<p>如果要查看某一个功能键的字符序列可以通过[CTRL-V]来实现，或者输入cat后回车，进入编辑中，直接按快捷键</p>\n</li>\n<li>\n<p>配置文件中可能会使用八进制或者十六进制来表示字符。</p>\n</li>\n</ol>\n<p>如果我们针对常用的操作设置成适当的快捷键，也许以前需要巴拉巴拉敲上半天的命令，你一个快捷键就能搞定，这无疑将会大大的提高我们的工作效率！</p>\n<h2 id=\"Bash-别名\">Bash 别名</h2>\n<p><strong>10 个方便的 Bash 别名</strong></p>\n<p>1、 你有几次遇到需要解压 <code>.tar</code> 文件但无法记住所需的确切参数？别名可以帮助你！只需将以下内容添加到 <code>.bash_profile</code> 中，然后使用 <code>untar FileName</code> 解压缩任何 <code>.tar</code> 文件。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">alias untar&#x3D;&#39;tar -zxvf &#39;</code></pre></div></figure>\n<p>2、 下载文件时，如果出现问题想要恢复下载？</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">alias wget&#x3D;&#39;wget -c &#39;</code></pre></div></figure>\n<p>3、 快速为新的帐户生成随机的 20 个字符的密码。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">alias getpass&#x3D;&quot;openssl rand -base64 20&quot;</code></pre></div></figure>\n<p>4、 对下载的文件进行校验和测试。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">alias sha&#x3D;&#39;shasum -a 256 &#39;</code></pre></div></figure>\n<p>5、 普通的 <code>ping</code> 将永远持续下去。通常我们不希望这样，让我们将其限制在五次之内。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">alias ping&#x3D;&#39;ping -c 5&#39;</code></pre></div></figure>\n<p>6、 在任何你想要的文件夹中启动一个 <code>Web</code> 服务器。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">alias www&#x3D;&#39;python -m SimpleHTTPServer 8000&#39;</code></pre></div></figure>\n<p>7、 想知道你的网络有多快？只需下载 <code>Speedtest-cli</code> 并使用此别名即可。你可以使用 <code>speedtest-cli --list</code> 命令选择离你所在位置更近的服务器。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">alias speed&#x3D;&#39;speedtest-cli --server 2406 --simple&#39;</code></pre></div></figure>\n<p>8、 在命令行中快速获取你的外部 <code>IP</code> 地址。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">alias ipe&#x3D;&#39;curl ipinfo.io&#x2F;ip&#39;</code></pre></div></figure>\n<p>9、 在命令行中快速获取你的本地 <code>IP</code> 地址。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">alias ipi&#x3D;&#39;ipconfig getifaddr en0&#39;</code></pre></div></figure>\n<p>10、 快速清空屏幕。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">alias c&#x3D;&#39;clear&#39;</code></pre></div></figure>\n<p>如你所见，<code>Bash</code> 别名是一种在命令行上简化操作的超级简便方法。想了解更多信息？建议你 <code>Google</code> 搜索 <code>“Bash 别名”</code> 或在 <code>Github</code> 中找找看。</p>\n<h2 id=\"Bash-参数处理\">Bash 参数处理</h2>\n<p>在编写shell程序时经常需要处理命令行参数，本文描述在bash下的命令行处理方式。<br>\n选项与参数：<br>\n如下命令行：</p>\n <figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">.&#x2F;test.sh -f config.conf -v --prefix&#x3D;&#x2F;home</code></pre></div></figure>\n<p>-f为选项，它需要一个参数，即config.conf, -v 也是一个选项，但它不需要参数。<br>\n–prefix我们称之为一个长选项，即选项本身多于一个字符，它也需要一个参数，用等号连接，当然等号不是必须的，/home可以直接写在–prefix后面，即–prefix/home,更多的限制后面具体会讲到。<br>\n在bash中，可以用以下三种方式来处理命令行参数，每种方式都有自己的应用场景。</p>\n<ul>\n<li>手工处理方式</li>\n<li>getopts</li>\n<li>getopt<br>\n依次讨论这三种处理方式。</li>\n</ul>\n<h3 id=\"手工处理方式\">手工处理方式</h3>\n<p>在手工处理方式中，首先要知道几个变量，还是以上面的命令行为例：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">*    $0 ： .&#x2F;test.sh,即命令本身，相当于c&#x2F;c++中的argv[0]\n*    $1 ： -f,第一个参数.\n*    $2 ： config.conf\n*    $3, $4 ... ：类推。\n*    $#  参数的个数，不包括命令本身，上例中$#为4.\n*    $@ ：参数本身的列表，也不包括命令本身，如上例为 -f config.conf -v --prefix&#x3D;&#x2F;home\n*    $* ：和$@相同，但&quot;$*&quot; 和 &quot;$@&quot;(加引号)并不同，&quot;$*&quot;将所有的参数解释成一个字符串，而&quot;$@&quot;是一个参数数组。</code></pre></div></figure>\n<p>例子：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#!&#x2F;bin&#x2F;bash  \nfor arg in &quot;$*&quot;  \ndo  \n   echo $arg  \ndone  \nfor arg in &quot;$@&quot;  \ndo  \n echo $arg  \ndone  </code></pre></div></figure>\n<p>执行./test.sh -f config.conf -n 10 会打印：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">-f config.conf -n 10    #这是&quot;$*&quot;的输出  \n-f   #以下为$@的输出  \nconfig.conf  \n-n  \n10  </code></pre></div></figure>\n<p>所以，手工处理的方式即对这些变量的处理。因为手工处理高度依赖于你在命令行上所传参数的位置，所以一般都只用来处理较简单的参数。</p>\n<p>例如：<br>\n<code>./test.sh 10  </code>而很少使用./test -n 10这种带选项的方式。 典型用法为：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#!&#x2F;bin&#x2F;bash  \nif [ x$1 !&#x3D; x ]  \nthen  \n    #...有参数  \nelse  \nthen  \n    #...没有参数  \nfi  </code></pre></div></figure>\n<p>为什么要使用 x$1 != x 这种方式来比较呢？想像一下这种方式比较：<br>\n<code>if [ -n $1 ]  #$1不为空  </code>但如果用户不传参数的时候，$1为空，这时 就会变成 [ -n ] ,所以需要加一个辅助字符串来进行比较。<br>\n手工处理方式能满足大多数的简单需求，配合shift使用也能构造出强大的功能，但在要处理复杂选项的时候建议用下面的两种方法。</p>\n<h3 id=\"getopts-getopt\">getopts/getopt</h3>\n<p>处理命令行参数是一个相似而又复杂的事情，为此，c提供了getopt/getopt_long等函数，<br>\nc++的boost提供了options库，在shell中，处理此事的是getopts和getopt.<br>\ngetopts和getopt功能相似但又不完全相同，其中getopt是独立的可执行文件，而getopts是由bash内置的。<br>\n先来看看参数传递的典型用法:</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">* .&#x2F;test.sh -a -b -c  ： 短选项，各选项不需参数  \n* .&#x2F;test.sh -abc   ： 短选项，和上一种方法的效果一样，只是将所有的选项写在一起。  \n* .&#x2F;test.sh -a args -b -c ：短选项，其中-a需要参数，而-b -c不需参数。  \n* .&#x2F;test.sh --a-long&#x3D;args --b-long ：长选项  </code></pre></div></figure>\n<p>先来看getopts,它不支持长选项。<br>\n使用getopts非常简单：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#test.sh  \n#!&#x2F;bin&#x2F;bash  \nwhile getopts &quot;a:bc&quot; arg #选项后面的冒号表示该选项需要参数  \ndo  \n        case $arg in  \n             a)  \n                echo &quot;a&#39;s arg:$optarg&quot; #参数存在$optarg中\n\n             b)  \n                echo &quot;b&quot;\n\n             c)  \n                echo &quot;c&quot;\n\n             ?)  #当有不认识的选项的时候arg为?  \n            echo &quot;unkonw argument&quot;  \n        exit 1\n\n        esac  \ndone</code></pre></div></figure>\n<p>现在就可以使用：<br>\n<code>./test.sh -a arg -b -c  </code>或<br>\n<code>./test.sh -a arg -bc  </code>来加载了。<br>\n应该说绝大多数脚本使用该函数就可以了，如果需要支持长选项以及可选参数，那么就需要使用getopt.<br>\ngetopt自带的一个例子：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">\n#!&#x2F;bin&#x2F;bash\n# a small example program for using the new getopt(1) program.\n# this program will only work with bash(1)\n# an similar program using the tcsh(1) script language can be found\n# as parse.tcsh\n# example input and output (from the bash prompt):\n# .&#x2F;parse.bash -a par1 &#39;another arg&#39; --c-long &#39;wow!*\\?&#39; -cmore -b &quot; very long &quot;\n# option a\n# option c, no argument\n# option c, argument &#96;more&#39;\n# option b, argument &#96; very long &#39;\n# remaining arguments:\n# --&gt; &#96;par1&#39;\n# --&gt; &#96;another arg&#39;\n# --&gt; &#96;wow!*\\?&#39;\n# note that we use &#96;&quot;$@&quot;&#39; to let each command-line parameter expand to a\n# separate word. the quotes around &#96;$@&#39; are essential!\n# we need temp as the &#96;eval set --&#39; would nuke the return value of getopt.\n#-o表示短选项，两个冒号表示该选项有一个可选参数，可选参数必须紧贴选项\n#如-carg 而不能是-c arg\n#--long表示长选项\n#&quot;$@&quot;在上面解释过\n# -n:出错时的信息\n# -- ：举一个例子比较好理解：\n#我们要创建一个名字为 &quot;-f&quot;的目录你会怎么办？\n# mkdir -f #不成功，因为-f会被mkdir当作选项来解析，这时就可以使用\n# mkdir -- -f 这样-f就不会被作为选项。\ntemp&#x3D;&#96;getopt -o ab:c:: --long a-long,b-long:,c-long:: \\\n     -n &#39;example.bash&#39; -- &quot;$@&quot;&#96;\nif [ $? !&#x3D; 0 ] ; then echo &quot;terminating...&quot; &gt;&amp;2 ; exit 1 ; fi\n# note the quotes around &#96;$temp&#39;: they are essential!\n#set 会重新排列参数的顺序，也就是改变$1,$2...$n的值，这些值在getopt中重新排列过了\neval set -- &quot;$temp&quot;\n#经过getopt的处理，下面处理具体选项。\nwhile true ; do\n        case &quot;$1&quot; in\n                -a|--a-long) echo &quot;option a&quot; ; shift ;;\n                -b|--b-long) echo &quot;option b, argument \\&#96;$2&#39;&quot; ; shift 2 ;;\n                -c|--c-long)\n                        # c has an optional argument. as we are in quoted mode,\n                        # an empty parameter will be generated if its optional\n                        # argument is not found.\n                        case &quot;$2&quot; in\n                                &quot;&quot;) echo &quot;option c, no argument&quot;; shift 2 ;;\n                                *)  echo &quot;option c, argument \\&#96;$2&#39;&quot; ; shift 2 ;;\n                        esac ;;\n                --) shift ; break ;;\n                *) echo &quot;internal error!&quot; ; exit 1 ;;\n        esac\ndone\necho &quot;remaining arguments:&quot;\nfor arg do\n   echo &#39;--&gt; &#39;&quot;\\&#96;$arg&#39;&quot; ;\ndone\n</code></pre></div></figure>\n<p>比如使用<br>\n<code>./test -a  -b arg arg1 -c  </code>你可以看到,命令行中多了个arg1参数，在经过getopt和set之后，命令行会变为：<br>\n<code>-a -b arg -c -- arg1  </code><code>$1</code>指向-a, <code>$2</code>指向-b,<code>$3</code>指向arg,<code>$4</code>指向-c,<code>$5</code>指向–,而多出的arg1则被放到了最后。</p>\n<h3 id=\"总结\">总结</h3>\n<p>一般小脚本手工处理也就够了，getopts能处理绝大多数的情况，getopt较复杂，功能也更强大。</p>\n<h2 id=\"100个实用的经典-Linux-Shell-脚本\">100个实用的经典 Linux Shell 脚本</h2>\n<ol>\n<li>编写 hello world 脚本</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#!&#x2F;bin&#x2F;bash  \n  \n# 编写 hello world 脚本  \n  \necho &quot;Hello World!&quot;  </code></pre></div></figure>\n<ol start=\"2\">\n<li>通过位置变量创建 Linux 系统账户及密码</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#!&#x2F;bin&#x2F;bash  \n  \n# 通过位置变量创建 Linux 系统账户及密码  \n  \n#$1 是执行脚本的第一个参数,$2 是执行脚本的第二个参数  \nuseradd    &quot;$1&quot;   \necho &quot;$2&quot;  |  passwd  ‐‐stdin  &quot;$1&quot;  </code></pre></div></figure>\n<ol start=\"3\">\n<li>备份日志</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#!&#x2F;bin&#x2F;bash  \n# 每周 5 使用 tar 命令备份&#x2F;var&#x2F;log 下的所有日志文件  \n# vim  &#x2F;root&#x2F;logbak.sh  \n# 编写备份脚本,备份后的文件名包含日期标签,防止后面的备份将前面的备份数据覆盖  \n# 注意 date 命令需要使用反引号括起来,反引号在键盘&lt;tab&gt;键上面  \ntar  -czf  log-&#96;date +%Y%m%d&#96;.tar.gz  &#x2F;var&#x2F;log   \n  \n# crontab ‐e  #编写计划任务,执行备份脚本  \n00  03  *  *  5  &#x2F;root&#x2F;logbak.sh  </code></pre></div></figure>\n<ol start=\"4\">\n<li>一键部署 LNMP(RPM 包版本)</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#!&#x2F;bin&#x2F;bash  \n# 一键部署 LNMP(RPM 包版本)  \n# 使用 yum 安装部署 LNMP,需要提前配置好 yum 源,否则该脚本会失败  \n# 本脚本使用于 centos7.2 或 RHEL7.2  \nyum ‐y install httpd  \nyum ‐y install mariadb mariadb‐devel mariadb‐server  \nyum ‐y install php  php‐mysql  \n  \nsystemctl start httpd mariadb  \nsystemctl enable httpd mariadb  </code></pre></div></figure>\n<ol start=\"5\">\n<li>监控内存和磁盘容量，小于给定值时报警</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#!&#x2F;bin&#x2F;bash  \n  \n# 实时监控本机内存和硬盘剩余空间,剩余内存小于500M、根分区剩余空间小于1000M时,发送报警邮件给root管理员  \n  \n# 提取根分区剩余空间  \ndisk_size&#x3D;$(df &#x2F; | awk &#39;&#x2F;\\&#x2F;&#x2F;&#123;print $4&#125;&#39;)  \n  \n# 提取内存剩余空间  \nmem_size&#x3D;$(free | awk &#39;&#x2F;Mem&#x2F;&#123;print $4&#125;&#39;)  \nwhile :  \ndo  \n# 注意内存和磁盘提取的空间大小都是以 Kb 为单位  \nif  [  $disk_size -le 512000 -a $mem_size -le 1024000  ]  \nthen  \n    mail  ‐s  &quot;Warning&quot;  root  &lt;&lt;EOF  \n  Insufficient resources,资源不足  \nEOF  \nfi  \ndone  </code></pre></div></figure>\n<ol start=\"6\">\n<li>猜数字游戏</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#!&#x2F;bin&#x2F;bash  \n  \n# 脚本生成一个 100 以内的随机数,提示用户猜数字,根据用户的输入,提示用户猜对了,  \n# 猜小了或猜大了,直至用户猜对脚本结束。  \n  \n# RANDOM 为系统自带的系统变量,值为 0‐32767的随机数  \n# 使用取余算法将随机数变为 1‐100 的随机数  \nnum&#x3D;$[RANDOM%100+1]  \necho &quot;$num&quot;  \n  \n# 使用 read 提示用户猜数字  \n# 使用 if 判断用户猜数字的大小关系:‐eq(等于),‐ne(不等于),‐gt(大于),‐ge(大于等于),  \n# ‐lt(小于),‐le(小于等于)  \nwhile  :  \ndo  \n  read -p &quot;计算机生成了一个 1‐100 的随机数,你猜: &quot; cai  \n    if [ $cai -eq $num ]  \n    then  \n         echo &quot;恭喜,猜对了&quot;  \n         exit  \n      elif [ $cai -gt $num ]  \n      then  \n             echo &quot;Oops,猜大了&quot;  \n        else  \n             echo &quot;Oops,猜小了&quot;  \n   fi  \ndone  </code></pre></div></figure>\n<ol start=\"7\">\n<li>检测本机当前用户是否为超级管理员，如果是管理员，则使用 yum 安装 vsftpd，如果不是，则提示您非管理员(使用字串对比版本)</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#!&#x2F;bin&#x2F;bash  \n  \n# 检测本机当前用户是否为超级管理员,如果是管理员,则使用 yum 安装 vsftpd,如果不  \n# 是,则提示您非管理员(使用字串对比版本)   \nif [ $USER &#x3D;&#x3D; &quot;root&quot; ]  \nthen  \n  yum ‐y install vsftpd  \nelse  \n    echo &quot;您不是管理员,没有权限安装软件&quot;  \nfi  </code></pre></div></figure>\n<ol start=\"8\">\n<li>检测本机当前用户是否为超级管理员，如果是管理员，则使用 yum 安装 vsftpd，如果不是，则提示您非管理员(使用 UID 数字对比版本)</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#!&#x2F;bin&#x2F;bash  \n  \n# 检测本机当前用户是否为超级管理员,如果是管理员,则使用 yum 安装 vsftpd,如果不  \n# 是,则提示您非管理员(使用 UID 数字对比版本)  \nif [ $UID -eq 0 ];then  \n    yum ‐y install vsftpd  \nelse  \n    echo &quot;您不是管理员,没有权限安装软件&quot;  \nfi  </code></pre></div></figure>\n<ol start=\"9\">\n<li>编写脚本：提示用户输入用户名和密码，脚本自动创建相应的账户及配置密码。如果用户不输入账户名，则提示必须输入账户名并退出脚本；如果用户不输入密码，则统一使用默认的 123456 作为默认密码。</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#!&#x2F;bin&#x2F;bash  \n  \n# 编写脚本:提示用户输入用户名和密码,脚本自动创建相应的账户及配置密码。如果用户  \n# 不输入账户名,则提示必须输入账户名并退出脚本;如果用户不输入密码,则统一使用默  \n# 认的 123456 作为默认密码。  \nread -p &quot;请输入用户名: &quot; user  \n#使用‐z 可以判断一个变量是否为空,如果为空,提示用户必须输入账户名,并退出脚本,退出码为 2  \n#没有输入用户名脚本退出后,使用$?查看的返回码为 2  \nif [ -z $user ];then  \n     echo &quot;您不需输入账户名&quot;  \n   exit 2  \nfi  \n#使用 stty ‐echo 关闭 shell 的回显功能  \n#使用 stty  echo 打开 shell 的回显功能  \nstty -echo  \nread -p &quot;请输入密码: &quot; pass  \nstty echo  \npass&#x3D;$&#123;pass:‐123456&#125;  \nuseradd &quot;$user&quot;  \necho &quot;$pass&quot; | passwd ‐‐stdin &quot;$user&quot;  </code></pre></div></figure>\n<ol start=\"10\">\n<li>输入三个数并进行升序排序</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#!&#x2F;bin&#x2F;bash  \n  \n# 依次提示用户输入 3 个整数,脚本根据数字大小依次排序输出 3 个数字  \nread -p &quot;请输入一个整数:&quot; num1  \nread -p &quot;请输入一个整数:&quot; num2  \nread -p &quot;请输入一个整数:&quot; num3  \n# 不管谁大谁小,最后都打印 echo &quot;$num1,$num2,$num3&quot;  \n# num1 中永远存最小的值,num2 中永远存中间值,num3 永远存最大值  \n# 如果输入的不是这样的顺序,则改变数的存储顺序,如:可以将 num1 和 num2 的值对调  \ntmp&#x3D;0  \n# 如果 num1 大于 num2,就把 num1 和和 num2 的值对调,确保 num1 变量中存的是最小值  \nif [ $num1 -gt $num2 ];then     \n  tmp&#x3D;$num1  \n  num1&#x3D;$num2  \n  num2&#x3D;$tmp  \nfi  \n# 如果 num1 大于 num3,就把 num1 和 num3 对调,确保 num1 变量中存的是最小值  \nif [ $num1 -gt $num3 ];then     \n    tmp&#x3D;$num1  \n    num1&#x3D;$num3  \n    num3&#x3D;$tmp  \nfi  \n# 如果 num2 大于 num3,就把 num2 和 num3 对标,确保 num2 变量中存的是小一点的值  \nif [ $num2 -gt $num3 ];then  \n    tmp&#x3D;$num2  \n    num2&#x3D;$num3  \n    num3&#x3D;$tmp  \nfi  \necho &quot;排序后数据(从小到大)为:$num1,$num2,$num3&quot;  </code></pre></div></figure>\n<ol start=\"11\">\n<li>石头、剪刀、布游戏</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#!&#x2F;bin&#x2F;bash  \n  \n# 编写脚本,实现人机&lt;石头,剪刀,布&gt;游戏  \ngame&#x3D;(石头 剪刀 布)  \nnum&#x3D;$[RANDOM%3]  \ncomputer&#x3D;$&#123;game[$num]&#125;  \n# 通过随机数获取计算机的出拳  \n# 出拳的可能性保存在一个数组中,game[0],game[1],game[2]分别是 3 中不同的可能  \n  \necho &quot;请根据下列提示选择您的出拳手势&quot;  \necho &quot;1.石头&quot;  \necho &quot;2.剪刀&quot;  \necho &quot;3.布&quot;  \n  \nread -p &quot;请选择 1‐3:&quot; person  \ncase  $person  in  \n1)  \n  if [ $num -eq 0 ]  \n  then  \n    echo &quot;平局&quot;  \n    elif [ $num -eq 1 ]  \n    then  \n      echo &quot;你赢&quot;  \n  else  \n    echo &quot;计算机赢&quot;  \n  fi;;  \n2)     \n  if [ $num -eq 0 ]  \n  then  \n    echo &quot;计算机赢&quot;  \n    elif [ $num -eq 1 ]  \n    then  \n      echo &quot;平局&quot;  \n  else  \n    echo &quot;你赢&quot;  \n  fi;;  \n3)  \n  if [ $num -eq 0 ]  \n  then  \n    echo &quot;你赢&quot;  \n    elif [ $num -eq 1 ]  \n    then  \n      echo &quot;计算机赢&quot;  \n  else  \n    echo &quot;平局&quot;  \n  fi;;  \n*)  \n  echo &quot;必须输入 1‐3 的数字&quot;  \nesac  </code></pre></div></figure>\n<ol start=\"12\">\n<li>编写脚本测试 192.168.4.0/24 整个网段中哪些主机处于开机状态，哪些主机处于关机状态(for 版本)</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#!&#x2F;bin&#x2F;bash  \n  \n# 编写脚本测试 192.168.4.0&#x2F;24 整个网段中哪些主机处于开机状态,哪些主机处于关机  \n# 状态(for 版本)  \nfor i in &#123;1..254&#125;  \ndo  \n  # 每隔0.3秒ping一次，一共ping2次，并以1毫秒为单位设置ping的超时时间  \n     ping ‐c 2 ‐i 0.3 ‐W 1 192.168.4.$i  &amp;&gt;&#x2F;dev&#x2F;null  \n    if  [ $? -eq 0 ];then  \n         echo &quot;192.168.4.$i is up&quot;  \n     else  \n         echo  &quot;192.168.4.$i is down&quot;  \n     fi  \ndone  </code></pre></div></figure>\n<ol start=\"13\">\n<li>编写脚本测试 192.168.4.0/24 整个网段中哪些主机处于开机状态，哪些主机处于关机状态(while 版本)</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#!&#x2F;bin&#x2F;bash  \n  \n# 编写脚本测试 192.168.4.0&#x2F;24 整个网段中哪些主机处于开机状态,哪些主机处于关机  \n# 状态(while 版本)   \ni&#x3D;1  \nwhile [ $i -le 254 ]  \ndo  \n     ping ‐c 2 ‐i 0.3 ‐W 1 192.168.4.$i  &amp;&gt;&#x2F;dev&#x2F;null  \n     if  [ $? -eq 0 ];then  \n         echo &quot;192.168.4.$i is up&quot;  \n    else  \n         echo  &quot;192.168.4.$i is down&quot;  \n     fi  \n     let i++  \ndone  </code></pre></div></figure>\n<ol start=\"14\">\n<li>编写脚本测试 192.168.4.0/24 整个网段中哪些主机处于开机状态，哪些主机处于关机状态(多进程版)</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#!&#x2F;bin&#x2F;bash  \n  \n# 编写脚本测试 192.168.4.0&#x2F;24 整个网段中哪些主机处于开机状态,哪些主机处于关机  \n# 状态(多进程版)  \n#定义一个函数,ping 某一台主机,并检测主机的存活状态  \nmyping()&#123;  \nping ‐c 2 ‐i 0.3 ‐W 1 $1  &amp;&gt;&#x2F;dev&#x2F;null  \nif  [ $? -eq 0 ];then  \n  echo &quot;$1 is up&quot;  \nelse  \n  echo &quot;$1 is down&quot;  \nfi  \n&#125;  \nfor i in &#123;1..254&#125;  \ndo  \n     myping 192.168.4.$i &amp;  \ndone  \n# 使用&amp;符号,将执行的函数放入后台执行  \n# 这样做的好处是不需要等待ping第一台主机的回应,就可以继续并发ping第二台主机,依次类推。  </code></pre></div></figure>\n<ol start=\"15\">\n<li>编写脚本,显示进度条</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#!&#x2F;bin&#x2F;bash  \n  \n# 编写脚本,显示进度条  \njindu()&#123;  \nwhile :  \ndo  \n     echo -n &#39;#&#39;  \n     sleep 0.2  \ndone  \n&#125;  \njindu &amp;  \ncp -a $1 $2  \nkillall $0  \necho &quot;拷贝完成&quot;  </code></pre></div></figure>\n<ol start=\"16\">\n<li>进度条,动态时针版本；定义一个显示进度的函数,屏幕快速显示| / ‐ \\</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#!&#x2F;bin&#x2F;bash  \n  \n# 进度条,动态时针版本  \n# 定义一个显示进度的函数,屏幕快速显示|  &#x2F; ‐ \\  \nrotate_line()&#123;  \nINTERVAL&#x3D;0.5  #设置间隔时间  \nCOUNT&#x3D;&quot;0&quot;     #设置4个形状的编号,默认编号为 0(不代表任何图像)  \nwhile :  \ndo  \n  COUNT&#x3D;&#96;expr $COUNT + 1&#96; #执行循环,COUNT 每次循环加 1,(分别代表4种不同的形状)  \n  case $COUNT in          #判断 COUNT 的值,值不一样显示的形状就不一样  \n  &quot;1&quot;)                    #值为 1 显示‐  \n          echo -e &#39;‐&#39;&quot;\\b\\c&quot;  \n          sleep $INTERVAL  \n          ;;  \n    &quot;2&quot;)                  #值为 2 显示\\\\,第一个\\是转义  \n          echo -e &#39;\\\\&#39;&quot;\\b\\c&quot;  \n          sleep $INTERVAL  \n          ;;  \n    &quot;3&quot;)                  #值为 3 显示|  \n          echo -e &quot;|\\b\\c&quot;  \n          sleep $INTERVAL  \n          ;;  \n   &quot;4&quot;)                   #值为 4 显示&#x2F;  \n          echo -e &quot;&#x2F;\\b\\c&quot;  \n          sleep $INTERVAL  \n          ;;  \n    *)                    #值为其他时,将 COUNT 重置为 0  \n          COUNT&#x3D;&quot;0&quot;;;  \n    esac  \ndone  \n&#125;  \nrotate_line  </code></pre></div></figure>\n<ol start=\"17\">\n<li>9*9 乘法表</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#!&#x2F;bin&#x2F;bash  \n  \n# 9*9 乘法表(编写 shell 脚本,打印 9*9 乘法表)   \nfor i in &#96;seq 9&#96;  \ndo  \n    for j in &#96;seq $i&#96;  \n     do  \n         echo -n &quot;$j*$i&#x3D;$[i*j]  &quot;  \n     done  \n    echo  \ndone  </code></pre></div></figure>\n<ol start=\"18\">\n<li>使用死循环实时显示 eth0 网卡发送的数据包流量</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#!&#x2F;bin&#x2F;bash  \n  \n# 使用死循环实时显示 eth0 网卡发送的数据包流量   \nwhile :  \ndo  \n   echo  &#39;本地网卡 eth0 流量信息如下: &#39;  \n    ifconfig eth0 | grep &quot;RX pack&quot; | awk &#39;&#123;print $5&#125;&#39;  \n    ifconfig eth0 | grep &quot;TX pack&quot; | awk &#39;&#123;print $5&#125;&#39;  \n     sleep 1  \ndone  </code></pre></div></figure>\n<ol start=\"19\">\n<li>使用 user.txt 文件中的人员名单,在计算机中自动创建对应的账户并配置初始密码本脚本执行,需要提前准备一个 user.txt 文件,该文件中包含有若干用户名信息</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#!&#x2F;bin&#x2F;bash  \n  \n# 使用 user.txt 文件中的人员名单,在计算机中自动创建对应的账户并配置初始密码  \n# 本脚本执行,需要提前准备一个 user.txt 文件,该文件中包含有若干用户名信息  \nfor i in &#96;cat user.txt&#96;  \ndo  \n     useradd  $i  \n     echo &quot;123456&quot; | passwd ‐‐stdin $i  \ndone  </code></pre></div></figure>\n<ol start=\"20\">\n<li>编写批量修改扩展名脚本</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#!&#x2F;bin&#x2F;bash  \n  \n# 编写批量修改扩展名脚本,如批量将 txt 文件修改为 doc 文件   \n# 执行脚本时,需要给脚本添加位置参数  \n# 脚本名  txt  doc(可以将 txt 的扩展名修改为 doc)  \n# 脚本名  doc  jpg(可以将 doc 的扩展名修改为 jpg)  \nfor i in &#96;ls *.$1&#96;  \ndo  \n     mv $i $&#123;i%.*&#125;.$2  \ndone  </code></pre></div></figure>\n<ol start=\"21\">\n<li>使用 expect 工具自动交互密码远程其他主机安装 httpd 软件</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#!&#x2F;bin&#x2F;bash  \n  \n# 使用 expect 工具自动交互密码远程其他主机安装 httpd 软件   \n  \n# 删除~&#x2F;.ssh&#x2F;known_hosts 后,ssh 远程任何主机都会询问是否确认要连接该主机  \nrm  ‐rf  ~&#x2F;.ssh&#x2F;known_hosts  \nexpect &lt;&lt;EOF  \nspawn ssh 192.168.4.254  \nexpect &quot;yes&#x2F;no&quot; &#123;send &quot;yes\\r&quot;&#125;  \n# 根据自己的实际情况将密码修改为真实的密码字串  \nexpect &quot;password&quot; &#123;send  &quot;密码\\r&quot;&#125;  \nexpect &quot;#&quot; &#123;send  &quot;yum ‐y install httpd\\r&quot;&#125;  \nexpect &quot;#&quot; &#123;send  &quot;exit\\r&quot;&#125;  \nEOF  </code></pre></div></figure>\n<ol start=\"22\">\n<li>一键部署 LNMP(源码安装版本)</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#!&#x2F;bin&#x2F;bash  \n  \n# 一键部署 LNMP(源码安装版本)  \nmenu()  \n&#123;  \nclear  \necho &quot;  ##############‐‐‐‐Menu‐‐‐‐##############&quot;  \necho &quot;# 1. Install Nginx&quot;  \necho &quot;# 2. Install MySQL&quot;  \necho &quot;# 3. Install PHP&quot;  \necho &quot;# 4. Exit Program&quot;  \necho &quot;  ########################################&quot;  \n&#125;  \n  \nchoice()  \n&#123;  \n  read -p &quot;Please choice a menu[1‐9]:&quot; select  \n&#125;  \n  \ninstall_nginx()  \n&#123;  \n  id nginx &amp;&gt;&#x2F;dev&#x2F;null  \n  if [ $? -ne 0 ];then  \n    useradd -s &#x2F;sbin&#x2F;nologin nginx  \n  fi  \n  if [ -f nginx‐1.8.0.tar.gz ];then  \n    tar -xf nginx‐1.8.0.tar.gz  \n    cd nginx‐1.8.0  \n    yum -y install  gcc pcre‐devel openssl‐devel zlib‐devel make  \n    .&#x2F;configure ‐‐prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx ‐‐with‐http_ssl_module  \n    make  \n    make install  \n    ln -s &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx &#x2F;usr&#x2F;sbin&#x2F;  \n    cd ..  \n  else  \n    echo &quot;没有 Nginx 源码包&quot;  \n  fi  \n&#125;  \n  \ninstall_mysql()  \n&#123;  \n  yum -y install gcc gcc‐c++ cmake ncurses‐devel perl  \n  id mysql &amp;&gt;&#x2F;dev&#x2F;null  \n  if [ $? -ne 0 ];then  \n    useradd -s &#x2F;sbin&#x2F;nologin mysql  \n  fi  \n  if [ -f mysql‐5.6.25.tar.gz ];then  \n    tar -xf mysql‐5.6.25.tar.gz  \n    cd mysql‐5.6.25  \n    cmake .  \n    make  \n    make install  \n    &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;scripts&#x2F;mysql_install_db ‐‐user&#x3D;mysql ‐‐datadir&#x3D;&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;data&#x2F;  \n‐‐basedir&#x3D;&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;  \n    chown -R root.mysql &#x2F;usr&#x2F;local&#x2F;mysql  \n    chown -R mysql &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;data  \n    &#x2F;bin&#x2F;cp -f &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;support‐files&#x2F;mysql.server &#x2F;etc&#x2F;init.d&#x2F;mysqld  \n    chmod +x &#x2F;etc&#x2F;init.d&#x2F;mysqld  \n    &#x2F;bin&#x2F;cp -f &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;support‐files&#x2F;my‐default.cnf &#x2F;etc&#x2F;my.cnf  \n    echo &quot;&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;lib&#x2F;&quot; &gt;&gt; &#x2F;etc&#x2F;ld.so.conf  \n    ldconfig  \n    echo &#39;PATH&#x3D;\\$PATH:&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;bin&#x2F;&#39; &gt;&gt; &#x2F;etc&#x2F;profile  \n    export PATH  \n  else  \n    echo  &quot;没有 mysql 源码包&quot;  \n    exit  \n  fi  \n&#125;  \n  \ninstall_php()  \n&#123;  \n#安装 php 时没有指定启动哪些模块功能,如果的用户可以根据实际情况自行添加额外功能如‐‐with‐gd 等  \nyum  -y  install  gcc  libxml2‐devel  \nif [ -f mhash‐0.9.9.9.tar.gz ];then  \n  tar -xf mhash‐0.9.9.9.tar.gz  \n  cd mhash‐0.9.9.9  \n  .&#x2F;configure  \n  make  \n  make install  \n  cd ..  \nif [ ! ‐f &#x2F;usr&#x2F;lib&#x2F;libmhash.so ];then  \n  ln -s &#x2F;usr&#x2F;local&#x2F;lib&#x2F;libmhash.so &#x2F;usr&#x2F;lib&#x2F;  \nfi  \nldconfig  \nelse  \n  echo &quot;没有 mhash 源码包文件&quot;  \n  exit  \nfi  \nif [ -f libmcrypt‐2.5.8.tar.gz ];then  \n  tar -xf libmcrypt‐2.5.8.tar.gz  \n  cd libmcrypt‐2.5.8  \n  .&#x2F;configure  \n  make  \n  make install  \n  cd ..  \n  if [ ! -f &#x2F;usr&#x2F;lib&#x2F;libmcrypt.so ];then    \n    ln -s &#x2F;usr&#x2F;local&#x2F;lib&#x2F;libmcrypt.so &#x2F;usr&#x2F;lib&#x2F;  \n  fi  \n  ldconfig  \nelse  \n  echo &quot;没有 libmcrypt 源码包文件&quot;  \n  exit  \nfi  \nif [ -f php‐5.4.24.tar.gz ];then  \n  tar -xf php‐5.4.24.tar.gz  \n  cd php‐5.4.24  \n  .&#x2F;configure  ‐‐prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;php5  ‐‐with‐mysql&#x3D;&#x2F;usr&#x2F;local&#x2F;mysql  ‐‐enable‐fpm    ‐‐  \n  enable‐mbstring  ‐‐with‐mcrypt  ‐‐with‐mhash  ‐‐with‐config‐file‐path&#x3D;&#x2F;usr&#x2F;local&#x2F;php5&#x2F;etc  ‐‐with‐  \n  mysqli&#x3D;&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;bin&#x2F;mysql_config  \n  make &amp;&amp; make install  \n  &#x2F;bin&#x2F;cp -f php.ini‐production &#x2F;usr&#x2F;local&#x2F;php5&#x2F;etc&#x2F;php.ini  \n  &#x2F;bin&#x2F;cp -f &#x2F;usr&#x2F;local&#x2F;php5&#x2F;etc&#x2F;php‐fpm.conf.default &#x2F;usr&#x2F;local&#x2F;php5&#x2F;etc&#x2F;php‐fpm.conf  \n  cd ..  \nelse  \n  echo &quot;没有 php 源码包文件&quot;  \n  exit  \nfi   \n&#125;  \n  \nwhile :  \ndo  \n  menu  \n  choice  \n  case $select in  \n  1)  \n    install_nginx  \n    ;;  \n  2)  \n    install_mysql  \n    ;;  \n  3)  \n    install_php  \n    ;;  \n  4)  \n    exit  \n    ;;  \n  *)  \n    echo Sorry!  \n  esac  \ndone  </code></pre></div></figure>\n<ol start=\"23\">\n<li>编写脚本快速克隆 KVM 虚拟机</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#!&#x2F;bin&#x2F;bash  \n  \n# 编写脚本快速克隆 KVM 虚拟机  \n  \n# 本脚本针对 RHEL7.2 或 Centos7.2  \n# 本脚本需要提前准备一个 qcow2 格式的虚拟机模板,  \n# 名称为&#x2F;var&#x2F;lib&#x2F;libvirt&#x2F;images  &#x2F;.rh7_template 的虚拟机模板  \n# 该脚本使用 qemu‐img 命令快速创建快照虚拟机  \n# 脚本使用 sed 修改模板虚拟机的配置文件,将虚拟机名称、UUID、磁盘文件名、MAC 地址  \n# exit code:    \n#    65 ‐&gt; user input nothing  \n#    66 ‐&gt; user input is not a number  \n#    67 ‐&gt; user input out of range  \n#    68 ‐&gt; vm disk image exists  \n  \nIMG_DIR&#x3D;&#x2F;var&#x2F;lib&#x2F;libvirt&#x2F;images  \nBASEVM&#x3D;rh7_template  \nread -p &quot;Enter VM number: &quot; VMNUM  \nif [ $VMNUM -le 9 ];then  \nVMNUM&#x3D;0$VMNUM  \nfi  \n  \nif [ -z &quot;$&#123;VMNUM&#125;&quot; ]; then  \n    echo &quot;You must input a number.&quot;  \n    exit 65  \nelif [[  $&#123;VMNUM&#125; &#x3D;~ [a‐z]  ]; then  \n    echo &quot;You must input a number.&quot;  \n    exit 66  \nelif [ $&#123;VMNUM&#125; -lt 1 -o $&#123;VMNUM&#125; -gt 99 ]; then  \n    echo &quot;Input out of range&quot;  \n    exit 67  \nfi  \n  \nNEWVM&#x3D;rh7_node$&#123;VMNUM&#125;  \n  \nif [ -e $IMG_DIR&#x2F;$&#123;NEWVM&#125;.img ]; then  \n    echo &quot;File exists.&quot;  \n    exit 68  \nfi  \n  \necho -en &quot;Creating Virtual Machine disk image......\\t&quot;  \nqemu‐img create -f qcow2 ‐b $IMG_DIR&#x2F;.$&#123;BASEVM&#125;.img $IMG_DIR&#x2F;$&#123;NEWVM&#125;.img &amp;&gt; &#x2F;dev&#x2F;null  \n  \necho -e &quot;\\e[32;1m[OK]\\e[0m&quot;  \n#virsh dumpxml $&#123;BASEVM&#125; &gt; &#x2F;tmp&#x2F;myvm.xml  \n  \ncat &#x2F;var&#x2F;lib&#x2F;libvirt&#x2F;images&#x2F;.rhel7.xml &gt; &#x2F;tmp&#x2F;myvm.xml  \nsed -i &quot;&#x2F;&lt;name&gt;$&#123;BASEVM&#125;&#x2F;s&#x2F;$&#123;BASEVM&#125;&#x2F;$&#123;NEWVM&#125;&#x2F;&quot; &#x2F;tmp&#x2F;myvm.xml  \nsed -i &quot;&#x2F;uuid&#x2F;s&#x2F;&lt;uuid&gt;.*&lt;\\&#x2F;uuid&gt;&#x2F;&lt;uuid&gt;$(uuidgen)&lt;\\&#x2F;uuid&gt;&#x2F;&quot; &#x2F;tmp&#x2F;myvm.xml  \nsed -i &quot;&#x2F;$&#123;BASEVM&#125;\\.img&#x2F;s&#x2F;$&#123;BASEVM&#125;&#x2F;$&#123;NEWVM&#125;&#x2F;&quot; &#x2F;tmp&#x2F;myvm.xml  \n  \n# 修改 MAC 地址,本例使用的是常量,每位使用该脚本的用户需要根据实际情况修改这些值   \n# 最好这里可以使用便利,这样更适合于批量操作,可以克隆更多虚拟机   \nsed -i &quot;&#x2F;mac &#x2F;s&#x2F;a1&#x2F;0c&#x2F;&quot; &#x2F;tmp&#x2F;myvm.xml  \n  \necho -en &quot;Defining new virtual machine......\\t\\t&quot;  \nvirsh define &#x2F;tmp&#x2F;myvm.xml &amp;&gt; &#x2F;dev&#x2F;null  \necho -e &quot;\\e[32;1m[OK]\\e[0m&quot;  </code></pre></div></figure>\n<ol start=\"24\">\n<li>点名器脚本</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#!&#x2F;bin&#x2F;bash  \n  \n# 编写一个点名器脚本  \n  \n# 该脚本,需要提前准备一个 user.txt 文件  \n# 该文件中需要包含所有姓名的信息,一行一个姓名,脚本每次随机显示一个姓名  \nwhile :  \ndo  \n#统计 user 文件中有多少用户  \nline&#x3D;&#96;cat user.txt |wc ‐l&#96;  \nnum&#x3D;$[RANDOM%line+1]  \nsed -n &quot;$&#123;num&#125;p&quot;  user.txt  \nsleep 0.2  \nclear  \ndone  </code></pre></div></figure>\n<ol start=\"25\">\n<li>查看有多少远程的 IP 在连接本机</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#!&#x2F;bin&#x2F;bash  \n  \n# 查看有多少远程的 IP 在连接本机(不管是通过 ssh 还是 web 还是 ftp 都统计)   \n# 使用 netstat ‐atn 可以查看本机所有连接的状态,‐a 查看所有,  \n# -t仅显示 tcp 连接的信息,‐n 数字格式显示  \n# Local Address(第四列是本机的 IP 和端口信息)  \n# Foreign Address(第五列是远程主机的 IP 和端口信息)  \n# 使用 awk 命令仅显示第 5 列数据,再显示第 1 列 IP 地址的信息  \n# sort 可以按数字大小排序,最后使用 uniq 将多余重复的删除,并统计重复的次数  \nnetstat -atn  |  awk  &#39;&#123;print $5&#125;&#39;  | awk  &#39;&#123;print $1&#125;&#39; | sort -nr  |  uniq -c  </code></pre></div></figure>\n<ol start=\"26\">\n<li>对 100 以内的所有正整数相加求和(1+2+3+4…+100)</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#!&#x2F;bin&#x2F;bash  \n  \n# 对 100 以内的所有正整数相加求和(1+2+3+4...+100)  \n#seq 100 可以快速自动生成 100 个整数  \nsum&#x3D;0  \nfor i in &#96;seq 100&#96;  \ndo  \n    sum&#x3D;$[sum+i]  \ndone  \necho &quot;总和是:$sum&quot;  </code></pre></div></figure>\n<ol start=\"27\">\n<li>统计 13:30 到 14:30 所有访问 apache 服务器的请求有多少个</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#!&#x2F;bin&#x2F;bash  \n  \n# 统计 13:30 到 14:30 所有访问 apache 服务器的请求有多少个  \n  \n# awk 使用‐F 选项指定文件内容的分隔符是&#x2F;或者:  \n# 条件判断$7:$8 大于等于 13:30,并且要求,$7:$8 小于等于 14:30  \n# 最后使用 wc ‐l 统计这样的数据有多少行,即多少个  \nawk -F &quot;[ &#x2F;:]&quot; &#39;$7&quot;:&quot;$8&gt;&#x3D;&quot;13:30&quot; &amp;&amp; $7&quot;:&quot;$8&lt;&#x3D;&quot;14:30&quot;&#39; &#x2F;var&#x2F;log&#x2F;httpd&#x2F;access_log |wc -l  </code></pre></div></figure>\n<ol start=\"28\">\n<li>统计 13:30 到 14:30 所有访问本机 Aapche 服务器的远程 IP 地址是什么</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#!&#x2F;bin&#x2F;bash  \n  \n# 统计 13:30 到 14:30 所有访问本机 Aapche 服务器的远程 IP 地址是什么   \n# awk 使用‐F 选项指定文件内容的分隔符是&#x2F;或者:  \n# 条件判断$7:$8 大于等于 13:30,并且要求,$7:$8 小于等于 14:30  \n# 日志文档内容里面,第 1 列是远程主机的 IP 地址,使用 awk 单独显示第 1 列即可  \nawk -F &quot;[ &#x2F;:]&quot; &#39;$7&quot;:&quot;$8&gt;&#x3D;&quot;13:30&quot; &amp;&amp; $7&quot;:&quot;$8&lt;&#x3D;&quot;14:30&quot;&#123;print $1&#125;&#39; &#x2F;var&#x2F;log&#x2F;httpd&#x2F;access_log  </code></pre></div></figure>\n<ol start=\"29\">\n<li>打印国际象棋棋盘</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#!&#x2F;bin&#x2F;bash  \n  \n# 打印国际象棋棋盘  \n# 设置两个变量,i 和 j,一个代表行,一个代表列,国际象棋为 8*8 棋盘  \n# i&#x3D;1 是代表准备打印第一行棋盘,第 1 行棋盘有灰色和蓝色间隔输出,总共为 8 列  \n# i&#x3D;1,j&#x3D;1 代表第 1 行的第 1 列;i&#x3D;2,j&#x3D;3 代表第 2 行的第 3 列  \n# 棋盘的规律是 i+j 如果是偶数,就打印蓝色色块,如果是奇数就打印灰色色块  \n# 使用 echo ‐ne 打印色块,并且打印完成色块后不自动换行,在同一行继续输出其他色块  \nfor i in &#123;1..8&#125;  \ndo  \n    for j in &#123;1..8&#125;  \n    do  \n      sum&#x3D;$[i+j]  \n    if [  $[sum%2] -eq 0 ];then  \n       echo -ne &quot;\\033[46m  \\033[0m&quot;  \n    else  \n      echo -ne &quot;\\033[47m  \\033[0m&quot;  \n    fi  \n    done  \n    echo  \ndone  </code></pre></div></figure>\n<ol start=\"30\">\n<li>统计每个远程 IP 访问了本机 apache 几次?</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#!&#x2F;bin&#x2F;bash  \n  \n# 统计每个远程 IP 访问了本机 apache 几次?   \nawk  &#39;&#123;ip[$1]++&#125;END&#123;for(i in ip)&#123;print ip[i],i&#125;&#125;&#39;  &#x2F;var&#x2F;log&#x2F;httpd&#x2F;access_log  </code></pre></div></figure>\n<ol start=\"31\">\n<li>统计当前 Linux 系统中可以登录计算机的账户有多少个</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#!&#x2F;bin&#x2F;bash  \n  \n# 统计当前 Linux 系统中可以登录计算机的账户有多少个  \n#方法 1:  \ngrep &quot;bash$&quot; &#x2F;etc&#x2F;passwd | wc -l  \n#方法 2:  \nawk -f: &#39;&#x2F;bash$&#x2F;&#123;x++&#125;end&#123;print x&#125;&#39;  &#x2F;etc&#x2F;passwd  </code></pre></div></figure>\n<ol start=\"32\">\n<li>统计/var/log 有多少个文件,并显示这些文件名</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#!&#x2F;bin&#x2F;bash  \n  \n# 统计&#x2F;var&#x2F;log 有多少个文件,并显示这些文件名   \n# 使用 ls 递归显示所有,再判断是否为文件,如果是文件则计数器加 1  \ncd  &#x2F;var&#x2F;log  \nsum&#x3D;0  \nfor i in &#96;ls -r *&#96;  \ndo  \n   if [ -f $i ];then  \n       let sum++  \n         echo &quot;文件名:$i&quot;  \n     fi  \ndone  \necho &quot;总文件数量为:$sum&quot;  </code></pre></div></figure>\n<ol start=\"33\">\n<li>自动为其他脚本添加解释器信息</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">Docker+K8s+Jenkins 主流技术全解视频资料【干货免费分享】  \n  \n#!&#x2F;bin&#x2F;bash  \n  \n# 自动为其他脚本添加解释器信息#!&#x2F;bin&#x2F;bash,如脚本名为 test.sh 则效果如下:   \n# .&#x2F;test.sh  abc.sh  自动为 abc.sh 添加解释器信息  \n# .&#x2F;test.sh  user.sh  自动为 user.sh 添加解释器信息  \n# 先使用 grep 判断对象脚本是否已经有解释器信息,如果没有则使用 sed 添加解释器以及描述信息  \nif  !  grep  -q  &quot;^#!&quot;  $1; then  \nsed  &#39;1i #!&#x2F;bin&#x2F;bash&#39;  $1  \nsed  &#39;2i #Description: &#39;  \nfi  \n# 因为每个脚本的功能不同,作用不同,所以在给对象脚本添加完解释器信息,以及 Description 后还希望  \n# 继续编辑具体的脚本功能的描述信息,这里直接使用 vim 把对象脚本打开,并且光标跳转到该文件的第 2 行  \nvim +2 $1  </code></pre></div></figure>\n<ol start=\"34\">\n<li>自动化部署 varnish 源码包软件</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#!&#x2F;bin&#x2F;bash  \n  \n# 自动化部署 varnish 源码包软件   \n# 本脚本需要提前下载 varnish‐3.0.6.tar.gz 这样一个源码包软件,该脚本即可用自动源码安装部署软件  \n  \nyum -y install gcc readline‐devel pcre‐devel  \nuseradd -s &#x2F;sbin&#x2F;nologin varnish  \ntar -xf varnish‐3.0.6.tar.gz  \ncd varnish‐3.0.6  \n  \n# 使用 configure,make,make install 源码安装软件包  \n.&#x2F;configure ‐‐prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;varnish  \nmake &amp;&amp; make install  \n  \n# 在源码包目录下,将相应的配置文件拷贝到 Linux 系统文件系统中  \n# 默认安装完成后,不会自动拷贝或安装配置文件到 Linux 系统,所以需要手动 cp 复制配置文件  \n# 并使用 uuidgen 生成一个随机密钥的配置文件  \ncp redhat&#x2F;varnish.initrc &#x2F;etc&#x2F;init.d&#x2F;varnish  \ncp redhat&#x2F;varnish.sysconfig &#x2F;etc&#x2F;sysconfig&#x2F;varnish  \ncp redhat&#x2F;varnish_reload_vcl &#x2F;usr&#x2F;bin&#x2F;  \nln -s &#x2F;usr&#x2F;local&#x2F;varnish&#x2F;sbin&#x2F;varnishd &#x2F;usr&#x2F;sbin&#x2F;  \nln -s &#x2F;usr&#x2F;local&#x2F;varnish&#x2F;bin&#x2F;* &#x2F;usr&#x2F;bin  \nmkdir &#x2F;etc&#x2F;varnish  \ncp &#x2F;usr&#x2F;local&#x2F;varnish&#x2F;etc&#x2F;varnish&#x2F;default.vcl &#x2F;etc&#x2F;varnish&#x2F;  \nuuidgen &gt; &#x2F;etc&#x2F;varnish&#x2F;secret  </code></pre></div></figure>\n<ol start=\"35\">\n<li>编写 nginx 启动脚本</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#!&#x2F;bin&#x2F;bash  \n  \n# 编写 nginx 启动脚本   \n# 本脚本编写完成后,放置在&#x2F;etc&#x2F;init.d&#x2F;目录下,就可以被 Linux 系统自动识别到该脚本  \n# 如果本脚本名为&#x2F;etc&#x2F;init.d&#x2F;nginx,则 service nginx start 就可以启动该服务  \n# service nginx stop 就可以关闭服务  \n# service nginx restart 可以重启服务  \n# service nginx status 可以查看服务状态  \nprogram&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx  \npid&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;logs&#x2F;nginx.pid  \nstart()&#123;  \nif [ -f $pid ];then  \n  echo  &quot;nginx 服务已经处于开启状态&quot;  \nelse  \n  $program  \nfi  \nstop()&#123;  \nif [ -! -f $pid ];then  \n  echo &quot;nginx 服务已经关闭&quot;  \nelse  \n  $program -s stop  \n  echo &quot;关闭服务 ok&quot;  \nfi  \n&#125;  \nstatus()&#123;  \nif [ -f $pid ];then  \n  echo &quot;服务正在运行...&quot;  \nelse  \n  echo &quot;服务已经关闭&quot;  \nfi  \n&#125;  \n  \ncase $1 in  \nstart)  \n  start;;  \nstop)  \n  stop;;  \nrestart)  \n  stop  \n  sleep 1  \n  start;;  \nstatus)  \n  status;;  \n*)  \n  echo  &quot;你输入的语法格式错误&quot;  \nesac  </code></pre></div></figure>\n<ol start=\"36\">\n<li>自动对磁盘分区、格式化、挂载</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\"> #!&#x2F;bin&#x2F;bash  \n  \n# 自动对磁盘分区、格式化、挂载  \n# 对虚拟机的 vdb 磁盘进行分区格式化,使用&lt;&lt;将需要的分区指令导入给程序 fdisk  \n# n(新建分区),p(创建主分区),1(分区编号为 1),两个空白行(两个回车,相当于将整个磁盘分一个区)  \n# 注意:1 后面的两个回车(空白行)是必须的!  \nfdisk &#x2F;dev&#x2F;vdb &lt;&lt; EOF  \nn  \np  \n1  \n  \n  \nwq  \nEOF  \n#格式化刚刚创建好的分区  \nmkfs.xfs   &#x2F;dev&#x2F;vdb1  \n#创建挂载点目录  \nif [ -e &#x2F;data ]; then  \nexit  \nfi  \nmkdir &#x2F;data  \n#自动挂载刚刚创建的分区,并设置开机自动挂载该分区  \necho &#39;&#x2F;dev&#x2F;vdb1     &#x2F;data    xfs    defaults        1 2&#39;  &gt;&gt; &#x2F;etc&#x2F;fstab  \nmount -a  </code></pre></div></figure>\n<ol start=\"37\">\n<li>自动优化 Linux 内核参数</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#!&#x2F;bin&#x2F;bash  \n  \n# 自动优化 Linux 内核参数  \n#脚本针对 RHEL7  \ncat &gt;&gt; &#x2F;usr&#x2F;lib&#x2F;sysctl.d&#x2F;00‐system.conf &lt;&lt;EOF  \nfs.file‐max&#x3D;65535  \nnet.ipv4.tcp_timestamps &#x3D; 0  \nnet.ipv4.tcp_synack_retries &#x3D; 5  \nnet.ipv4.tcp_syn_retries &#x3D; 5  \nnet.ipv4.tcp_tw_recycle &#x3D; 1  \nnet.ipv4.tcp_tw_reuse &#x3D; 1  \nnet.ipv4.tcp_fin_timeout &#x3D; 30  \n#net.ipv4.tcp_keepalive_time &#x3D; 120  \nnet.ipv4.ip_local_port_range &#x3D; 1024  65535  \nkernel.shmall &#x3D; 2097152  \nkernel.shmmax &#x3D; 2147483648  \nkernel.shmmni &#x3D; 4096  \nkernel.sem &#x3D; 5010 641280 5010 128  \nnet.core.wmem_default&#x3D;262144  \nnet.core.wmem_max&#x3D;262144  \nnet.core.rmem_default&#x3D;4194304  \nnet.core.rmem_max&#x3D;4194304  \nnet.ipv4.tcp_fin_timeout &#x3D; 10  \nnet.ipv4.tcp_keepalive_time &#x3D; 30  \nnet.ipv4.tcp_window_scaling &#x3D; 0  \nnet.ipv4.tcp_sack &#x3D; 0  \nEOF  \n  \nsysctl –p  </code></pre></div></figure>\n<ol start=\"38\">\n<li>切割 Nginx 日志文件(防止单个文件过大,后期处理很困难)</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#mkdir  &#x2F;data&#x2F;scripts  \n#vim   &#x2F;data&#x2F;scripts&#x2F;nginx_log.sh    \n#!&#x2F;bin&#x2F;bash  \n  \n# 切割 Nginx 日志文件(防止单个文件过大,后期处理很困难)   \nlogs_path&#x3D;&quot;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;logs&#x2F;&quot;  \nmv $&#123;logs_path&#125;access.log $&#123;logs_path&#125;access_$(date -d &quot;yesterday&quot; +&quot;%Y%m%d&quot;).log  \nkill -USR1  &#96;cat &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;logs&#x2F;nginx.pid&#96;  \n  \n# chmod +x  &#x2F;data&#x2F;scripts&#x2F;nginx_log.sh  \n# crontab  ‐e                    #脚本写完后,将脚本放入计划任务每天执行一次脚本  \n0  1  *  *   *   &#x2F;data&#x2F;scripts&#x2F;nginx_log.sh </code></pre></div></figure>\n<ol start=\"39\">\n<li>检测 MySQL 数据库连接数量</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#!&#x2F;bin&#x2F;bash  \n  \n# 检测 MySQL 数据库连接数量   \n  \n# 本脚本每 2 秒检测一次 MySQL 并发连接数,可以将本脚本设置为开机启动脚本,或在特定时间段执行  \n# 以满足对 MySQL 数据库的监控需求,查看 MySQL 连接是否正常  \n# 本案例中的用户名和密码需要根据实际情况修改后方可使用  \nlog_file&#x3D;&#x2F;var&#x2F;log&#x2F;mysql_count.log  \nuser&#x3D;root  \npasswd&#x3D;123456  \nwhile :  \ndo  \n    sleep 2  \n    count&#x3D;&#96;mysqladmin  -u  &quot;$user&quot;  -p  &quot;$passwd&quot;   status |  awk &#39;&#123;print $4&#125;&#39;&#96;  \n    echo &quot;&#96;date +%Y‐%m‐%d&#96; 并发连接数为:$count&quot; &gt;&gt; $log_file  \ndone  </code></pre></div></figure>\n<ol start=\"40\">\n<li>根据 md5 校验码,检测文件是否被修改</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#!&#x2F;bin&#x2F;bash  \n  \n# 根据 md5 校验码,检测文件是否被修改   \n# 本示例脚本检测的是&#x2F;etc 目录下所有的 conf 结尾的文件,根据实际情况,您可以修改为其他目录或文件  \n# 本脚本在目标数据没有被修改时执行一次,当怀疑数据被人篡改,再执行一次  \n# 将两次执行的结果做对比,MD5 码发生改变的文件,就是被人篡改的文件  \nfor i in $(ls &#x2F;etc&#x2F;*.conf)  \ndo  \n  md5sum &quot;$i&quot; &gt;&gt; &#x2F;var&#x2F;log&#x2F;conf_file.log  \ndone  </code></pre></div></figure>\n<ol start=\"41\">\n<li>检测 MySQL 服务是否存活</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#!&#x2F;bin&#x2F;bash  \n  \n# 检测 MySQL 服务是否存活   \n  \n# host 为你需要检测的 MySQL 主机的 IP 地址,user 为 MySQL 账户名,passwd 为密码  \n# 这些信息需要根据实际情况修改后方可使用  \nhost&#x3D;192.168.51.198  \nuser&#x3D;root  \npasswd&#x3D;123456  \nmysqladmin -h &#39;$host&#39; -u &#39;$user&#39; -p&#39;$passwd&#39; ping &amp;&gt;&#x2F;dev&#x2F;null  \nif [ $? -eq 0 ]  \nthen  \n        echo &quot;MySQL is UP&quot;  \nelse  \n        echo &quot;MySQL is down&quot;  \nfi  </code></pre></div></figure>\n<ol start=\"42\">\n<li>备份 MySQL 的 shell 脚本(mysqldump版本)</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#!&#x2F;bin&#x2F;bash  \n  \n# 备份 MySQL 的 shell 脚本(mysqldump版本)   \n  \n# 定义变量 user(数据库用户名),passwd(数据库密码),date(备份的时间标签)  \n# dbname(需要备份的数据库名称,根据实际需求需要修改该变量的值,默认备份 mysql 数据库)  \n  \nuser&#x3D;root  \npasswd&#x3D;123456  \ndbname&#x3D;mysql  \ndate&#x3D;$(date +%Y%m%d)  \n  \n# 测试备份目录是否存在,不存在则自动创建该目录  \n[ ! -d &#x2F;mysqlbackup ] &amp;&amp; mkdir &#x2F;mysqlbackup  \n# 使用 mysqldump 命令备份数据库  \nmysqldump -u &quot;$user&quot; -p &quot;$passwd&quot; &quot;$dbname&quot; &gt; &#x2F;mysqlbackup&#x2F;&quot;$dbname&quot;-$&#123;date&#125;.sql  </code></pre></div></figure>\n<ol start=\"43\">\n<li>将文件中所有的小写字母转换为大写字母</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#!&#x2F;bin&#x2F;bash  \n  \n# 将文件中所有的小写字母转换为大写字母   \n# $1是位置参数,是你需要转换大小写字母的文件名称  \n# 执行脚本,给定一个文件名作为参数,脚本就会将该文件中所有的小写字母转换为大写字母  \ntr &quot;[a‐z]&quot; &quot;[A‐Z]&quot; &lt; $1  </code></pre></div></figure>\n<ol start=\"44\">\n<li>非交互自动生成 SSH 密钥文件</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#!&#x2F;bin&#x2F;bash  \n  \n# 非交互自动生成 SSH 密钥文件   \n# ‐t 指定 SSH 密钥的算法为 RSA 算法;‐N 设置密钥的密码为空;‐f 指定生成的密钥文件&gt;存放在哪里  \nrm  -rf  ~&#x2F;.ssh&#x2F;&#123;known_hosts,id_rsa*&#125;  \nssh‐keygen -t RSA -N &#39;&#39; -f ~&#x2F;.ssh&#x2F;id_rsa  </code></pre></div></figure>\n<ol start=\"45\">\n<li>检查特定的软件包是否已经安装</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#!&#x2F;bin&#x2F;bash  \n  \n# 检查特定的软件包是否已经安装   \nif [ $# -eq 0 ];then  \n  echo &quot;你需要制定一个软件包名称作为脚本参数&quot;  \n  echo &quot;用法:$0 软件包名称 ...&quot;  \nfi  \n# $@提取所有的位置变量的值,相当于$*  \nfor package in &quot;$@&quot;  \ndo  \n    if rpm -q $&#123;package&#125; &amp;&gt;&#x2F;dev&#x2F;null ;then  \n    echo -e &quot;$&#123;package&#125;\\033[32m 已经安装\\033[0m&quot;  \n    else  \n    echo -e &quot;$&#123;package&#125;\\033[34;1m 未安装\\033[0m&quot;  \n    fi  \ndone  </code></pre></div></figure>\n<ol start=\"46\">\n<li>监控 HTTP 服务器的状态(测试返回码)</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#!&#x2F;bin&#x2F;bash  \n  \n# 监控 HTTP 服务器的状态(测试返回码)  \n  \n# 设置变量,url为你需要检测的目标网站的网址(IP 或域名),比如百度  \nurl&#x3D;http:&#x2F;&#x2F;http:&#x2F;&#x2F;183.232.231.172&#x2F;index.html  \n  \n# 定义函数 check_http:  \n# 使用 curl 命令检查 http 服务器的状态  \n# ‐m 设置curl不管访问成功或失败,最大消耗的时间为 5 秒,5 秒连接服务为相应则视为无法连接  \n# ‐s 设置静默连接,不显示连接时的连接速度、时间消耗等信息  \n# ‐o 将 curl 下载的页面内容导出到&#x2F;dev&#x2F;null(默认会在屏幕显示页面内容)  \n# ‐w 设置curl命令需要显示的内容%&#123;http_code&#125;,指定curl返回服务器的状态码  \ncheck_http()  \n&#123;  \n        status_code&#x3D;$(curl -m 5 -s -o &#x2F;dev&#x2F;null -w %&#123;http_code&#125; $url)  \n&#125;  \n  \n  \nwhile :  \ndo  \n        check_http  \n        date&#x3D;$(date +%Y%m%d‐%H:%M:%S)  \n  \n  \n# 生成报警邮件的内容  \n        echo &quot;当前时间为:$date  \n        $url 服务器异常,状态码为$&#123;status_code&#125;.  \n        请尽快排查异常.&quot; &gt; &#x2F;tmp&#x2F;http$$.pid  \n  \n  \n# 指定测试服务器状态的函数,并根据返回码决定是发送邮件报警还是将正常信息写入日志  \n        if [ $status_code -ne 200 ];then  \n                mail -s Warning root &lt; &#x2F;tmp&#x2F;http$$.pid  \n        else  \n                echo &quot;$url 连接正常&quot; &gt;&gt; &#x2F;var&#x2F;log&#x2F;http.log  \n        fi  \n        sleep 5  \ndone  </code></pre></div></figure>\n<ol start=\"47\">\n<li>自动添加防火墙规则,开启某些服务或端口(适用于 RHEL7)</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#!&#x2F;bin&#x2F;bash  \n  \n# 自动添加防火墙规则,开启某些服务或端口(适用于 RHEL7)  \n#   \n# 设置变量定义需要添加到防火墙规则的服务和端口号  \n# 使用 firewall‐cmd ‐‐get‐services 可以查看 firewall 支持哪些服务  \nservice&#x3D;&quot;nfs http ssh&quot;  \nport&#x3D;&quot;80 22 8080&quot;  \n  \n# 循环将每个服务添加到防火墙规则中  \nfor i in $service  \ndo  \n    echo &quot;Adding $i service to firewall&quot;  \n    firewall‐cmd  --add-service&#x3D;$&#123;i&#125;  \ndone  \n  \n#循环将每个端口添加到防火墙规则中  \nfor i in $port  \ndo  \n    echo &quot;Adding $i Port to firewall&quot;  \n    firewall‐cmd --add-port&#x3D;$&#123;i&#125;&#x2F;tcp  \ndone  \n#将以上设置的临时防火墙规则,转换为永久有效的规则(确保重启后有效)  \nfirewall‐cmd  --runtime-to-permanent  </code></pre></div></figure>\n<ol start=\"48\">\n<li>使用脚本自动创建逻辑卷</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#!&#x2F;bin&#x2F;bash  \n  \n# 使用脚本自动创建逻辑卷   \n  \n  \n# 清屏,显示警告信息,创建将磁盘转换为逻辑卷会删除数据  \nclear  \necho -e &quot;\\033[32m           !!!!!!警告(Warning)!!!!!!\\033[0m&quot;  \necho  \necho &quot;+++++++++++++++++++++++++++++++++++++++++++++++++&quot;  \necho &quot;脚本会将整个磁盘转换为 PV,并删除磁盘上所有数据!!!&quot;  \necho &quot;This Script will destroy all data on the Disk&quot;  \necho &quot;+++++++++++++++++++++++++++++++++++++++++++++++++&quot;  \necho  \nread -p &quot;请问是否继续 y&#x2F;n?:&quot; sure  \n  \n# 测试用户输入的是否为 y,如果不是则退出脚本  \n[ $sure !&#x3D; y ] &amp;&amp; exit  \n  \n# 提示用户输入相关参数(磁盘、卷组名称等数据),并测试用户是否输入了这些值,如果没有输入,则脚本退出  \nread -p &quot;请输入磁盘名称,如&#x2F;dev&#x2F;vdb:&quot; disk  \n[ -z $disk ] &amp;&amp; echo &quot;没有输入磁盘名称&quot; &amp;&amp; exit  \nread -p &quot;请输入卷组名称:&quot; vg_name  \n[ -z $vg_name ] &amp;&amp; echo &quot;没有输入卷组名称&quot; &amp;&amp; exit  \nread -p &quot;请输入逻辑卷名称:&quot; lv_name  \n[ -z $lv_name ] &amp;&amp; echo &quot;没有输入逻辑卷名称&quot; &amp;&amp; exit  \nread -p &quot;请输入逻辑卷大小:&quot; lv_size  \n[ -z $lv_size ] &amp;&amp; echo &quot;没有输入逻辑卷大小&quot; &amp;&amp; exit  \n# 使用命令创建逻辑卷  \npvcreate $disk  \nvgcreate $vg_name $disk  \nlvcreate -L $&#123;lv_size&#125;M -n $&#123;lv_name&#125;  $&#123;vg_name&#125;  </code></pre></div></figure>\n<ol start=\"49\">\n<li>显示 CPU 厂商信息</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#!&#x2F;bin&#x2F;bash  \n  \n# 显示 CPU 厂商信息   \nawk &#39;&#x2F;vendor_id&#x2F;&#123;print $3&#125;&#39; &#x2F;proc&#x2F;cpuinfo | uniq</code></pre></div></figure>\n<ol start=\"50\">\n<li>删除某个目录下大小为 0 的文件</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#!&#x2F;bin&#x2F;bash  \n  \n# 删除某个目录下大小为 0 的文件  \n  \n#&#x2F;var&#x2F;www&#x2F;html 为测试目录,脚本会清空该目录下所有 0 字节的文件  \ndir&#x3D;&quot;&#x2F;var&#x2F;www&#x2F;html&quot;  \nfind $dir -type f -size 0 -exec rm -rf &#123;&#125; \\;  </code></pre></div></figure>\n<ol start=\"51\">\n<li>查找 Linux 系统中的僵尸进程</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#!&#x2F;bin&#x2F;bash  \n  \n# 查找 Linux 系统中的僵尸进程  \n# awk 判断 ps 命令输出的第 8 列为 Z 是,显示该进程的 PID 和进程命令  \nps aux | awk &#39;&#123;if($8 &#x3D;&#x3D; &quot;Z&quot;)&#123;print $2,$11&#125;&#125;&#39;  </code></pre></div></figure>\n<ol start=\"52\">\n<li>提示用户输入年份后判断该年是否为闰年</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#!&#x2F;bin&#x2F;bash  \n  \n# 提示用户输入年份后判断该年是否为闰年  \n  \n  \n# 能被4整除并且并不能被100整除的年份是闰年  \n# 能被400整除的年份也是闰年  \nread -p &quot;请输入一个年份:&quot; year  \n  \n  \nif [ &quot;$year&quot; &#x3D; &quot;&quot; ];then  \n    echo &quot;没有输入年份&quot;  \n    exit  \nfi  \n#使用正则测试变量 year 中是否包含大小写字母  \nif [[ &quot;$year&quot; &#x3D;~ [a‐Z] ]];then  \n    echo &quot;你输入的不是数字&quot;  \n    exit  \nfi  \n# 判断是否为闰年  \nif [ $[year % 4] -eq 0 ] &amp;&amp; [ $[year % 100] -ne 0 ];then  \n    echo &quot;$year年是闰年&quot;    \nelif [ $[year % 400] -eq 0 ];then  \n    echo &quot;$year年是闰年&quot;  \nelse  \n    echo &quot;$year年不是闰年&quot;  \nfi  </code></pre></div></figure>\n<ol start=\"53\">\n<li>生成随机密码(urandom 版本)</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#!&#x2F;bin&#x2F;bash  \n  \n# 生成随机密码(urandom 版本)   \n  \n# &#x2F;dev&#x2F;urandom 文件是 Linux 内置的随机设备文件  \n# cat &#x2F;dev&#x2F;urandom 可以看看里面的内容,ctrl+c 退出查看  \n# 查看该文件内容后,发现内容有些太随机,包括很多特殊符号,我们需要的密码不希望使用这些符号  \n# tr ‐dc &#39;_A‐Za‐z0‐9&#39; &lt; &#x2F;dev&#x2F;urandom  \n# 该命令可以将随机文件中其他的字符删除,仅保留大小写字母,数字,下划线,但是内容还是太多  \n# 我们可以继续将优化好的内容通过管道传递给 head 命令,在大量数据中仅显示头 10 个字节  \n# 注意 A 前面有个下划线  \ntr -dc &#39;_A‐Za‐z0‐9&#39; &lt;&#x2F;dev&#x2F;urandom | head -c 10  </code></pre></div></figure>\n<ol start=\"54\">\n<li>生成随机密码(字串截取版本)</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#!&#x2F;bin&#x2F;bash  \n  \n# 生成随机密码(字串截取版本)   \n  \n# 设置变量 key,存储密码的所有可能性(密码库),如果还需要其他字符请自行添加其他密码字符  \n# 使用$#统计密码库的长度  \nkey&#x3D;&quot;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;  \nnum&#x3D;$&#123;#key&#125;  \n# 设置初始密码为空  \npass&#x3D;&#39;&#39;  \n# 循环 8 次,生成随机密码  \n# 每次都是随机数对密码库的长度取余,确保提取的密码字符不超过密码库的长度  \n# 每次循环提取一位随机密码,并将该随机密码追加到 pass 变量的最后  \nfor i in &#123;1..8&#125;  \ndo    \n  index&#x3D;$[RANDOM%num]  \n  pass&#x3D;$pass$&#123;key:$index:1&#125;  \ndone  \necho $pass  </code></pre></div></figure>\n<ol start=\"55\">\n<li>生成随机密码(UUID 版本,16 进制密码)</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#!&#x2F;bin&#x2F;bash  \n  \n# 生成随机密码(UUID 版本,16 进制密码)   \nuuidgen  </code></pre></div></figure>\n<ol start=\"56\">\n<li>生成随机密码(进程 ID 版本,数字密码)</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#!&#x2F;bin&#x2F;bash  \n  \n# 生成随机密码(进程 ID 版本,数字密码)  \necho $$  </code></pre></div></figure>\n<ol start=\"57\">\n<li>测试用户名与密码是否正确</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#!&#x2F;bin&#x2F;bash  \n  \n# 测试用户名与密码是否正确  \n#用户名为 tom 并且密码为 123456,则提示登录成功,否则提示登录失败  \nread -p &quot;请输入用户名:&quot;  user  \nread -p &quot;请输入密码:&quot;    pass  \nif [ &quot;$user&quot; &#x3D;&#x3D; &#39;tom&#39; -a &quot;$pass&quot; &#x3D;&#x3D; &#39;123456&#39; ];then  \n  echo &quot;Login successful&quot;  \nelse  \n  echo &quot;Login Failed&quot;  \nfi  </code></pre></div></figure>\n<ol start=\"58\">\n<li>循环测试用户名与密码是否正确</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#!&#x2F;bin&#x2F;bash  \n  \n# 循环测试用户名与密码是否正确   \n# 循环测试用户的账户名和密码,最大测试 3 次,输入正确提示登录成功,否则提示登录失败  \n# 用户名为 tom 并且密码为 123456    \nfor i in &#123;1..3&#125;  \ndo  \n  read -p &quot;请输入用户名:&quot; user  \n  read -p &quot;请输入密码:&quot;   pass  \nif [ &quot;$user&quot; &#x3D;&#x3D; &#39;tom&#39; -a &quot;$pass&quot; &#x3D;&#x3D; &#39;123456&#39; ];then  \n    echo &quot;Login successful&quot;  \n     exit  \nfi  \ndone  \necho &quot;Login Failed&quot;  </code></pre></div></figure>\n<ol start=\"59\">\n<li>Shell 脚本的 fork 炸弹</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#!&#x2F;bin&#x2F;bash  \n  \n# Shell 脚本的 fork 炸弹   \n  \n  \n# 快速消耗计算机资源,致使计算机死机  \n# 定义函数名为.(点), 函数中递归调用自己并放入后台执行  \n.() &#123; .|.&amp; &#125;;. </code></pre></div></figure>\n<ol start=\"60\">\n<li>批量下载有序文件(pdf、图片、视频等等)</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#!&#x2F;bin&#x2F;bash  \n  \n# 批量下载有序文件(pdf、图片、视频等等)  \n  \n# 本脚本准备有序的网络资料进行批量下载操作(如 01.jpg,02.jpg,03.jpg)  \n# 设置资源来源的域名连接  \nurl&#x3D;&quot;http:&#x2F;&#x2F;www.baidu.com&#x2F;&quot;  \necho  &quot;开始下载...&quot;  \nsleep 2  \ntype&#x3D;jpg  \nfor i in &#96;seq 100&#96;  \n     echo &quot;正在下载$i.$type&quot;  \n  curl $url&#x2F;$i.$type -o &#x2F;tmp&#x2F;$&#123;i&#125;$type  \n     sleep 1  \ndone  \n#curl 使用-o 选项指定下载文件另存到哪里.  </code></pre></div></figure>\n<ol start=\"61\">\n<li>显示当前计算机中所有账户的用户名称</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\"> #!&#x2F;bin&#x2F;bash  \n  \n # 显示当前计算机中所有账户的用户名称  \n  \n# 下面使用3种不同的方式列出计算机中所有账户的用户名  \n# 指定以:为分隔符,打印&#x2F;etc&#x2F;passwd 文件的第 1 列  \nawk -F: &#39;&#123;print $1&#125;&#39; &#x2F;etc&#x2F;passwd  \n  \n# 指定以:为分隔符,打印&#x2F;etc&#x2F;passwd 文件的第 1 列  \ncut -d: -f1 &#x2F;etc&#x2F;passwd  \n  \n# 使用 sed 的替换功能,将&#x2F;etc&#x2F;passwd 文件中:后面的所有内容替换为空(仅显示用户名)  \nsed &#39;s&#x2F;:.*&#x2F;&#x2F;&#39; &#x2F;etc&#x2F;passwd  </code></pre></div></figure>\n<ol start=\"62\">\n<li>制定目录路径,脚本自动将该目录使用 tar 命令打包备份到/data目录</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#!&#x2F;bin&#x2F;bash  \n  \n# 制定目录路径,脚本自动将该目录使用 tar 命令打包备份到&#x2F;data目录   \n  \n  \n[ ! -d &#x2F;data ] &amp;&amp; mkdir &#x2F;data  \n[ -z $1 ] &amp;&amp; exit  \nif [ -d $1 ];then  \n  tar -czf &#x2F;data&#x2F;$1.-&#96;date +%Y%m%d&#96;.tar.gz $1  \nelse  \n    echo &quot;该目录不存在&quot;  \nfi  </code></pre></div></figure>\n<ol start=\"63\">\n<li>显示进度条(回旋镖版)</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#!&#x2F;bin&#x2F;bash  \n  \n# 显示进度条(回旋镖版)  \n  \n  \nwhile :  \ndo  \n  clear  \n  for i in &#123;1..20&#125;  \n  do  \n    echo ‐e &quot;\\033[3;$&#123;i&#125;H*&quot;  \n    sleep 0.1  \n    done  \n    clear  \n    for i in &#123;20..1&#125;  \n    do  \n    echo ‐e &quot;\\033[3;$&#123;i&#125;H*&quot;  \n    sleep 0.1  \n    done  \n    clear  \ndone  </code></pre></div></figure>\n<ol start=\"64\">\n<li>安装 LAMP 环境(yum 版本)</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#!&#x2F;bin&#x2F;bash  \n  \n# 安装 LAMP 环境(yum 版本)   \n# 本脚本适用于 RHEL7(RHEL6 中数据库为 mysql)  \nyum makecache &amp;&gt;&#x2F;dev&#x2F;null  \nnum&#x3D;$(yum repolist | awk &#39;&#x2F;repolist&#x2F;&#123;print $2&#125;&#39; | sed &#39;s&#x2F;,&#x2F;&#x2F;&#39;)  \nif [ $num -lt 0 ];then  \n  yum -y install httpd  \n  yum -y install mariadb mariadb-server mariadb-devel  \n  yum -y install php php-mysql  \nelse  \n  echo &quot;未配置 yum 源...&quot;  \nfi  </code></pre></div></figure>\n<ol start=\"65\">\n<li>循环关闭局域网中所有主机</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#!&#x2F;bin&#x2F;bash  \n  \n# 循环关闭局域网中所有主机   \n# 假设本机为 192.168.4.100,编写脚本关闭除自己外的其他所有主机  \n# 脚本执行,需要提前给所有其他主机传递 ssh 密钥,满足无密码连接  \nfor i in &#123;1..254&#125;  \ndo  \n  [ $i -eq 100 ] &amp;&amp; continue  \n  echo &quot;正在关闭 192.168.4.$i...&quot;  \n  ssh 192.168.4.$i poweroff  \ndone  </code></pre></div></figure>\n<ol start=\"66\">\n<li>获取本机 MAC 地址</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#!&#x2F;bin&#x2F;bash  \n  \n# 获取本机 MAC 地址  \nip a s | awk &#39;BEGIN&#123;print  &quot; 本 机 MAC 地 址 信 息 如 下 :&quot;&#125;&#x2F;^[0‐9]&#x2F;&#123;print $2;getline;if($0~&#x2F;link\\&#x2F;ether&#x2F;)&#123;print $2&#125;&#125;&#39; | grep -v lo:  \n# awk 读取 ip 命令的输出,输出结果中如果有以数字开始的行,先显示该行的地 2 列(网卡名称),  \n# 接着使用 getline 再读取它的下一行数据,判断是否包含 link&#x2F;ether  \n# 如果保护该关键词,就显示该行的第 2 列(MAC 地址)  \n# lo 回环设备没有 MAC,因此将其屏蔽,不显示 </code></pre></div></figure>\n<ol start=\"67\">\n<li>自动配置 rsynd 服务器的配置文件 rsyncd.conf</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#!&#x2F;bin&#x2F;bash  \n  \n# 自动配置 rsynd 服务器的配置文件 rsyncd.conf  \n  \n# See rsyncd.conf man page for more options.  \n  \n[ ! -d &#x2F;home&#x2F;ftp ] &amp;&amp; mkdir &#x2F;home&#x2F;ftp  \necho &#39;uid &#x3D; nobody  \ngid &#x3D; nobody  \nuse chroot &#x3D; yes  \nmax connections &#x3D; 4  \npid file &#x3D; &#x2F;var&#x2F;run&#x2F;rsyncd.pid  \nexclude &#x3D; lost+found&#x2F;  \ntransfer logging &#x3D; yes  \ntimeout &#x3D; 900  \nignore nonreadable &#x3D; yes  \ndont compress   &#x3D; *.gz *.tgz *.zip *.z *.Z *.rpm *.deb *.bz2  \n[ftp]  \n    path &#x3D; &#x2F;home&#x2F;ftp  \n    comment &#x3D; share&#39; &gt; &#x2F;etc&#x2F;rsyncd.conf  </code></pre></div></figure>\n<ol start=\"68\">\n<li>修改 Linux 系统的最大打开文件数量</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#!&#x2F;bin&#x2F;bash  \n  \n# 修改 Linux 系统的最大打开文件数量   \n  \n# 往&#x2F;etc&#x2F;security&#x2F;limits.conf 文件的末尾追加两行配置参数,修改最大打开文件数量为 65536  \ncat &gt;&gt; &#x2F;etc&#x2F;security&#x2F;limits.conf &lt;&lt;EOF  \n* soft nofile  65536  \n* hard nofile  65536  \nEOF  </code></pre></div></figure>\n<ol start=\"69\">\n<li>设置 Python 支持自动命令补齐功能</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#!&#x2F;bin&#x2F;bash  \n  \n# 设置 Python 支持自动命令补齐功能   \n  \n# Summary:Enable tab complete for python  \n# Description:  \n  \nNeeds import readline and rlcompleter module  \n#  \nimport readline  \n#  \nimport rlcompleter  \n#  \nhelp(rlcompleter) display detail: readline.parse_and_bind(&#39;tab: complete&#39;)  \n#  \nman python display detail: PYTHONSTARTUP variable  \n  \nif  [ ! -f &#x2F;usr&#x2F;bin&#x2F;tab.py ];then  \n  cat &gt;&gt; &#x2F;usr&#x2F;bin&#x2F;tab.py &lt;&lt;EOF  \nimport readline  \nimport rlcompleter  \nreadline.parse_and_bind(&#39;tab: complete&#39;)  \nEOF  \nfi  \nsed  -i &#39;$a export PYTHONSTARTUP&#x3D;&#x2F;usr&#x2F;bin&#x2F;tab.py&#39; &#x2F;etc&#x2F;profile  \nsource &#x2F;etc&#x2F;profile  </code></pre></div></figure>\n<ol start=\"70\">\n<li>自动修改计划任务配置文件</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">Docker+K8s+Jenkins 主流技术全解视频资料【干货免费分享】  \n  \n#!&#x2F;bin&#x2F;bash  \n  \n# 自动修改计划任务配置文件   \nread -p &quot;请输入分钟信息(00‐59):&quot; min  \nread -p &quot;请输入小时信息(00‐24):&quot; hour  \nread -p &quot;请输入日期信息(01‐31):&quot; date  \nread -p &quot;请输入月份信息(01‐12):&quot; month  \nread -p &quot;请输入星期信息(00‐06):&quot; weak  \nread -p &quot;请输入计划任务需要执行的命令或脚本:&quot; program  \necho &quot;$min $hour $date $month $weak $program&quot; &gt;&gt; &#x2F;etc&#x2F;crontab  </code></pre></div></figure>\n<ol start=\"71\">\n<li>使用脚本循环创建三位数字的文本文件(111-999 的文件)</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#!&#x2F;bin&#x2F;bash  \n  \n# 使用脚本循环创建三位数字的文本文件(111-999 的文件)   \n  \nfor i in &#123;1..9&#125;  \ndo  \n  for j in &#123;1..9&#125;  \n  do  \n    for k in &#123;1..9&#125;  \n    do  \n      touch &#x2F;tmp&#x2F;$i$j$k.txt  \n    done  \n    done  \ndone  </code></pre></div></figure>\n<ol start=\"72\">\n<li>找出/etc/passwd 中能登录的用户,并将对应在/etc/shadow 中第二列密码提出处理</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#!&#x2F;bin&#x2F;bash  \n  \n# 找出&#x2F;etc&#x2F;passwd 中能登录的用户,并将对应在&#x2F;etc&#x2F;shadow 中第二列密码提出处理  \n  \nuser&#x3D;$(awk -F: &#39;&#x2F;bash$&#x2F;&#123;print $1&#125;&#39; &#x2F;etc&#x2F;passwd)  \nfor i in $user  \ndo  \n  awk -F: -v x&#x3D;$i &#39;$1&#x3D;&#x3D;x&#123;print $1,$2&#125;&#39; &#x2F;etc&#x2F;shadow  \ndone  </code></pre></div></figure>\n<ol start=\"73\">\n<li>统计/etc/passwd 中 root 出现的次数</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#!&#x2F;bin&#x2F;bash  \n  \n# 统计&#x2F;etc&#x2F;passwd 中 root 出现的次数   \n  \n#每读取一行文件内容,即从第 1 列循环到最后 1 列,依次判断是否包含 root 关键词,如果包含则 x++  \nawk -F: &#39;&#123;i&#x3D;1;while(i&lt;&#x3D;NF)&#123;if($i~&#x2F;root&#x2F;)&#123;x++&#125;;i++&#125;&#125; END&#123;print &quot;root 出现次数为&quot;x&#125;&#39; &#x2F;etc&#x2F;passwd  </code></pre></div></figure>\n<ol start=\"74\">\n<li>统计 Linux 进程相关数量信息</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#!&#x2F;bin&#x2F;bash  \n  \n# 统计 Linux 进程相关数量信息   \nrunning&#x3D;0  \nsleeping&#x3D;0  \nstoped&#x3D;0  \nzombie&#x3D;0  \n# 在 proc 目录下所有以数字开始的都是当前计算机正在运行的进程的进程 PID  \n# 每个 PID 编号的目录下记录有该进程相关的信息  \nfor pid in &#x2F;proc&#x2F;[1‐9]*  \ndo  \n  procs&#x3D;$[procs+1]  \n  stat&#x3D;$(awk &#39;&#123;print $3&#125;&#39; $pid&#x2F;stat)  \n# 每个 pid 目录下都有一个 stat 文件,该文件的第 3 列是该进程的状态信息  \n    case $stat in  \n    R)  \n    running&#x3D;$[running+1]  \n    ;;  \n    T)  \n    stoped&#x3D;$[stoped+1]  \n    ;;  \n    S)  \n    sleeping&#x3D;$[sleeping+1]  \n    ;;  \n    Z)  \n     zombie&#x3D;$[zombie+1]  \n     ;;  \n    esac  \ndone  \necho &quot;进程统计信息如下&quot;  \necho &quot;总进程数量为:$procs&quot;  \necho &quot;Running 进程数为:$running&quot;  \necho &quot;Stoped 进程数为:$stoped&quot;  \necho &quot;Sleeping 进程数为:$sleeping&quot;  \necho &quot;Zombie 进程数为:$zombie&quot;  </code></pre></div></figure>\n<ol start=\"75\">\n<li>从键盘读取一个论坛积分,判断论坛用户等级</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#!&#x2F;bin&#x2F;bash  \n  \n# 从键盘读取一个论坛积分,判断论坛用户等级  \n  \n#等级分类如下:  \n#  大于等于 90        神功绝世  \n#  大于等于 80,小于 90       登峰造极  \n#  大于等于 70,小于 80       炉火纯青  \n#  大于等于 60,小于 70       略有小成  \n#  小于 60               初学乍练  \nread -p &quot;请输入积分(0‐100):&quot; JF  \nif [ $JF -ge 90 ] ; then  \n  echo &quot;$JF 分,神功绝世&quot;  \nelif [ $JF -ge 80 ] ; then  \n    echo &quot;$JF 分,登峰造极&quot;  \nelif [ $JF -ge 70 ] ; then  \n    echo &quot;$JF 分,炉火纯青&quot;  \nelif [ $JF -lt 60 ] ; then  \n    echo &quot;$JF 分,略有小成&quot;  \nelse  \n    echo &quot;$JF 分,初学乍练&quot;  \nfi  </code></pre></div></figure>\n<ol start=\"76\">\n<li>判断用户输入的数据类型(字母、数字或其他)</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#!&#x2F;bin&#x2F;bash  \n  \n# 判断用户输入的数据类型(字母、数字或其他)   \nread -p &quot;请输入一个字符:&quot; KEY  \ncase &quot;$KEY&quot; in  \n  [a‐z]|[A‐Z])  \n    echo &quot;字母&quot;   \n    ;;  \n  [0‐9])  \n    echo &quot;数字&quot;   \n    ;;  \n  *)  \n    echo &quot;空格、功能键或其他控制字符&quot;  \nesac  </code></pre></div></figure>\n<ol start=\"77\">\n<li>显示进度条(数字版)</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#!&#x2F;bin&#x2F;bash  \n  \n# 显示进度条(数字版)   \n# echo 使用‐e 选项后,在打印参数中可以指定 H,设置需要打印内容的 x,y 轴的定位坐标  \n# 设置需要打印内容在第几行,第几列  \nfor i in &#123;1..100&#125;  \ndo  \n    echo -e &quot;\\033[6;8H[&quot;  \n    echo -e &quot;\\033[6;9H$i%&quot;  \n    echo -e &quot;\\033[6;13H]&quot;  \n    sleep 0.1  \ndone  </code></pre></div></figure>\n<ol start=\"78\">\n<li>打印斐波那契数列</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#!&#x2F;bin&#x2F;bash  \n  \n# 打印斐波那契数列(该数列的特点是后一个数字,永远都是前 2 个数字之和)   \n  \n# 斐波那契数列后一个数字永远是前 2 个数字之和  \n# 如:0  1  1  2  3  5  8  13 ... ...  \nlist&#x3D;(0 1)  \nfor i in &#96;seq 2 11&#96;  \ndo  \n  list[$i]&#x3D;&#96;expr $&#123;list[‐1]&#125; + $&#123;list[‐2]&#125;&#96;  \ndone  \necho $&#123;list[@]&#125;  </code></pre></div></figure>\n<ol start=\"79\">\n<li>判断用户输入的是 Yes 或 NO</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#!&#x2F;bin&#x2F;bash  \n  \n# 判断用户输入的是 Yes 或 NO   \n  \nread -p  &quot;Are you sure?[y&#x2F;n]:&quot;  sure  \ncase  $sure  in  \n  y|Y|Yes|YES)    \n    echo &quot;you enter $a&quot;  \n    ;;  \n    n|N|NO|no)  \n     echo &quot;you enter $a&quot;  \n     ;;  \n    *)  \n     echo &quot;error&quot;;;  \nesac  </code></pre></div></figure>\n<ol start=\"80\">\n<li>显示本机 Linux 系统上所有开放的端口列表</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#!&#x2F;bin&#x2F;bash  \n  \n# 显示本机 Linux 系统上所有开放的端口列表   \n  \n# 从端口列表中观测有没有没用的端口,有的话可以将该端口对应的服务关闭,防止意外的攻击可能性  \nss -nutlp | awk &#39;&#123;print $1,$5&#125;&#39; | awk -F&quot;[: ]&quot; &#39;&#123;print &quot;协议:&quot;$1,&quot;端口号:&quot;$NF&#125;&#39; | grep &quot;[0‐9]&quot; | uniq  </code></pre></div></figure>\n<ol start=\"81\">\n<li>将 Linux 系统中 UID 大于等于 1000 的普通用户都删除</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#!&#x2F;bin&#x2F;bash  \n  \n# 将 Linux 系统中 UID 大于等于 1000 的普通用户都删除   \n  \n# 先用 awk 提取所有 uid 大于等于 1000 的普通用户名称  \n# 再使用 for 循环逐个将每个用户删除即可  \nuser&#x3D;$(awk -F: &#39;$3&gt;&#x3D;1000&#123;print $1&#125;&#39; &#x2F;etc&#x2F;passwd)  \nfor i in $user  \ndo  \n     userdel -r $i  \ndone  </code></pre></div></figure>\n<ol start=\"82\">\n<li>使用脚本开启关闭虚拟机</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#!&#x2F;bin&#x2F;bash  \n  \n# 使用脚本开启关闭虚拟机   \n# 脚本通过调用virsh命令实现对虚拟机的管理,如果没有该命令,需要安装 libvirt‐client 软件包  \n# $1是脚本的第1个参数,$2是脚本的第2个参数  \n# 第1个参数是你希望对虚拟机进行的操作指令,第2个参数是虚拟机名称  \ncase $1 in  \n  list)  \n    virsh list --all  \n    ;;  \n  start)  \n    virsh start $2  \n    ;;  \n  stop)  \n    virsh destroy $2  \n    ;;  \n  enable)  \n    virsh autostart $2  \n    ;;  \n  disable)  \n    virsh autostart --disable $2  \n    ;;  \n  *)  \n    echo &quot;Usage:$0 list&quot;  \n    echo &quot;Usage:$0 [start|stop|enable|disable]  VM_name&quot;  \n    cat &lt;&lt; EOF  \n    #list      显示虚拟机列表  \n    #start     启动虚拟机  \n    #stop      关闭虚拟机  \n    #enable    设置虚拟机为开机自启  \n    #disable   关闭虚拟机开机自启功能  \n    EOF  \n    ;;  \nesac  </code></pre></div></figure>\n<ol start=\"83\">\n<li>调整虚拟机内存参数的 shell 脚本</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#!&#x2F;bin&#x2F;bash  \n  \n# 调整虚拟机内存参数的 shell 脚本   \n# 脚本通过调用 virsh 命令实现对虚拟机的管理,如果没有该命令,需要安装 libvirt‐client 软件包  \ncat &lt;&lt; EOF  \n1.调整虚拟机最大内存数值  \n2.调整实际分配给虚拟机的内存数值  \nEOF  \nread -p &quot;请选择[1‐2]:&quot; select  \ncase $select in  \n  1)  \n      read -p &quot;请输入虚拟机名称&quot; name  \n      read -p &quot;请输入最大内存数值(单位:k):&quot; size  \n      virsh setmaxmem $name --size $size --config  \n      ;;  \n  2)  \n      read -p &quot;请输入虚拟机名称&quot; name  \n      read -p &quot;请输入实际分配内存数值(单位:k):&quot; size  \n      virsh setmem $name $size  \n      ;;  \n  *)  \n      echo &quot;Error&quot;  \n      ;;  \nesac  </code></pre></div></figure>\n<ol start=\"84\">\n<li>查看 KVM 虚拟机中的网卡信息(不需要进入启动或进入虚拟机)</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#!&#x2F;bin&#x2F;bash  \n  \n# 查看 KVM 虚拟机中的网卡信息(不需要进入启动或进入虚拟机)   \n  \n# 该脚本使用 guestmount 工具,可以将虚拟机的磁盘系统挂载到真实机文件系统中  \n# Centos7.2 中安装 libguestfs‐tools‐c 可以获得 guestmount 工具  \n# 虚拟机可以启动或者不启动都不影响该脚本的使用  \n# 将虚拟机磁盘文件挂载到文件系统后,就可以直接读取磁盘文件中的网卡配置文件中的数据  \nclear  \nmountpoint&#x3D;&quot;&#x2F;media&#x2F;virtimage&quot;  \n[ ! -d $mountpoint ] &amp;&amp; mkdir $mountpoint  \nread -p &quot;输入虚拟机名称:&quot; name  \necho &quot;请稍后...&quot;  \n# 如果有设备挂载到该挂载点,则先 umount 卸载  \nif mount | grep -q &quot;$mountpoint&quot; ;then  \n  umount $mountpoint  \nfi  \n# 只读的方式,将虚拟机的磁盘文件挂载到特定的目录下,这里是&#x2F;media&#x2F;virtimage 目录  \nguestmount -r -d $name -i $mountpoint  \necho  \necho &quot;‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐&quot;  \necho -e &quot;\\033[32m$name 虚拟机中网卡列表如下:\\033[0m&quot;  \ndev&#x3D;$(ls &#x2F;media&#x2F;virtimage&#x2F;etc&#x2F;sysconfig&#x2F;network‐scripts&#x2F;ifcfg-* |awk -F&quot;[&#x2F;‐]&quot; &#39;&#123;print $9&#125;&#39;)  \necho $dev  \necho &quot;‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐&quot;  \necho  \necho  \necho &quot;+++++++++++++++++++++++++++++++++++++++++++&quot;  \necho -e &quot;\\033[32m 网卡 IP 地址信息如下:\\033[0m&quot;  \nfor i in $dev  \ndo  \n  echo -n &quot;$i:&quot;  \n  grep -q &quot;IPADDR&quot; &#x2F;media&#x2F;virtimage&#x2F;etc&#x2F;sysconfig&#x2F;network‐scripts&#x2F;ifcfg-$i || echo &quot;未配置 IP地址&quot;  \n  awk -F&#x3D; &#39;&#x2F;IPADDR&#x2F;&#123;print $2&#125;&#39; &#x2F;media&#x2F;virtimage&#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-$i  \ndone  \necho &quot;+++++++++++++++++++++++++++++++++++++++++++&quot;  </code></pre></div></figure>\n<ol start=\"85\">\n<li>不登陆虚拟机,修改虚拟机网卡 IP 地址</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#!&#x2F;bin&#x2F;bash  \n  \n# 不登陆虚拟机,修改虚拟机网卡 IP 地址   \n  \n# 该脚本使用 guestmount 工具,Centos7.2 中安装 libguestfs‐tools‐c 可以获得 guestmount 工具  \n# 脚本在不登陆虚拟机的情况下,修改虚拟机的 IP 地址信息  \n# 在某些环境下,虚拟机没有 IP 或 IP 地址与真实主机不在一个网段  \n# 真实主机在没有 virt‐manger 图形的情况下,远程连接虚拟机很麻烦  \n# 该脚本可以解决类似的问题  \nread -p &quot;请输入虚拟机名称:&quot; name  \nif virsh domstate $name | grep -q running ;then  \n  echo &quot;修改虚拟机网卡数据,需要关闭虚拟机&quot;  \n  virsh destroy $name  \nfi  \nmountpoint&#x3D;&quot;&#x2F;media&#x2F;virtimage&quot;  \n[ ! -d $mountpoint ] &amp;&amp; mkdir $mountpoint  \necho &quot;请稍后...&quot;  \nif mount | grep -q &quot;$mountpoint&quot; ;then  \n  umount $mountpoint  \nfi  \nguestmount  -d $name -i $mountpoint  \nread -p &quot;请输入需要修改的网卡名称:&quot; dev  \nread -p &quot;请输入 IP 地址:&quot; addr  \n# 判断原本网卡配置文件中是否有 IP 地址,有就修改该 IP,没有就添加一个新的 IP 地址  \nif grep -q &quot;IPADDR&quot;  $mountpoint&#x2F;etc&#x2F;sysconfig&#x2F;network‐scripts&#x2F;ifcfg‐$dev ;then  \n  sed -i &quot;&#x2F;IPADDR&#x2F;s&#x2F;&#x3D;.*&#x2F;&#x3D;$addr&#x2F;&quot;  $mountpoint&#x2F;etc&#x2F;sysconfig&#x2F;network‐scripts&#x2F;ifcfg‐$dev  \nelse  \n  echo &quot;IPADDR&#x3D;$addr&quot; &gt;&gt; $mountpoint&#x2F;etc&#x2F;sysconfig&#x2F;network‐scripts&#x2F;ifcfg‐$dev  \nfi  \n# 如果网卡配置文件中有客户配置的 IP 地址,则脚本提示修改 IP 完成  \nawk -F&#x3D; -v x&#x3D;$addr &#39;$2&#x3D;&#x3D;x&#123;print &quot;完成...&quot;&#125;&#39;  $mountpoint&#x2F;etc&#x2F;sysconfig&#x2F;network‐scripts&#x2F;ifcfg-$dev  </code></pre></div></figure>\n<ol start=\"86\">\n<li>破解虚拟机密码,无密码登陆虚拟机系统</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#!&#x2F;bin&#x2F;bash  \n  \n# 破解虚拟机密码,无密码登陆虚拟机系统   \n  \n# 该脚本使用 guestmount 工具,Centos7.2 中安装 libguestfs‐tools‐c 可以获得 guestmount 工具  \nread -p &quot;请输入虚拟机名称:&quot; name  \nif virsh domstate $name | grep -q running ;then  \n  echo &quot;破解,需要关闭虚拟机&quot;  \n  virsh destroy $name  \nfi  \nmountpoint&#x3D;&quot;&#x2F;media&#x2F;virtimage&quot;  \n[ ! -d $mountpoint ] &amp;&amp; mkdir $mountpoint  \necho &quot;请稍后...&quot;  \nif mount | grep -q &quot;$mountpoint&quot; ;then  \n  umount $mountpoint  \nfi  \nguestmount -d $name -i $mountpoint  \n# 将 passwd 中密码占位符号 x 删除,该账户即可实现无密码登陆系统  \nsed -i &quot;&#x2F;^root&#x2F;s&#x2F;x&#x2F;&#x2F;&quot; $mountpoint&#x2F;etc&#x2F;passwd </code></pre></div></figure>\n<ol start=\"87\">\n<li>Shell 脚本对信号的处理,执行脚本后,按键盘 Ctrl+C 无法终止的脚本</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#!&#x2F;bin&#x2F;bash  \n  \n# Shell 脚本对信号的处理,执行脚本后,按键盘 Ctrl+C 无法终止的脚本   \n# 使用 trap 命令可以拦截用户通过键盘或 kill 命令发送过来的信号  \n# 使用 kill ‐l 可以查看 Linux 系统中所有的信号列表,其中 2 代表 Ctrl+C  \n# trap 当发现有用户 ctrl+C 希望终端脚本时,就执行 echo &quot;暂停 10s&quot;;sleep 10 这两条命令  \n# 另外用户使用命令:[ kill ‐2 脚本的 PID ] 也可以中断脚本和 Ctrl+C 一样的效果,都会被 trap 拦截  \ntrap &#39;echo &quot;暂停 10s&quot;;sleep 10&#39; 2  \nwhile :  \ndo  \n  echo &quot;go go go&quot;  \ndone  </code></pre></div></figure>\n<ol start=\"88\">\n<li>一键部署 memcached</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#!&#x2F;bin&#x2F;bash  \n  \n# 一键部署 memcached   \n# 脚本用源码来安装 memcached 服务器  \n# 注意:如果软件的下载链接过期了,请更新 memcached 的下载链接  \nwget http:&#x2F;&#x2F;www.memcached.org&#x2F;files&#x2F;memcached-1.5.1.tar.gz  \nyum -y install gcc  \ntar -xf  memcached‐1.5.1.tar.gz  \ncd memcached‐1.5.1  \n.&#x2F;configure  \nmake  \nmake install  </code></pre></div></figure>\n<ol start=\"89\">\n<li>一键配置 VNC 远程桌面服务器(无密码版本)</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#!&#x2F;bin&#x2F;bash  \n  \n# 一键配置 VNC 远程桌面服务器(无密码版本)  \n  \n# 脚本配置的 VNC 服务器,客户端无需密码即可连接  \n# 客户端仅有查看远程桌面的权限,没有鼠标和键盘的操作权限  \n  \nrpm --quiet -q tigervnc‐server  \nif [  $? -ne  0 ];then  \n  yum  -y  tigervnc‐server  \nfi  \nx0vncserver AcceptKeyEvents&#x3D;0 AlwaysShared&#x3D;1 \\  \nAcceptPointerEvents&#x3D;0 SecurityTypes&#x3D;None  rfbport&#x3D;5908  </code></pre></div></figure>\n<ol start=\"90\">\n<li>关闭 SELinux</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#!&#x2F;bin&#x2F;bash  \n  \n# 关闭 SELinux   \n  \nsed -i  &#39;&#x2F;^SELINUX&#x2F;s&#x2F;&#x3D;.*&#x2F;&#x3D;disabled&#x2F;&#39; &#x2F;etc&#x2F;selinux&#x2F;config  \nsetenforce 0  </code></pre></div></figure>\n<ol start=\"91\">\n<li>查看所有虚拟机磁盘使用量以及CPU使用量信息</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#!&#x2F;bin&#x2F;bash  \n  \n# 查看所有虚拟机磁盘使用量以及CPU使用量信息   \n  \nvirt‐df  \nread -n1 &quot;按任意键继续&quot; key  \nvirt‐top  </code></pre></div></figure>\n<ol start=\"92\">\n<li>使用 shell 脚本打印图形</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#!&#x2F;bin&#x2F;bash  \n  \n# 使用 shell 脚本打印如下图形:   \n# 打印第一组图片  \n# for(())为类 C 语言的语法格式,也可以使用 for i  in;do  ;done 的格式替换  \n# for((i&#x3D;1;i&lt;&#x3D;9;i++))循环会执行 9 次,i 从 1 开始到 9,每循环一次 i 自加 1  \nclear  \nfor (( i&#x3D;1; i&lt;&#x3D;9; i++ ))  \ndo  \n  for (( j&#x3D;1; j&lt;&#x3D;i; j++ ))  \n  do  \n    echo -n &quot;$i&quot;  \n  done  \n  echo &quot;&quot;  \ndone  \nread  -n1  &quot;按任意键继续&quot;  key  \n#打印第二组图片  \nclear  \nfor (( i&#x3D;1; i&lt;&#x3D;5; i++ ))   \ndo  \n  for (( j&#x3D;1; j&lt;&#x3D;i; j++ ))  \n  do  \n    echo -n &quot; |&quot;  \n  done  \n  echo &quot;_ &quot;  \ndone  \nread  -n1  &quot;按任意键继续&quot;  key  \n#打印第三组图片  \nclear  \nfor (( i&#x3D;1; i&lt;&#x3D;5; i++ ))  \ndo  \n  for (( j&#x3D;1; j&lt;&#x3D;i; j++ ))  \n  do  \n    echo -n &quot; *&quot;  \n  done  \n  echo &quot;&quot;  \ndone  \nfor (( i&#x3D;5; i&gt;&#x3D;1; i‐‐ ))  \ndo  \n  for (( j&#x3D;1; j&lt;&#x3D;i; j++ ))  \n  do  \n    echo -n &quot; *&quot;  \n  done  \n  echo &quot;&quot;  \ndone  </code></pre></div></figure>\n<ol start=\"93\">\n<li>根据计算机当前时间,返回问候语,可以将该脚本设置为开机启动</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#!&#x2F;bin&#x2F;bash  \n  \n# 根据计算机当前时间,返回问候语,可以将该脚本设置为开机启动   \n  \n# 00‐12 点为早晨,12‐18 点为下午,18‐24 点为晚上  \n# 使用 date 命令获取时间后,if 判断时间的区间,确定问候语内容  \ntm&#x3D;$(date +%H)  \nif [ $tm -le 12 ];then  \n  msg&#x3D;&quot;Good Morning $USER&quot;  \nelif [ $tm -gt 12 -a $tm -le 18 ];then  \n    msg&#x3D;&quot;Good Afternoon $USER&quot;  \nelse  \n    msg&#x3D;&quot;Good Night $USER&quot;  \nfi  \necho &quot;当前时间是:$(date +&quot;%Y‐%m‐%d %H:%M:%S&quot;)&quot;  \necho -e &quot;\\033[34m$msg\\033[0m&quot;  </code></pre></div></figure>\n<ol start=\"94\">\n<li>读取用户输入的账户名称,将账户名写入到数组保存</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#!&#x2F;bin&#x2F;bash  \n  \n# 读取用户输入的账户名称,将账户名写入到数组保存   \n# 定义数组名称为 name,数组的下标为 i,小标从 0 开始,每输入一个账户名,下标加 1,继续存下一个账户  \n# 最后,输入 over,脚本输出总结性信息后脚本退出  \ni&#x3D;0  \nwhile :  \ndo  \n  read -p &quot;请输入账户名,输入 over 结束:&quot; key  \n  if [ $key &#x3D;&#x3D; &quot;over&quot; ];then   \n    break  \n    else  \n    name[$i]&#x3D;$key  \n    let i++  \n    fi  \ndone  \necho &quot;总账户名数量:$&#123;#name[*]&#125;&quot;  \necho &quot;$&#123;name[@]&#125;&quot;  </code></pre></div></figure>\n<ol start=\"95\">\n<li>判断文件或目录是否存在</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#!&#x2F;bin&#x2F;bash  \n  \n# 判断文件或目录是否存在   \nif [ $# -eq 0 ] ;then  \necho &quot;未输入任何参数,请输入参数&quot;  \necho &quot;用法:$0 [文件名|目录名]&quot;  \nfi  \nif [ -f $1 ];then  \n  echo &quot;该文件,存在&quot;  \n  ls -l $1  \nelse  \n  echo &quot;没有该文件&quot;  \nfi  \nif [ -d  $1 ];then  \n     echo &quot;该目录,存在&quot;  \n     ls -ld  $2  \nelse  \n     echo &quot;没有该目录&quot;  \nfi  </code></pre></div></figure>\n<ol start=\"96\">\n<li>打印各种格式的时间</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#!&#x2F;bin&#x2F;bash  \n  \n# 打印各种时间格式   \n  \necho &quot;显示星期简称(如:Sun)&quot;  \ndate +%a  \necho &quot;显示星期全称(如:Sunday)&quot;  \ndate +%A  \necho &quot;显示月份简称(如:Jan)&quot;  \ndate +%b  \necho &quot;显示月份全称(如:January)&quot;  \ndate +%B  \necho &quot;显示数字月份(如:12)&quot;  \ndate +%m  \necho &quot;显示数字日期(如:01 号)&quot;  \ndate +%d  \necho &quot;显示数字年(如:01 号)&quot;  \ndate +%Y echo &quot;显示年‐月‐日&quot;  \ndate +%F  \necho &quot;显示小时(24 小时制)&quot;  \ndate +%H  \necho &quot;显示分钟(00..59)&quot;  \ndate +%M  \necho &quot;显示秒&quot;  \ndate +%S  \necho &quot;显示纳秒&quot;  \ndate +%N  \necho &quot;组合显示&quot;  \ndate +&quot;%Y%m%d %H:%M:%S&quot; </code></pre></div></figure>\n<ol start=\"97\">\n<li>使用 egrep 过滤 MAC 地址</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#!&#x2F;bin&#x2F;bash  \n  \n# 使用 egrep 过滤 MAC 地址   \n  \n# MAC 地址由 16 进制组成,如 AA:BB:CC:DD:EE:FF  \n# [0‐9a‐fA‐F]&#123;2&#125;表示一段十六进制数值,&#123;5&#125;表示连续出现5组前置:的十六进制  \negrep &quot;[0‐9a‐fA‐F]&#123;2&#125;(:[0‐9a‐fA‐F]&#123;2&#125;)&#123;5&#125;&quot; $1  </code></pre></div></figure>\n<ol start=\"98\">\n<li>统计双色球各个数字的中奖概率</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#!&#x2F;bin&#x2F;bash  \n  \n# 统计双色球各个数字的中奖概率   \n  \n# 往期双色球中奖号码如下:  \n# 01 04 11 28 31 32  16  \n# 04 07 08 18 23 24  02  \n# 02 05 06 16 28 29  04  \n# 04 19 22 27 30 33  01  \n# 05 10 18 19 30 31  03  \n# 02 06 11 12 19 29  06  \n# 统计篮球和红球数据出现的概率次数(篮球不分顺序,统计所有篮球混合在一起的概率)  \nawk &#39;&#123;print $1&quot;\\n&quot;$2&quot;\\n&quot;$3&quot;\\n&quot;$4&quot;\\n&quot;$5&quot;\\n&quot;$6&#125;&#39; 1.txt | sort | uniq -c | sort  \nawk &#39;&#123;print $7&#125;&#39; 1.txt | sort | uniq -c | sort  </code></pre></div></figure>\n<ol start=\"99\">\n<li>生成签名私钥和证书</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#!&#x2F;bin&#x2F;bash  \n  \n# 生成签名私钥和证书   \n  \nread -p &quot;请输入存放证书的目录:&quot; dir  \nif [ ! -d $dir ];then  \n  echo &quot;该目录不存在&quot;  \n  exit  \nfi  \nread -p &quot;请输入密钥名称:&quot; name  \n# 使用 openssl 生成私钥  \nopenssl genrsa -out $&#123;dir&#125;&#x2F;$&#123;name&#125;.key  \n# 使用 openssl 生成证书 #subj 选项可以在生成证书时,非交互自动填写 Common Name 信息  \nopenssl req -new -x509 -key $&#123;dir&#125;&#x2F;$&#123;name&#125;.key -subj &quot;&#x2F;CN&#x3D;common&quot; -out $&#123;dir&#125;&#x2F;$&#123;name&#125;.crt  </code></pre></div></figure>\n<ol start=\"100\">\n<li>使用 awk 编写的 wc 程序</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#!&#x2F;bin&#x2F;bash  \n  \n# 使用 awk 编写的 wc 程序   \n  \n# 自定义变量 chars 变量存储字符个数,自定义变量 words 变量存储单词个数  \n# awk 内置变量 NR 存储行数  \n# length()为 awk 内置函数,用来统计每行的字符数量,因为每行都会有一个隐藏的$,所以每次统计后都+1  \n# wc 程序会把文件结尾符$也统计在内,可以使用 cat ‐A 文件名,查看该隐藏字符  \nawk &#39;&#123;chars+&#x3D;length($0)+1;words+&#x3D;NF&#125; END&#123;print NR,words,chars&#125;&#39; $1</code></pre></div></figure>\n<h2 id=\"参考-致谢\">参考&amp;致谢</h2>\n<ul>\n<li><a href=\"https://www.jb51.net/article/48686.htm\">bash shell命令行选项与修传入参数处理_linux shell</a></li>\n<li><a href=\"blog.csdn.net/yugemengjing/article/details/82469785\">100个实用的经典 Linux Shell 脚本案例参考</a></li>\n</ul>\n<link rel=\"stylesheet\" href=\"https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css\"><script src=\"https://fastly.jsdelivr.net/npm/d3@7\"></script><script src=\"https://fastly.jsdelivr.net/npm/markmap-view@0.18.10\"></script><script src=\"https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10\"></script>\n<link rel=\"stylesheet\" href=\"/css/markmap.css\">\n\n<script src=\"/js/markmap.js\"></script>\n",
            "tags": [
                "linux",
                "shell",
                "bash"
            ]
        },
        {
            "id": "https://blog.17lai.site/posts/e691e603/",
            "url": "https://blog.17lai.site/posts/e691e603/",
            "title": "常用Linux Bash命令教程",
            "date_published": "2022-05-28T13:49:36.000Z",
            "content_html": "<blockquote>\n<p>常用linux命令介绍。入门Linux必学的命令行，熟练掌握后，效率远超Windows GUI操作。重要的是，可以方便的做自动化处理！</p>\n<p><mark>更多命令在线查询</mark> <a href=\"https://linux-command.17lai.site/\">linux-command.17lai.site</a></p>\n</blockquote>\n<span id=\"more\"></span>\n<p><img src=\"https://cimg1.17lai.site/data/2022/04/2120220421192048.svg\" alt=\"Linux shell\"></p>\n<h2 id=\"Bash-基础\">Bash 基础</h2>\n<h2 id=\"说明\">说明</h2>\n<p>记录在Linux中经常会用到的命令，持续更新。更多命令详解可参考：</p>\n<ul>\n<li><a href=\"https://linuxtools-rst.readthedocs.io/zh_CN/latest/index.html\">Linux Tools Quick Tutorial</a></li>\n<li><a href=\"https://www.runoob.com/linux/linux-command-manual.html\">Linux 命令大全</a></li>\n<li><a href=\"https://wangdoc.com/bash/intro.html\">Bash 脚本教程</a></li>\n<li><a href=\"https://wangdoc.com/ssh/index.html\">SSH 教程</a></li>\n</ul>\n<h3 id=\"Shell选择与切换\">Shell选择与切换</h3>\n<p>在现代的 Linux 上，sh 已经被 bash 代替，<code>/bin/sh</code>往往是指向<code>/bin/bash</code>的符号链接。早期macos系统默认使用bash解释器，在macos10.15系统中官方推荐使用zsh解释器。bash和zsh均是shell的一种，由于bash或zsh本质上都是解释器，他们所共同服务的是shell语言，因此在命令语法上基本相同，zsh能基本完美兼容bash的命令，并且使用起来更加优雅。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">$ echo $SHELL               # 查看当前默认shell\n$ cat &#x2F;etc&#x2F;shells          # 查看系统安装了哪些shell\n\n$ chsh -s &#x2F;bin&#x2F;bash        # 切换bash,读取的配置文件：~&#x2F;.bash_profile\n$ chsh -s &#x2F;bin&#x2F;zsh        # 切换,读取的配置文件：~&#x2F;.zshrc</code></pre></div></figure>\n<p>当从bash切换为zsh时，如果不想重新配置一遍<code>.zshrc</code>文件，可以在<code>.zshrc</code>文件中加上<code>source ~/.bash_profile</code>，从而直接从<code>.bash_profile</code>文件读取配置。</p>\n<p>如果选择zsh，会获得如下好用的功能：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">$ cd .....                         # 输入n+1个点，可以往上跳转n层\n$ kill process_name        # 自动补全进程ID\n$ d                                        # 列出最近访问过的目录，然后选择目录前面的数字进行快速跳转\n$ r                                        # 重复执行上一条命令\n$ commond + tab                # 常用命令参数补全提醒</code></pre></div></figure>\n<p>扩展阅读：<a href=\"https://xiaozhou.net/learn-the-command-line-iterm-and-zsh-2017-06-23.html\">程序员内功系列–iTerm与Zsh篇</a></p>\n<h3 id=\"特殊命令符号\">特殊命令符号</h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">符号</th>\n<th style=\"text-align:left\">格式</th>\n<th style=\"text-align:left\">作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">;</td>\n<td style=\"text-align:left\">命令1;命令2</td>\n<td style=\"text-align:left\">多个命令顺序执行，命令之间无任何逻辑关系</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&amp;&amp;</td>\n<td style=\"text-align:left\">命令1&amp;&amp;命令2</td>\n<td style=\"text-align:left\">逻辑与：当命令1正确执行后，命令2才会正确执行，否则命令2不会执行</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">||</td>\n<td style=\"text-align:left\">命令1||命令2</td>\n<td style=\"text-align:left\">逻辑或：当命令1不正确执行后，命令2才会正确执行，否则命令2不会执行</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">|</td>\n<td style=\"text-align:left\">命令1命令2</td>\n<td style=\"text-align:left\">管道符：命令1的正确输出作为命令2的操作对象</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&amp;</td>\n<td style=\"text-align:left\">命令 &amp;</td>\n<td style=\"text-align:left\">后台执行：把命令放在后台执行</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&gt;</td>\n<td style=\"text-align:left\">命令1 &gt; file</td>\n<td style=\"text-align:left\">输出重定向：将命令1的结果输出到文件中，该文件原有内容会被删除</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&gt;&gt;</td>\n<td style=\"text-align:left\">命令1 &gt;&gt; file</td>\n<td style=\"text-align:left\">输出重定向：将命令1的结果附加到文件中，原文件内容不会被删除</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&lt;</td>\n<td style=\"text-align:left\">命令1 &lt; file</td>\n<td style=\"text-align:left\">输入重定向：将file作为命令1的输入</td>\n</tr>\n</tbody>\n</table>\n<p>一般情况下，每个 Unix/Linux 命令运行时都会打开三个文件：</p>\n<ul>\n<li>标准输入文件(stdin)：stdin的文件描述符为0，Unix程序默认从stdin读取数据。</li>\n<li>标准输出文件(stdout)：stdout 的文件描述符为1，Unix程序默认向stdout输出数据。</li>\n<li>标准错误文件(stderr)：stderr的文件描述符为2，Unix程序会向stderr流中写入错误信息。</li>\n</ul>\n<p>如果希望执行某个命令，但又不希望在屏幕上显示输出结果，那么可以将输出重定向到 <code>/dev/null</code>,以下是常用重定向命令示例：</p>\n<ul>\n<li>将 stderr 重定向到 file：<code>command 2&gt;file</code></li>\n<li>将 stderr 追加到 file 文件末尾：<code>command 2&gt;&gt;file</code>。</li>\n<li>将 stdout 和 stderr 合并后重定向到 file：<code>$ command &gt; file 2&gt;&amp;1</code></li>\n<li>对 stdin 和 stdout 都重定向：<code>command &lt; file1 &gt; file2</code></li>\n<li>屏蔽 stdout 和 stderr：<code>command &gt; /dev/null 2&gt;&amp;1</code></li>\n</ul>\n<blockquote>\n<p>**注意：**0 是标准输入（STDIN），1 是标准输出（STDOUT），2 是标准错误输出（STDERR）。这里的 <strong>2</strong> 和 <strong>&gt;</strong> 之间不可以有空格，<strong>2&gt;</strong> 是一体的时候才表示错误输出。</p>\n</blockquote>\n<h3 id=\"Bash中的特殊符号\">Bash中的特殊符号</h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">通配符</th>\n<th style=\"text-align:left\">作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">?</td>\n<td style=\"text-align:left\">匹配一个任意字符</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">*</td>\n<td style=\"text-align:left\">匹配0个或多个任意字符，也就是可以匹配任何内容</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">[]</td>\n<td style=\"text-align:left\">匹配括号中任意一个字符</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">[-]</td>\n<td style=\"text-align:left\">匹配括号中任意一个字符，“-”代表范围</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">[^]</td>\n<td style=\"text-align:left\">逻辑非，表示匹配不是括号内的一个字符</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">‘’</td>\n<td style=\"text-align:left\">单引号，在单引号中所有的特殊符号，如“$”和“`”（反引号）都无特殊含义 |</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">“”</td>\n<td style=\"text-align:left\">双引号，在双引号中特殊符号都无特殊含义， 但“$”、“`”（反引号）和“\\”是例外，拥有“调用变量值”,“引用命令”和“转义符”的特殊含义 |</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">“</td>\n<td style=\"text-align:left\">反引号：反引号括起来的内容是系统命令，在Bash中先会执行它和()</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$()</td>\n<td style=\"text-align:left\">和反引号作用相同，用来引用系统命令</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">#</td>\n<td style=\"text-align:left\">在shell脚本中,#开头的行代表注释</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$</td>\n<td style=\"text-align:left\">用于调用变量的值，如需要调用变量name的值时，需要用的 <code>$name</code> 方式得到</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">\\</td>\n<td style=\"text-align:left\">转义符，跟在\\之后的特殊字符将失去特殊含义，变为普通字符</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"基础命令\">基础命令</h2>\n<h3 id=\"查看系统基础信息\">查看系统基础信息</h3>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">$ ssh-copy-id -i ~&#x2F;.ssh&#x2F;id_rsa.pub root@192.168.0.22        # 免密登录\n$ cat &#x2F;etc&#x2F;redhat-release                                   # 查看CentOS版本\n$ lshw                                                      # 查看硬件详细信息\n$ cat &#x2F;proc&#x2F;cpuinfo| grep &quot;cpu cores&quot;| uniq  　             # 查看cpu核心数\n$ cat &#x2F;proc&#x2F;cpuinfo| grep &quot;physical id&quot;|uniq| wc -l         # 查看物理cpu个数\n$ cat &#x2F;proc&#x2F;cpuinfo | grep &quot;processor[[:space:]]:&quot;| wc -l   # 查看逻辑cpu的个数\n\n$ free -h 　                #查看内存大小</code></pre></div></figure>\n<h3 id=\"添加用户\">添加用户</h3>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\"># 添加用户 lxl80\n$ useradd lxl80 &amp;&amp; echo &quot;Lixl.cn&quot; | passwd --stdin lxl80 \n$ vi  &#x2F;etc&#x2F;sudoers\n## Allow root to run any commands anywhere\nroot    ALL&#x3D;(ALL)       ALL\n# 添加以下内容\nweixin  ALL&#x3D;(ALL) NOPASSWD: ALL\n\n$ vim &#x2F;etc&#x2F;ssh&#x2F;sshd_config    # 禁止root用户远程登录\nPermitRootLogin   no          # 生效要重启sshd进程。\n$ systemctl restart sshd</code></pre></div></figure>\n<h3 id=\"基础设置\">基础设置</h3>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">$ yum install -y wget               # 安装wget\n# 修改yum源\n$ cd &#x2F;etc&#x2F;yum.repos.d \n$ mv CentOS-Base.repo CentOS-Base.repo.bak\n$ wget -O .&#x2F;CentOS-Base.repo https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;repo&#x2F;Centos-7.repo\n$ yum clean all\n$ yum makecache\n\n$ yum update                        # 升级系统及相关软件\n# 安装必备软件\n$ yum install net-tools -y          # 安装常用网络工具\n$ yum install bash-completion -y    # 命令自动补全    \n$ echo -e &#39;set completion-ignore-case on&#39; &gt;&gt; ~&#x2F;.inputrc &amp;&amp; bind -f  ~&#x2F;.inputrc     # 命令补全忽略大小写\n\n$ yum install ntp                   # 与NTP服务器进行的同步\n$ systemctl start ntpd\n$ systemctl enable ntpd\n$ ntpdate -u  cn.ntp.org.cn         # 同步时间\n$ date                              # 检查时间\n\n$ yum -y install crontab            # 安装crontab\n$ crontab -e                        # 创建crontab任务\n# 每天2点同步一次，先通过 which ntpdate 查找命令所在路径\n$ * 2 * * * &#x2F;sbin&#x2F;ntpdate cn.ntp.org.cn &gt; &#x2F;dev&#x2F;null 2&gt;&amp;1   \n$ service crond reload              # 重启crontab</code></pre></div></figure>\n<h3 id=\"磁盘管理\">磁盘管理</h3>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\"># 以易读的方式查看磁盘占用情况\n$ df -Th\n$ lsblk 　　               # 查看分区和磁盘,列出所有可用块设备的信息\n$ fdisk -l                # 分区工具查看分区信息，查看所有被系统识别的磁盘\n$ fdisk &#x2F;dev&#x2F;sdb  　　     # 分区操作,n,p, , ,w\n\n# 格式化sdb1分区，挂载到&#x2F;home&#x2F;weixin，并开机启动自动挂载\n$ mkfs -t ext4 &#x2F;dev&#x2F;sdb1 &amp;&amp; mkdir &#x2F;weixin &amp;&amp; mount &#x2F;dev&#x2F;sdb1 &#x2F;weixin &amp;&amp; echo &#x2F;dev&#x2F;sdb1 &#x2F;weixin ext4 defaults 0 0 &gt;&gt; &#x2F;etc&#x2F;fstab\n$ chmod 700 &#x2F;weixin &amp;&amp; chown weixin:weixin &#x2F;weixin        # 更改目录权限及归属\n$ resize2fs &#x2F;dev&#x2F;sdb      # 扩展ext*磁盘分区文件系统的大小\n$ xfs_growfs &#x2F;dev&#x2F;sdb     # 扩展xfs磁盘分区文件系统的大小\n\n$ du -sh *                # 以易读的方式查看当前目录空间占用总计\n$ du -h --max-depth&#x3D;1     # 查看哪个文件夹或文件占用磁盘最多\n$ du -ch *.tar.gz         # 查看当前文件夹下所有后缀是 tar.gz 的文件的磁盘使用量总和 -c</code></pre></div></figure>\n<h3 id=\"查看网络情况\">查看网络情况</h3>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">$ semanage port -l|grep ssh                      # 查看 SELinux 开放给 ssh 使用的端口\n$ semanage port -a -t ssh_port_t -p tcp 12022    # 为 ssh 添加允许使用的端口12022\n$ vi &#x2F;etc&#x2F;ssh&#x2F;sshd_config                               # 查看&#x2F;修改 ssh 使用的端口\n$ vi &#x2F;etc&#x2F;hosts.allow                            # 如果ssh无法链接\nsshd: ALL            ##允许所有ip主机均能连接本机\n\n# 查看当前网络连接情况\n$ netstat -ant|awk &#39;&#x2F;^tcp&#x2F; &#123;++S[$NF]&#125; END &#123;for(a in S) print (a,S[a])&#125;&#39;  \n$ netstat -anlp | grep 1230                  # 查看端口监听\n\n$ systemctl status firewalld                 # 查看防火墙状态\n$ systemctl stop firewalld.service           # 停止防火墙\n$ systemctl disable firewalld.service        # 禁止防火墙开机启动\n$ firewall-cmd --zone&#x3D;public --permanent --add-port&#x3D;端口号&#x2F;tcp    # 新增开放端口\n$ firewall-cmd --zone&#x3D;public --permanent --remove-port&#x3D;端口号&#x2F;tcp # 移除开放端口\n$ firewall-cmd --zone&#x3D;public --list-ports    # 查看开放端口\n$ firewall-cmd --reload                                   # 刷新防火墙\n\n$ nc -lv 19301                          # 监听本机19301端口\n$ nc 192.168.0.18 19301                 # 连接特定端口\n$ telnet 192.168.0.18 19301                     # 尝试连接19302端口，ctrl+],q退出</code></pre></div></figure>\n<h3 id=\"上传下载文件\">上传下载文件</h3>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\"># 通过 sftp 上传下载文件\n$ sftp  -i ~&#x2F;Downloads&#x2F;newszxl.pem root@106.15.89.34     # 连接服务器\n$ get &#x2F;data&#x2F;chainmaker&#x2F;log&#x2F;*  .                    # 把log下所有日志下载到本地当前目录\n$ put crypto-config.zip &#x2F;data&#x2F;app&#x2F;chainmaker&#x2F;      # 把节点证书上传版到服务器\n\n# 通过 scp 远程传输文件\n$ scp -rp &#x2F;data&#x2F; root@192.168.1.3:&#x2F;data&#x2F;\n$ scp -rp root@192.168.1.3:&#x2F;data&#x2F; &#x2F;data&#x2F;\n\n# 通过 rsync 传输&#x2F;同步文件,排除&#x2F;data&#x2F;dir1&#x2F;目录下的所有文件，不排除dir1目录\n$ sudo yum install -y rsync\n$ rsync -av --exclude&#x3D;&#123;&#39;.*&#39;,&#39;dir1&#x2F;*&#39;&#125; &#x2F;data&#x2F; root@192.168.1.3:&#x2F;data&#x2F;</code></pre></div></figure>\n<h3 id=\"清除history\">清除history</h3>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">$ history -c                      # 清除所有历史记录\n$ vim ~&#x2F;.bash_history                       # 按需修改\n$ history -r                      # 重置文件里的内容到内存中，缓存修改</code></pre></div></figure>\n<h3 id=\"窗口管理\">窗口管理</h3>\n<p><a href=\"https://tmux.github.io/\">tmux</a> 是一个终端复用器，可以激活多个终端或窗口，每一个终端都可以访问、运行和控制各自的程序。tmux类似于screen，可以关闭窗口将程序放在后台运行，需要的时候再重新连接。常用快捷键如下：</p>\n<ul>\n<li><code>Ctrl+b %</code>：划分左右两个窗格。</li>\n<li><code>Ctrl+b &quot;</code>：划分上下两个窗格。</li>\n<li><code>Ctrl+b &lt;方向键&gt;</code>：光标切换到其他窗格。</li>\n<li><code>Ctrl+b x</code>：关闭当前窗格。</li>\n<li><code>Ctrl+b z</code>：当前窗格全屏显示，再使用一次会变回原来大小。</li>\n<li><code>Ctrl+b Ctrl+&lt;方向键&gt;</code>：按箭头方向调整窗格大小。</li>\n</ul>\n<h3 id=\"后台执行\">后台执行</h3>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-none\" data-start=\"1\"><code class=\"language-none\">$ command &amp;     # 命令末尾添加＆符号在后台运行\n$ command &gt; &#x2F;dev&#x2F;null 2&gt;&amp;1 &amp;   # 将stdout重定向到&#x2F;dev&#x2F;null，将stderr重定向到stdout\nctrl + z        # 将一个正在前台执行的命令放到后台，并且处于暂停状态。\n$ bg            # 将一个在后台暂停的命令继续执行。用bg %jobnumber 恢复运行\n$ fg            # 将后台任务切换到前台执行\n$ jobs -l       # 显示当前shell会话中所有已停止和后台进程的状态</code></pre></div></figure>\n<h2 id=\"性能测试\">性能测试</h2>\n<h3 id=\"磁盘测试\">磁盘测试</h3>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\"># 使用dd磁盘IO简易性能测试\n$ dd if&#x3D;&#x2F;dev&#x2F;zero of&#x3D;iotestr bs&#x3D;1024k count&#x3D;8k conv&#x3D;fsync   # 测试写性能\n$ dd if&#x3D;&#x2F;dev&#x2F;sda of&#x3D;&#x2F;dev&#x2F;null bs&#x3D;8k count&#x3D;1024k  # 测试读性能\n\n# 使用fio进行磁盘专业性能测试\n$ yum install fio -y\n# 测试随机写IOPS：\n$ fio -direct&#x3D;1 -iodepth&#x3D;64 -rw&#x3D;randwrite -ioengine&#x3D;libaio -bs&#x3D;4k -size&#x3D;8G -numjobs&#x3D;1 -runtime&#x3D;60 -group_reporting -filename&#x3D;iotest -name&#x3D;Rand_Write_IOPS_Test\n# 测试随机读IOPS：\n$ fio -direct&#x3D;1 -iodepth&#x3D;64 -rw&#x3D;randread -ioengine&#x3D;libaio -bs&#x3D;4k -size&#x3D;8G -numjobs&#x3D;1 -runtime&#x3D;60 -group_reporting -filename&#x3D;iotest -name&#x3D;Rand_Read_IOPS_Test\n# 测试写吞吐量：\n$ fio -direct&#x3D;1 -iodepth&#x3D;32 -rw&#x3D;write -ioengine&#x3D;libaio -bs&#x3D;1024k -size&#x3D;8G -numjobs&#x3D;1 -runtime&#x3D;60 -group_reporting -filename&#x3D;iotest -name&#x3D;Write_BandWidth_Test\n# 测试读吞吐量：\n$ fio -direct&#x3D;1 -iodepth&#x3D;32 -rw&#x3D;read -ioengine&#x3D;libaio -bs&#x3D;1024k -size&#x3D;8G -numjobs&#x3D;1 -runtime&#x3D;60 -group_reporting -filename&#x3D;iotest -name&#x3D;Read_BandWidth_Test</code></pre></div></figure>\n<p>延伸阅读：<a href=\"https://cloud.tencent.com/developer/article/1836176?from=15425\">磁盘性能压测—FIO</a></p>\n<h3 id=\"网络测试\">网络测试</h3>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\"># 网络测试（需要在需要测试的服务器上分别安装iperf）\n$ wget https:&#x2F;&#x2F;iperf.fr&#x2F;download&#x2F;source&#x2F;iperf-3.1.3-source.tar.gz\n$ tar zxvf iperf-3.1.3-source.tar.gz\n$ cd iperf-3.1.3\n$ .&#x2F;configure\n$ make \n$ make install\n# 服务器端测试命令，后台运行\n$ iperf3 -s -D -i 10 -p 19302 --logfile &#x2F;data&#x2F;iperf.log\n# 客户端测试命令，运行60秒,加参数R代表ServerToClient模式\n$ iperf3 -c 192.168.0.18 -t 60 -f M -P 1 -p 19302 --get-server-output\n$ iperf3 -c 192.168.0.18 -t 60 -f M -P 1 -R -p 19302 --get-server-output</code></pre></div></figure>\n<p>延伸阅读：<a href=\"https://docs.azure.cn/zh-cn/articles/azure-operations-guide/virtual-network/aog-virtual-network-iperf-bandwidth-test\">使用 iPerf 进行网络带宽测试</a>，<a href=\"https://www.tuicool.com/articles/emINv2v\">使用 MTR 诊断网络问题</a></p>\n<h2 id=\"系统监\">系统监</h2>\n<h3 id=\"dstat\">dstat</h3>\n<p>dstat 是一个可以取代vmstat，iostat，netstat和ifstat这些命令的多功能产品。使用dstat命令可以查看当前cpu，磁盘，网络，内存页和系统的一些当前状态指标。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-none\" data-start=\"1\"><code class=\"language-none\">$ yum install -y dstat\n$ dstat 5     # 5秒统计一次</code></pre></div></figure>\n<p>1、 –total-cpu-usage—- CPU使用率</p>\n<p>usr：用户空间的程序所占百分比；</p>\n<p>sys：系统空间程序所占百分比；</p>\n<p>idel：空闲百分比；</p>\n<p>wai：等待磁盘I/O所消耗的百分比；</p>\n<p>hiq：硬中断次数；</p>\n<p>siq：软中断次数；</p>\n<hr>\n<p>2、-dsk/total-磁盘统计</p>\n<p>read：读总数</p>\n<p>writ：写总数</p>\n<hr>\n<p>3、-net/total- 网络统计</p>\n<p>recv：网络收包总数</p>\n<p>send：网络发包总数</p>\n<hr>\n<p>4、—paging– 内存分页统计</p>\n<p>in： pagein（换入）</p>\n<p>out：page out（换出）</p>\n<p>注：系统的分页活动。分页指的是一种内存管理技术用于查找系统场景，一个较大的分页表明系统正在使用大量的交换空间，通常情况下当系统已经开始用交换空间的时候，就说明你的内存已经不够用了，或者说内存非常分散，理想情况下page in（换入）和page out（换出）的值是0 0。</p>\n<hr>\n<p>5、–system–系统信息</p>\n<p>int：中断次数</p>\n<p>csw：上下文切换</p>\n<p>注：中断（int）和上下文切换（csw）。这项统计仅在有比较基线时才有意义。这一栏中较高的统计值通常表示大量的进程造成拥塞，需要对CPU进行关注。你的服务器一般情况下都会运行运行一些程序，所以这项总是显示一些数值。</p>\n<h3 id=\"vmstat\">vmstat</h3>\n<p>vmstat是Virtual Meomory Statistics（虚拟内存统计）的缩写，可实时动态监视操作系统的虚拟内存、进程、CPU活动。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">$ vmstat -S m -t 3     # 3秒刷新一次，以M为单位</code></pre></div></figure>\n<ul>\n<li>r 表示运行队列,当这个值超过了CPU数目，就会出现CPU瓶颈了。</li>\n<li>b 正在等待资源的阻塞内核线程数，大于3表示io性能不好</li>\n<li>bi: 每秒读取的块数</li>\n<li>bo: 每秒写入的块数</li>\n<li>us: 用户进程执行时间(user time)</li>\n<li>sy: 系统进程执行时间(system time)</li>\n<li>id: 空闲时间(包括IO等待时间)</li>\n<li>wa: IO等待所占用的CPU时间的百分比，高过30%时IO压力高。</li>\n</ul>\n<h3 id=\"top\">top</h3>\n<p>top命令是Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况。提供了实时的对系统处理器的状态监视。它将显示系统中CPU最“敏感”的任务列表。该命令可以按CPU使用、内存使用和执行时间对任务进行排序；而且该命令的很多特性都可以通过交互式命令或者在个人定制文件中进行设定。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-none\" data-start=\"1\"><code class=\"language-none\">$ top -s # 在安全模式运行top</code></pre></div></figure>\n<ul>\n<li>Cpu(s) %id：空闲CPU时间百分比</li>\n<li>Cpu(s) %wa：等待I/O的CPU时间百分比</li>\n<li>VIRT：进程占用的虚拟内存，详情可参考: <a href=\"https://www.cnblogs.com/bravery/archive/2012/06/27/2560611.html\">观察进程的内存占用情况</a></li>\n<li>RES：进程占用的物理内存</li>\n<li>SHR：进程使用的共享内存</li>\n<li>i 只显示正在运行的进程</li>\n<li>e 切换内存单位，切换顺序为： k,m,g,t,p</li>\n<li>k 杀掉某进程</li>\n<li>o: COMMAND=chain 过滤进程，只显示启动命令带chain的进程</li>\n</ul>\n<h3 id=\"sysstat\">sysstat</h3>\n<p>一个非常方便的工具，它带有众多的系统资源监控工具，用于监控系统的性能和使用情况。我们在日常使用的工具中有相当一部分是来自sysstat工具包的。同时，它还提供了一种使用cron表达式来制定性能和活动数据的收集计划。以下是包含在sysstat包中的工具：</p>\n<ul>\n<li><a href=\"http://linux.cn/article-4024-1.html\"><strong>iostat</strong></a>: 输出CPU的统计信息和所有I/O设备的输入输出（I/O）统计信息。</li>\n<li><strong>mpstat</strong>: 关于CPU的详细信息（单独输出或者分组输出）。</li>\n<li><strong>pidstat</strong>: 关于运行中的进程/任务、CPU、内存等的统计信息。</li>\n<li><strong>sar</strong>: 保存并输出不同系统资源（CPU、内存、IO、网络、内核等）的详细信息。</li>\n<li><strong>sadc</strong>: 系统活动数据收集器，用于收集sar工具的后端数据。</li>\n<li><strong>sa1</strong>: 系统收集并存储sadc数据文件的二进制数据，与sadc工具配合使用</li>\n<li><strong>sa2</strong>: 配合sar工具使用，产生每日的摘要报告。</li>\n<li><strong>sadf</strong>: 用于以不同的数据格式（CVS或者XML）来格式化sar工具的输出。</li>\n<li><strong>Sysstat</strong>: sysstat工具的man帮助页面。</li>\n<li><strong>nfsiostat</strong>: NFS（Network File System）的I/O统计信息。</li>\n<li><strong>cifsiostat</strong>: CIFS(Common Internet File System)的统计信息。</li>\n</ul>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">$ yum install sysstat -y                         # 安装\n$ iostat 2 -mxt                                  # 监测IO，2秒刷新一次，以M为单位\n$ pidstat -u 1 10                                # 监测进程，1秒刷新一次</code></pre></div></figure>\n<ul>\n<li>%user：CPU处在用户模式下的时间百分比。</li>\n<li>%nice：CPU处在带NICE值的用户模式下的时间百分比。</li>\n<li>%system：CPU处在系统模式下的时间百分比。</li>\n<li>%iowait：CPU等待输入输出完成时间的百分比。</li>\n<li>%steal：管理程序维护另一个虚拟处理器时，虚拟CPU的无意识等待时间百分比。</li>\n<li>%idle：CPU空闲时间百分比。</li>\n<li>r/s: 每秒完成的读 I/O 设备次数。即 rio/s</li>\n<li>w/s: 每秒完成的写 I/O 设备次数。即 wio/s</li>\n<li>rMB/s: 每秒读M字节数。</li>\n<li>wMB/s: 每秒写K字节数。</li>\n<li>rrqm/s: 每秒进行 merge 的读操作数目。即 rmerge/s</li>\n<li>wrqm/s: 每秒进行 merge 的写操作数目。即 wmerge/s</li>\n<li>avgrq-sz：平均每次设备I/O操作的数据大小，类似于平均每人所买的东西多少</li>\n<li>avgqu-sz：平均I/O队列长度，类似于单位时间里平均排队人数，如果值比较大，表示有大量io在等待。</li>\n<li>await: 平均每次设备I/O操作的等待时间 (毫秒)，类似于平均每人的等待时间，如果远大于svctm说明IO响应太慢。</li>\n<li>r_await：平均每次读请求的等待时间(毫秒)。这包括请求在队列中和执行它们所花费的时间。</li>\n<li>w_await：平均每次写请求的等待时间(毫秒)。这包括请求在队列中和执行它们所花费的时间。</li>\n<li>aqu-sz：发送到设备的请求的平均队列长度。</li>\n</ul>\n<blockquote>\n<p>如果 %util 接近 100%，说明产生的I/O请求太多，I/O系统已经满负荷，该磁盘可能存在瓶颈，同时可以结合vmstat 查看b参数和wa参数。</p>\n<p>另外 await 的参数也要和 svctm 参考比较。差的过高就一定有 IO 的问题。svctm 一般要小于 await (因为同时等待的请求的等待时间被重复计算了)，svctm 的大小一般和磁盘性能有关，CPU/内存的负荷也会对其有影响，请求过多也会间接导致 svctm 的增加。await 的大小一般取决于服务时间(svctm) 以及 I/O 队列的长度和 I/O 请求的发出模式。如果 svctm 比较接近 await，说明 I/O 几乎没有等待时间；如果 await 远大于 svctm，说明 I/O 队列太长，应用得到的响应时间变慢。</p>\n<p>队列长度(avgqu-sz)也可作为衡量系统 I/O 负荷的指标，但由于 avgqu-sz 是按照单位时间的平均值，所以不能反映瞬间的 I/O 洪水。</p>\n<p>更详细的信息，可参考：<a href=\"https://bean-li.github.io/dive-into-iostat/\">深入理解iostat</a></p>\n</blockquote>\n<h3 id=\"iotop\">iotop</h3>\n<p><code>iotop</code> 是一个类似 <code>top</code> 的工具，用来显示实时的磁盘活动。监控 Linux 内核输出的 I/O 使用信息，并且显示一个系统中进程或线程的当前 I/O 使用情况。它显示每个进程/线程读写 I/O 带宽。它同样显示当等待换入和等待 I/O 的线程/进程花费的时间的百分比。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">$ yum install iotop\n$ iotop -o   # 仅显示正在占用I&#x2F;O的进程或者线程，可以随时按o切换\n$ iotop -oP   # 按进程显示</code></pre></div></figure>\n<ul>\n<li>\n<p><code>IO</code>：它显示每个进程的 I/O 利用率，包含磁盘和交换。</p>\n</li>\n<li>\n<p><code>SWAPIN</code>： 它只显示每个进程的交换使用率。</p>\n<p>更多信息可参考：<a href=\"https://cleanli.github.io/cleanhome/posts/2021-01-05/Iotop_usage.html\">https://cleanli.github.io/cleanhome/posts/2021-01-05/Iotop_usage.html</a></p>\n</li>\n</ul>\n<h2 id=\"性能调优\">性能调优</h2>\n<h3 id=\"分析进程调用\">分析进程调用</h3>\n<p>pstack用来跟踪进程栈，如果发现一个服务一直处于work状态（如假死），可以多执行几次pstack，若发现代码栈总是停在同一个位置，很可能就是出问题的地方：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">$ yum install gdb -y\n$ pstack pid  # 获取进程栈</code></pre></div></figure>\n<p>strace能够动态的跟踪进程执行时的系统调用和所接收的信号：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">$ yum install -y strace\n$ strace -ttTv o ~&#x2F;straceout.txt -p 21120 # 查看进程20020的系统调用情况</code></pre></div></figure>\n<h3 id=\"内核参数优化\">内核参数优化</h3>\n<p>对于服务器来说，file-max和ulimit都需要设置，否则会出现文件描述符耗尽的问题。否则会碰到”Too many open files”或者Socket/File: Can’t open so many files等错误。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\"># 查看用户进程级的能够打开文件句柄的数量，Centos7默认是1024。\n$ ulimit -a \n# 查看系统级别的能够打开的文件句柄的数量，Centos7默认是794168\n$ cat &#x2F;proc&#x2F;sys&#x2F;fs&#x2F;file-max\n# 永久生效的修改方法，文件末尾加入配置内容：\n$ vim &#x2F;etc&#x2F;sysctl.conf\nfs.file-max &#x3D; 2000000\n# 然后执行命令，使修改配置立即生效：\n$ sysctl -p\n# 查看当前shell的当前用户的打开的最大限制\n$ ulimit -n\n# 修改一个用户的所有shell能打开的最大数，文件末尾加入配置内容：\n$ vim &#x2F;etc&#x2F;security&#x2F;limits.conf\n* soft nofile 65535\n* hard nofile 65535\n# 修改以后，需要重新登录才能生效。如果需要设置当前用户session立即生效，还需要执行：\n$ ulimit -n 65535 </code></pre></div></figure>\n<h2 id=\"文本处理\">文本处理</h2>\n<h3 id=\"Vim常用命令\">Vim常用命令</h3>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">$ vi +&#x2F;pattern filename   # 打幵文件，并将光标置于第一个与pattern匹配的位置\n# u 撤销刚才执行的命令\n# I 在光标所在行的行首插入随后输入的文本，相当于光标移动到行首执行 i 命令\n# o&#x2F;O 在光标所在行的下面&#x2F;上面插入新的一行。光标停在空行首，等待输入文本\n# &#x2F;abc ?abc 从光标所在位置向前&#x2F;向后查找字符串 abc，如搜索空格加转义符\\\n# ?abc    从光标所在为主向后查找字符串 abc\n# &#x2F;^abc &#x2F;abc$    查找以 abc 为行首&#x2F;为行尾的行\n# n  N    向同一&#x2F;相反方向重复上次的查找指令\n# gg 跳转到第一行，G 跳转到最后一行\n# :s&#x2F;a1&#x2F;a2&#x2F;g    将当前光标所在行中的所有 a1 用 a2 替换\n# :n1,n2 s&#x2F;a1&#x2F;a2&#x2F;g    将文件中 n1 到 n2 行中所有 a1 都用 a2 替换\n# :%s&#x2F;a1&#x2F;a2&#x2F;g    将文件中所有的 a1 都用 a2 替换\n# x    删除光标所在位置的字符(放入剪贴板)\n# ndd    删除当前行（包括此行）后 n 行文本(放入剪贴板)\n# dG    删除光标所在行一直到文件末尾的所有内容(放入剪贴板)\n# D    删除光标位置到行尾的内容(放入剪贴板)\n# p(P)    将剪贴板中的内容粘贴到光标后(光标后)\n# 列编辑模式\n$ ctrl + v   # 进入列编辑模式,然后通过光标移动选择要编辑的块\n$ shift + i&#x2F;a        # 在光标前&#x2F;后插入，ESC自动补全\n$ shift + c   # 修改内容，ESC自动补全</code></pre></div></figure>\n<h3 id=\"文本处理-2\">文本处理</h3>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">$ grep &quot;put block&quot; logs -R -n               # 在多级目录中对文本递归搜索\n$ grep -e &quot;ERROR&quot; -e &quot;put block&quot; file # 匹配多个模式\n$ cat LOG.* | tr a-z A-Z | grep &quot;FROM &quot; | grep &quot;WHERE&quot; &gt; b    # 将日志中的所有带where条件的sql查找查找出来\n$ sort unsort.txt | uniq                             # 消除重复行\n$ sort unsort.txt | uniq -c                        # 统计各行在文件中出现的次数\n$ sort unsort.txt | uniq -d                        # 找出重复行\n$ echo 12345 | tr &#39;0-9&#39; &#39;9876543210&#39;     # 加解密转换，替换对应字符\n$ cat text| tr &#39;\\t&#39; &#39; &#39;                           # 制表符转空格\n$ cat file | tr -d &#39;0-9&#39;                          # 删除所有数字\n$ cat file | tr -c &#39;0-9&#39;                             # 获取文件中所有数字\n$ cat file | tr -d -c &#39;0-9 \\n&#39;                 # 删除非数字数据\n$ cut -f2,4 filename                                    # 截取文件的第2列和第4列\n$ paste file1 file2    -d &quot;,&quot;                        # 将两个文本按列拼接到一起,用,分割\n$ wc -l file                                                     # 统计行数\n$ wc -w file                                                     # 统计单词数\n$ wc -c file                                                     # 统计字符数\n$ sed &#39;s&#x2F;text&#x2F;replace_text&#x2F;&#39; file       # 替换每一行的第一处匹配的text\n$ sed &#39;s&#x2F;text&#x2F;replace_text&#x2F;g&#39; file        # 全局替换，输出替换后的内容\n$ sed -i &#39;s&#x2F;text&#x2F;replace_text&#x2F;g&#39; file    # 全局替换，直接替换源文件\n$ sed &#39;&#x2F;^$&#x2F;d&#39; file                                        # 移除空白行</code></pre></div></figure>\n<h3 id=\"awk-数据流处理\">awk 数据流处理</h3>\n<p><a href=\"https://en.wikipedia.org/wiki/AWK\"><code>awk</code></a>是文本处理程序，它依次处理文件的每一行，并读取里面的每一个字段。适用于处理日志、CSV 这种每行格式相同的文本文件。参考：<a href=\"https://www.ruanyifeng.com/blog/2018/11/awk.html\">Awk入门</a> 及 <a href=\"https://likegeeks.com/awk-command/\">30个Awk文本处理示例</a></p>\n<p>脚本结构: <code>awk 'BEGIN{statements} statements2 END{statements}'</code>，工作方式：</p>\n<ul>\n<li>执行begin中语句块；</li>\n<li>从文件或stdin中读入一行，然后执行statements2，重复这个过程，直到文件全部被读取完毕；</li>\n<li>执行end语句块；</li>\n</ul>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\"># 使用不带参数的print时，会打印当前行，输入内容如下：\n$ echo -e &quot;line1\\nline2&quot; | awk &#39;BEGIN&#123;print &quot;start&quot;&#125; &#123;print&#125; END&#123;print &quot;End&quot;&#125;&#39;    \nstart\nline1\nline2\nEnd\n$ awk &#39;&#123;print $0&#125;&#39; demo.txt        # 把demo.txt文件中每一行原样打印出来\n# 用空格分割，输出字段数&gt;30且第四列为特定字符的行中1，4及倒数第二列，第4列转成大写。&#39;,&#39;代表用空格分割\n$ awk -F &#39; &#39; &#39;NF&gt;3 &#123;if ($4 &#x3D; &quot;CONSENSUS&quot;) print $1,toupper($4),$(NF-1)&#125;&#39; panic.log</code></pre></div></figure>\n<h3 id=\"数字证书\">数字证书</h3>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">&#x2F;&#x2F; 查看证书信息\n$ openssl x509 -noout -text -in user&#x2F;admin1&#x2F;admin1.tls.crt\n$ openssl x509 -in cert.pem -noout -text</code></pre></div></figure>\n<h2 id=\"系统相关\">系统相关</h2>\n<h3 id=\"hostname-查看主机名\">hostname - 查看主机名</h3>\n<p><code>hostname</code>命令用于查看系统的主机名，或是修改系统的主机名。</p>\n<p><code>hostname</code>的常用命令如下：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\"># 显示系统的当前主机名\nhostname\n\n# 修改你系统的主机名\nhostname blinkfox-system\n\n# 使用 -F 选项，从指定的文件中读取主机名\nhostname -F &#x2F;root&#x2F;hostname.txt</code></pre></div></figure>\n<h3 id=\"uptime-查看系统运行时间\">uptime - 查看系统运行时间</h3>\n<p><code>uptime</code>命令用于打印系统的运行时间等信息。使用如下：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">uptime</code></pre></div></figure>\n<h3 id=\"w、who-列出登录的用户\">w、who - 列出登录的用户</h3>\n<p><code>w</code>命令用于显示登录用户及他们当前运行的进程。输入的内容格式如下：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">w\n\n# 打印如下\n22:42  up 18 days, 1 hr, 2 users, load averages: 1.23 1.79 1.75\nUSER     TTY      FROM              LOGIN@  IDLE WHAT\nblinkfox console  -                日19   6days -\nblinkfox s000     -                五23       - w</code></pre></div></figure>\n<p><code>who</code>命令有与<code>w</code>命令类似的用途，但它的功能比<code>w</code>命令更强大一些。语法格式如下：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">who [OPTION]... [FILE | ARG1 ARG2]</code></pre></div></figure>\n<p><code>who</code>常用命令如下：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\"># 显示当前登录的所有用户信息\nwho\n\n# 显示系统的启动时间\nwho -b\n\n# 显示系统登录进程\nwho -l\n\n# 显示与当前标准输入关联的用户信息\nwho -m\n\n# 显示系统的运行级别\nwho -r\n\n# 显示所有登录用户的用户名和登录用户数\nwho -q</code></pre></div></figure>\n<h3 id=\"uname-查看系统信息\">uname - 查看系统信息</h3>\n<p><code>uname</code>命令用于打印内核名称和版本、主机名等系统信息。命令的语法如下所示：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">uname [OPTION]...</code></pre></div></figure>\n<p>常用使用方式如下：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\"># 只打印内核的名称\nuname\n\n# 使用 -n 选项，只打印系统的主机名\nuname -n\n\n# 使用 -r 选项，打印内核版本信息\nuname -r\n\n# 使用 -m 选项，打印系统的硬件名称\nuname -m\n\n# 使用 -p 选项，打印系统的处理器类型信息\nuname -p\n\n# 使用 -i 选项，打印系统的硬件平台信息\nuname -i\n\n# 使用 -a 选项，打印上述所有示例中的信息\nuname -a</code></pre></div></figure>\n<h3 id=\"date-显示和设置系统日期和时间\">date - 显示和设置系统日期和时间</h3>\n<p><code>date</code>命令用于以多种格式显示日期和时间，或设置系统的日期和时间。<code>date</code>命令的语法如下所示：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">date [OPTION]... [+FORMAT]\ndate [-u|--utc|--universal] [MMDDhhmm[[CC]YY][.ss]]</code></pre></div></figure>\n<p>常用使用命令如下：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\"># 以默认格式显示系统的当前日期时间\ndate\n\n# 格式化当前日期\ndate +&quot;%Y-%m-%d&quot;\n\n# 格式化输出昨天的日期\ndate -d &quot;1 day ago&quot; +&quot;%Y-%m-%d&quot;\n\n# 2秒后格式化输出\ndate -d &quot;2 second&quot; +&quot;%Y-%m-%d %H:%M.%S&quot;\n\n# 普通格式化转出\ndate -d &quot;2009-12-12&quot; +&quot;%Y&#x2F;%m&#x2F;%d %H:%M.%S&quot;\n\n# apache格式转换\ndate -d &quot;Dec 5, 2009 12:00:37 AM&quot; +&quot;%Y-%m-%d %H:%M.%S&quot;\n\n# 日期加减操作\ndate +%Y%m%d #显示前天年月日\ndate -d &quot;+1 day&quot; +%Y%m%d #显示前一天的日期\ndate -d &quot;-1 day&quot; +%Y%m%d #显示后一天的日期\ndate -d &quot;-1 month&quot; +%Y%m%d #显示上一月的日期\ndate -d &quot;+1 month&quot; +%Y%m%d #显示下一月的日期\ndate -d &quot;-1 year&quot; +%Y%m%d #显示前一年的日期\ndate -d &quot;+1 year&quot; +%Y%m%d #显示下一年的日期\n\n# 设定时间\ndate -s # 设置当前时间，只有root权限才能设置，其他只能查看\ndate -s 20160816 # 设置成20160816，这样会把具体时间设置成空00:00:00\ndate -s 01:01:01 # 设置具体时间，不会对日期做更改\ndate -s &quot;01:01:01 2012-05-23&quot; # 这样可以设置全部时间\ndate -s &quot;01:01:01 20120523&quot; # 这样可以设置全部时间\ndate -s &quot;2012-05-23 01:01:01&quot; # 这样可以设置全部时间\ndate -s &quot;20120523 01:01:01&quot; # 这样可以设置全部时间</code></pre></div></figure>\n<h3 id=\"id-显示用户属性\">id - 显示用户属性</h3>\n<p><code>id</code>命令用于打印输出用户<code>uid</code>、<code>gid</code>、用户名和组名等用户身份信息。<code>id</code>命令的语法如下所示：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">id [OPTION]... [USERNAME]</code></pre></div></figure>\n<p>常见使用命令如下：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\"># 输出当前用户的uid、用户名、gid、组名及用户属于的群组信息\nid\n\n# 使用 -u 选项，输出用户的 uid\nid -u\n\n#-u 选项和 -n 选项结合使用，输出账户的用户名\nid -un\n\n# 使用 -g 选项，输出帐号当前起作用的gid\nid -g\n\n# -g 与 -n 选项结合使用，输出帐号当前起作用的用户组名\nid -gn\n\n# 使用 -G 选项，输出帐号所属的所有群组id\nid -G root\n\n# -G 与 -n 选项结合使用，输出账号所属的所有群组的名称\nid -Gn root</code></pre></div></figure>\n<h2 id=\"文件和目录操作\">文件和目录操作</h2>\n<h3 id=\"touch-创建文件\">touch - 创建文件</h3>\n<p><code>touch</code>命令就可用于创建、变更和修改文件的时间戳。它是 Linux 操作系统的标准程序。<code>touch</code>命令又如下选项：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">-a: 只改变访问时间\n-c: 不创建任何文件\n-m: 只改变修改时间\n-r: 使用指定文件的时间替代当前时间\n-t: 使用 [[CC]YY]MMDDhhmm[.ss] 替代当前时间</code></pre></div></figure>\n<p>touch 命令的常见用法如下：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\"># 创建一个名为 effyl 的新空文件\ntouch effyl\n\n# 同时创建名称分别为 effyl myeffyl lueffyl 的三个文件\ntouch effyl myeffyl lueffyl\n\n# 使用 -a 选项，可以改变或更新文件的最新访问时间，如果文件 effyl 不存在，则新创建一个\ntouch -a effyl\n\n# 使用 -c 选项，可以避免创建一个新文件，并用当前时间更新文件的时间戳\ntouch -c effyl\n\n# 使用 -m 选项，可以只改变文件的修改时间，而访问时间不变\ntouch -m effyl\n\n# 使用 -c 和 -t 选项，来明确设置文件的时间\ntouch -c -t YYMMDDHHMM filename\n\n# 如果想使用文件 myeffyl 的时间戳更新文件 effyl 的时间戳，可以使用 -r 选项\ntouch -r myeffyl effyl</code></pre></div></figure>\n<h3 id=\"mkdir-创建目录\">mkdir - 创建目录</h3>\n<p><code>mkdir</code>命令用于创建一个新目录。最基本的<code>mkdir</code>命令的使用方法如下所示：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\"># 在当前目录下创建一个给定的目录名\nmkdir &lt;dirname&gt;\n\n# 在 backup 中的相对路径创建一个名为 old 的目录\nmkdir backup&#x2F;old\n\n# 在 backup 中的绝对路径中创建一个名为 old 的目录\nmkdir &#x2F;home&#x2F;blinkfox&#x2F;backup&#x2F;old\n\n# 使用 -p 选项，会自动创建所有还不存在的父目录\nmkdir -p backup&#x2F;old\n\n# 使用 -m 选项，可以设置将要创建目录的权限\n# 如：创建一个任何人都有读写访问权限的目录\nmkdir -p -m 777 backup&#x2F;old</code></pre></div></figure>\n<h3 id=\"cp-复制文件或目录\">cp - 复制文件或目录</h3>\n<p><code>cp</code>命令用于将文件从一个地方复制到另一个地方。原来的文件保持不变，新文件可能保持原名或用一个不同的名字。</p>\n<p>使用 cp 命令复制文件和目录的语法有以下几种：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\"># 复制源文件到目标文件\ncp [OPTION] SOURCE DEST\n\n# 复制一个或多个源文件到一个目录\ncp [OPTION] SOURCE... DIRECTORY\n\n# 同上\ncp [OPTION] -t DIRECTORY SOURCE...</code></pre></div></figure>\n<p>常用使用示例如下：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\"># 在当前目录下，创建一个文件 file.txt 的副本，取名为 newfile.txt\ncp file.txt newfile.txt\n\n# 复制当前目录下的 file.txt 文件到 &#x2F;tmp 目录下\ncp file.txt &#x2F;tmp\n\n# 复制当前目录下的所有文件到 &#x2F;tmp 目录下\ncp * &#x2F;tmp\n\n# 使用 -p 选项，可以使复制一个文件到新文件时，保留源文件的所有者、权限等信息\ncp -p filename &#x2F;path&#x2F;to&#x2F;new&#x2F;location&#x2F;myfile\n\n# 使用 -R 或 -r 选项，恶意递归地复制一个目录\n# 即将一个目录及其下的所有文件和子目录都复制到另一个目录\ncp -R * &#x2F;home&#x2F;blinkfox&#x2F;backup</code></pre></div></figure>\n<h3 id=\"ln-链接文件或目录\">ln - 链接文件或目录</h3>\n<p><code>ln</code>命令用于创建软链接或硬链接。使用 -s 选项，可以创建一个软链接：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\"># 在目录 lib 下创建一个软链接 library.so，链接到 &#x2F;home&#x2F;blinkfox&#x2F;src&#x2F;library.so\nln -s &#x2F;home&#x2F;blinkfox&#x2F;src&#x2F;library.so &#x2F;home&#x2F;blinkfox&#x2F;lib\n\n# 创建目录的软链接\nln -s &#x2F;home&#x2F;blinkfox&#x2F;src source</code></pre></div></figure>\n<h3 id=\"mv-移动文件或目录\">mv - 移动文件或目录</h3>\n<p><code>mv</code>命令用于将文件和目录从一个位置移到另外一个位置。除了移动文件，<code>mv</code>命令还可用于修改文件或目录的名字。</p>\n<p>mv 命令的基本语法如下所示：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">mv SOURCE... DIRECTORY</code></pre></div></figure>\n<p>常用命令如下：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\"># 将当前目录下的文件 source.txt 移到目录 &#x2F;tmp 下\nmv source.txt &#x2F;tmp\n\n# 将目录 dir1、dir2 移到目录 dir_dist 下\nmv dir1 dir2 dir_dist\n\n# 将当前目录下的 old.txt 文件更名为 new.txt\nmv old.txt new.txt\n\n# 使用 -i 选项，在重写覆盖目标文件或目录之前给出提示信息\nmv -i old.txt new.txt\n\n# 将当前目录下的所有文件移动到目录 &#x2F;tmp 下\nmv * &#x2F;tmp&#x2F;\n\n# 使用 -i 选项，从 dir1 中移动那些在目标目录中不存在的文件到目标目录\nmv -u dir1&#x2F;* dir2&#x2F;</code></pre></div></figure>\n<h3 id=\"rm-删除文件或目录\">rm - 删除文件或目录</h3>\n<p><code>rm</code>命令用于删除指定的文件和目录。其语法如下所示：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">rm [OPTIONS]... FILE...</code></pre></div></figure>\n<p><code>rm</code>的常用命令如下：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\"># 删除当前目录下的文件 file1.txt、file2.txt、file3.txt\nrm file1.txt file2.txt file3.txt\n\n# 删除当前目录下的所有文件\nrm *\n\n# 删除你当前帐号主目录下的 temp 目录中的所有文件\nrm ~&#x2F;temp&#x2F;*\n\n# 使用 -i 选项，可以在删除每个文件或目录前提示用户确认\nrm -i *\n\n# 删除当前目录下所有以&quot;.doc&quot;结尾的文件\nrm *.doc\n\n# 删除当前目录下所有文件名中包含&quot;movie&quot;字符串的文件\nrm *movie*\n\n# 删除当前目录下所有以&quot;a&quot;开头的文件\nrm a*\n\n# 删除当前目录下整个文件名（包括扩展名）只有 3 个字符的所有文件\nrm ???\n\n# 删除当前目录下文件扩展名有两个字符的所有文件\nrm *.??\n\n# 删除当前目录下文件名中含有字母 a 或 b 或 c 的所有文件\nrm *[abc]*\n\n# 删除当前目录下文件名中包含 0~9 的所有文件\nrm *[0-9]*\n\n# 删除当前目录下文件扩展名是字母 c 或 h 的所有文件\nrm *.[ch]\n\n# 删除 &#x2F;tmp 目录下的所有文件及其子目录\nrm -rf &#x2F;tmp&#x2F;*</code></pre></div></figure>\n<blockquote>\n<ul>\n<li>-f 删除前不提示用户确认，并忽略不存在的文件</li>\n<li>-r 递归地删除目录及其下的内容</li>\n</ul>\n</blockquote>\n<h3 id=\"ls-列出文件名和目录\">ls - 列出文件名和目录</h3>\n<p><code>ls</code>命令是<code>Linux</code>中最常用的命令之一，其作用就是列出文件名和目录。在命令行提示符下，直接输入<code>ls</code>命令，不带任何选项，将列出当前目录下所有文件和目录，但不会显示详细的信息，比如，文件类型、大小、修改日期和时间、权限等。</p>\n<p>以下便是<code>ls</code>命令及其选项的作用说明：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\"># 仅列出当前目录下所有文件和目录\nls\n\n# 每行显示一条记录，每条记录包括文件类型、大小、修改日期和时间、权限等\nls -l\n\n# 将文件大小显示符合人类阅读习惯的格式\nls -lh\n\n# 将使用不同的特殊字符归类不同的文件类型\nls -F\n\n# 以长列表格式列出某个目录的信息\nls -ld &#x2F;var&#x2F;log\n\n# 将递归地列出子目录的内容\nls -R &#x2F;etc&#x2F;sysconfig&#x2F;\n\n# 以长列表格式按文件或目录的修改时间倒序地列出文件和目录\nls -ltr\n\n# 以长列表格式按文件大小顺序列出文件和目录\nls -ls\n\n# 列出包括隐藏文件或目录在内的所有文件和目录，包括“.”（当前目录）和“..”（父目录）\nls -a\n\n# 列出包括隐藏文件或目录在内的所有文件和目录，不包括“.”（当前目录）和“..”（父目录）\nls -A\n\n输出的内容类似于-l选项，指示显示uid和gid，替代显示所有者和用户组\nls -n</code></pre></div></figure>\n<h3 id=\"cat-连接显示文件内容\">cat - 连接显示文件内容</h3>\n<p><code>cat</code> 命令也是 Linux 系统中最常用的命令之一。<code>cat</code>命令让我们可以看看文件的内容、连接文件、创建一个或多个文件和重定向输出到终端或文件。</p>\n<p><code>cat</code>命令的语法如下所示：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">cat [OPTION] [FILE]...</code></pre></div></figure>\n<p><code>cat</code>常用命令如下：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\"># 使用 cat 命令查看文件 &#x2F;etc&#x2F;group 的内容\ncat &#x2F;etc&#x2F;group\n\n# 显示多个文件的内容\ncat &#x2F;etc&#x2F;redhat-release &#x2F;etc&#x2F;issue\n\n# -n 选项，可以显示文件内容的行号\ncat -n &#x2F;etc&#x2F;fstab\n\n# -b 选项和 -n 选项类似，但只标识非空白行的行号\ncat -b &#x2F;etc&#x2F;fstab\n\n# -e 选项，将在每一行的结尾显示“$”字符\ncat -e &#x2F;etc&#x2F;fstab</code></pre></div></figure>\n<blockquote>\n<p>当你只输入 cat 命令，而没有任何参数时，它只是接收标准输入的内容并在标准输出中显示。所以你在输入一行内容并回车后，会在接下来的一行显示相同的内容。你也可以重定向标准输出到一个新文件。</p>\n<p>dd</p>\n</blockquote>\n<h3 id=\"less、more-分屏显示文件\">less、more - 分屏显示文件</h3>\n<p><code>more</code>命令在你使用小的 xterm 窗口时，或是想不使用文本编辑器而只是简单地阅读一个文件时是很有用的。more 命令是一个用于一次翻阅一整屏文件的过滤器。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\"># 查看一个文件，自动清空屏幕并显示文件开头部分\nmore &#x2F;etc&#x2F;inittab\n\n# 指定一次显示num行\nmore -num &#x2F;etc&#x2F;inittab</code></pre></div></figure>\n<p>与<code>more</code>命令相比，我个人更喜欢<code>less</code>命令来查看文件。<code>less</code>命令与<code>more</code>命令类似，但<code>less</code>命令向前和向后翻页都支持，而且<code>less</code>命令不需要在查看前加载整个文件，即<code>less</code>命令查看文件更快速。</p>\n<p><code>less</code>常用命令参数如下：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">-b  &lt;缓冲区大小&gt; 设置缓冲区的大小\n-e  当文件显示结束后，自动离开\n-f  强迫打开特殊文件，例如外围设备代号、目录和二进制文件\n-g  只标志最后搜索的关键词\n-i  忽略搜索时的大小写\n-m  显示类似more命令的百分比\n-N  显示每行的行号\n-o  &lt;文件名&gt; 将less 输出的内容在指定文件中保存起来\n-Q  不使用警告音\n-s  显示连续空行为一行\n-S  行过长时间将超出部分舍弃\n-x  &lt;数字&gt; 将“tab”键显示为规定的数字空格\n&#x2F;字符串：向下搜索“字符串”的功能\n?字符串：向上搜索“字符串”的功能\nn： 重复前一个搜索（与 &#x2F; 或 ? 有关）\nN： 反向重复前一个搜索（与 &#x2F; 或 ? 有关）\nb  向后翻一页\nd  向后翻半页\nh  显示帮助界面\nQ  退出less 命令\nu  向前滚动半页\ny  向前滚动一行\n空格键 滚动一行\n回车键 滚动一页\n[pagedown]： 向下翻动一页\n[pageup]：   向上翻动一页</code></pre></div></figure>\n<h3 id=\"head-显示文件头部\">head - 显示文件头部</h3>\n<p><code>head</code>命令用于打印指定输入的开头部分内容。默认情况下，打印每个指定输入的前 10 行内容。</p>\n<p>使用<code>-n</code>选项可以指定打印文件的前 N 行：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\"># 指定打印文件的前5行\nhead -n 5 &#x2F;etc&#x2F;inittab\n（或）head -5 &#x2F;etc&#x2F;inittab\n\n# 打印文件的前N个字节的数据\nhead -c 10 &#x2F;etc&#x2F;inittab</code></pre></div></figure>\n<h3 id=\"tail-显示文件尾部\">tail - 显示文件尾部</h3>\n<p><code>tail</code>命令和<code>head</code>命令相反，它打印指定输入的结尾部分的内容。默认情况下，它打印指定输入的最后 10 行内容。</p>\n<p>使用<code>-n</code>选项可以指定打印文件的最后 N 行：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\"># 指定打印文件的后10行\ntail -n 10 &#x2F;etc&#x2F;inittab\ntail -10 &#x2F;etc&#x2F;inittab\n\n# 即时打印文件中新写入的行\ntail -f &#x2F;var&#x2F;log&#x2F;messages\n\n# --retry选项表示持续尝试打开某个文件，当你想打开一个稍后才会创建或即使不可用的文件\ntail -f &#x2F;tmp&#x2F;debug.log --retry</code></pre></div></figure>\n<h3 id=\"file-查看文件类型\">file - 查看文件类型</h3>\n<p><code>file</code>命令用于接收一个文件作为参数并执行某些测试，已确定正确的文件类型。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\"># 查看文件类型\nfile &#x2F;etc&#x2F;inittab\n\n# 可以MIME类型的格式显示文件类型的信息\nfile -i  &#x2F;etc&#x2F;inittab\n\n# 使用-N 选项，输出的队列可以以在文件名之后无空白填充的形式显示\nfile -N *</code></pre></div></figure>\n<h3 id=\"wc-查看文件统计信息\">wc - 查看文件统计信息</h3>\n<p><code>wc</code>命令用于查看文件的行数、单词数和字符数等信息。语法类似如下所示：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">wc filename\nX Y Z &#x2F;etc&#x2F;inittab</code></pre></div></figure>\n<p>其中 X 表示行数，Y 表示单词数，Z 表示字节数，filename 表示文件名。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\"># -l选项，可以只统计文件的行数信息\nwc -l &#x2F;etc&#x2F;inittab\n\n# -w选项，可以只统计文件的单词数信息\nwc -w &#x2F;etc&#x2F;inittab\n\n# -c选项，可以只统计文件的字节数信息\nwc -c &#x2F;etc&#x2F;inittab\n\n# -L选项，可以只统计文件中最长的行的长度\nwc -L &#x2F;etc&#x2F;inittab</code></pre></div></figure>\n<h3 id=\"find-查找文件或目录\">find - 查找文件或目录</h3>\n<p><code>find</code>命令用于根据你指定的参数搜索和定位文件和目录的列表。<code>find</code>命令可以在多种情况下使用，比如你可以通过权限、用户、用户组、文件类型、日期、大小和其他可能的条件来查找文件。</p>\n<p><code>find</code>命令常用使用和说明如下：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\"># 查找指定目录下的某个文件\nfind &#x2F;etc&#x2F; -name inittab\n\n# 在当前目录下查找名称为 inittab 的文件\nfind . -name inittab\n\n# 在当前目录下，文件不区分大小写是example的所有文件\nfind . -iname example\n\n# 找出当前目录下所有以 sh 结尾的文件\nfind . -type f -name &quot;*.sh&quot;\n\n# 找出当前目录下，文件权限是 777 的所有文件\nfind . -type f -perm 777\n\n# 找出当前目录下，文件权限不是 777 的所有文件\nfind . -type f ! -perm 777\n\n# 找出当前目录下所有只读文件\nfind . -type f ! -perm &#x2F;a+w\n\n# 找出你帐号主目录下的所有可执行文件\nfind ~ -type f -perm &#x2F;a+w\n\n# 找出 &#x2F;tmp 目录下的.log文件并将其删除：\nfind &#x2F;tmp&#x2F; -type f -name &quot;*.log&quot; -exec rm -f &#123;&#125; \\;\n\n# 找出当前目录下的所有空文件\nfind . -type f -empty\n\n# 找出当前目录下的所有空目录\nfind . -type d -empty\n\n# 找出 &#x2F;tmp 目录下的所有隐藏文件\nfind &#x2F;tmp&#x2F; -type f -name &quot;.*&quot;\n\n# 找出 &#x2F;tmp 目录下，所有者是 root 的文件和目录\nfind &#x2F;tmp&#x2F; -user root\n\n# 找出 &#x2F;tmp 目录下，用户组是 developer 的文件和目录\nfind &#x2F;tmp&#x2F; -group root\n\n# 找出你账号的主目录下，3 天前修改的文件\nfind ~ -type f -mtime 3\n\n# 找出你账号的主目录下，30 天以前修改的所有文件\nfind ~ -type f -mtime +30\n\n# 找出你账号的主目录下，3 天以内修改的所有文件\nfind ~ -type f -mtime -3\n\n# 找出你账号的主目录下，30 天以前，60 天以内修改的所有文件\nfind ~ -type f -mtime +30 -mtime -60\n\n# 找出 &#x2F;etc 目录下，一小时以内变更过的文件\nfind &#x2F;etc -type f -cmin -60\n\n# 找出 &#x2F;etc 目录下，一小时以内访问过的文件\nfind &#x2F;etc -type f -amin -60\n\n# 找出你账号主目录下，大小是50MB的所有文件\nfind ~ -type f -size 50MB\n\n# 找出你账号主目录下，大于50MB小于100MB的所有文件\nfind ~ -type f -size +50MB -size -100MB\n\n# 找出你账号主目录下，大于100MB的文件并将其删除\nfind ~ -type f -size +100MB -exec rm -rf &#123;&#125; \\;</code></pre></div></figure>\n<h2 id=\"文本处理-3\">文本处理</h2>\n<h3 id=\"sort-文本排序\">sort - 文本排序</h3>\n<p><code>sort</code>命令用于将文本文件的行排序。默认情况下，<code>sort</code>命令是按照字符串的字母顺序排序。</p>\n<p>sort 的常用命令如下：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\"># 将文本内容按字母顺序排序\nsort example.txt\n\n# 使用 -u 选项，移除所有重复行后排序\nsort -u example.txt\n\n# 使用 -n 选项，将令数字按数值的大小排序\nsort -n example.txt\n\n# 使用 -r 选项，以倒序方式排序\nsort -n -r example.txt\n\n# 同时将 file1、file2 的内容排序\nsort file1 file2</code></pre></div></figure>\n<h3 id=\"uniq-文本去重\">uniq - 文本去重</h3>\n<p><code>uniq</code>命令用于移除或发现文件中重复的条目。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\"># 它将移除文件中重复的行并显示单一行\nuniq example.txt\n\n# 可以统计重复行出现的次数\nuniq -c example.txt\n\n# 使用 -d 选项，只显示文件中有重复的行并只显示一次\nuniq -d example.txt\n\n# 使用 -D 选项，显示文件中所有重复的行\nuniq -D example.txt\n\n# 使用 -u 选项，只显示文件中不重复的行\nuniq -u example.txt\n\n# 使用 -w 选项，限制 uniq 命令只比较每行的前 3 个字符是否重复\nuniq -w 3 example.txt\n\n# 使用 -s 选项，避免 uniq 命令比较每行的前 3 个字符，只比较后面的字符是否重复\nuniq -s 3 example.txt\n\n# 使用 -f 选项，避免 uniq 命令比较第一列的内容，只比较后面的字符是否重复\nuniq -f 1 example.txt</code></pre></div></figure>\n<h3 id=\"tr-替换或删除字符\">tr - 替换或删除字符</h3>\n<p><code>tr</code>命令主要用于删除文件中控制字符或进行字符转换。使用<code>tr</code>时要转换两个字符串：字符串 1 用于查询，字符串 2 用于处理各种转换。<code>tr</code>刚执行时，字符串 1 中的字符被映射到字符串 2 中的字符，然后转换操作开始。</p>\n<p><code>tr</code>命令的语法如下所示：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">tr [OPTION]... SET1 [SET2]</code></pre></div></figure>\n<p>常用命令示例：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\"># 若要将大括号转换为小括号\ntr &#39;&#123;&#125;&#39; &#39;()&#39; &lt; textfile &gt; newfile\n\n# 若要将大括号转换成方括号\ntr &#39;&#123;&#125;&#39; &#39;\\[]&#39; &lt; textfile &gt; newfile\n\n# 若要将小写字符转换成大写，请输入：\ntr &#39;a-z&#39; &#39;A-Z&#39; &lt; textfile &gt; newfile\n\n# 若要创建一个文件中的单词列表\ntr -cs &#39;[:lower:][:upper:]&#39; &#39;[\\n*]&#39; &lt; textfile &gt; newfile\n\n# 若要从某个文件中删除所有空字符\ntr -d &#39;\\0&#39; &lt; textfile &gt; newfile\n\n# 若要用单独的换行替换每一序列的一个或多个换行，请输入：\ntr -s &#39;\\n&#39; &lt; textfile &gt; newfile\n\n# 要以单个“#”字符替换 &lt;space&gt; 字符类中的每个字符序列\ntr -s &#39;[:space:]&#39; &#39;[#*]&#39;</code></pre></div></figure>\n<h3 id=\"grep-查找字符串\">grep - 查找字符串</h3>\n<p><code>grep</code>命令用于搜索文本或指定的文件中与指定的字符串或模式相匹配的行。默认情况下，<code>grep</code>命令只显示匹配的行。</p>\n<p><code>grep</code>命令的语法如下所示：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">grep [OPTION]... PATTERN [FILE]...\ngrep [OPTION]... [-e PATTERN | -f FILE] [FILE]...</code></pre></div></figure>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\"># &#96;grep&#96;命令查找文件&#x2F;etc&#x2F;passwd 中帐号 blinkfox 的信息\ngrep blinkfox &#x2F;etc&#x2F;passwd\n\n# 使用 -i 选项，强制 grep 命令忽略搜索关键字的大小写\ngrep -i blinkfox &#x2F;etc&#x2F;passwd\n\n# 使用 -r 选项，可以递归搜索指定目录下的所有文件\ngrep -r blinkfox &#x2F;etc&#x2F;\n\n# 使用 -w 选项，只匹配包含指定单词的行\ngrep -w blinkfox &#x2F;etc&#x2F;\n\n# 使用 -c 选项，报告文件或文本中模式被匹配的次数\ngrep -c blinkfox &#x2F;etc&#x2F;passwd\n\n# 使用 -n 选项，显示每一个匹配的行的行号\ngrep -n blinkfox &#x2F;etc&#x2F;passwd\n\n# 使用 -v 选项，可以输出除匹配指定模式的行以外的其他所有行\ngrep -v blinkfox &#x2F;etc&#x2F;passwd\n\n# 使用 --color 选项，在输出中将匹配的字符串以彩色的形式标出\ngrep --color blinkfox &#x2F;etc&#x2F;passwd</code></pre></div></figure>\n<h3 id=\"diff-比较两个文件\">diff - 比较两个文件</h3>\n<p><code>diff</code>命令用于比较两个文件，并找出它们之间的不同。<code>diff</code>命令的语法如下所示：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">diff [OPTION]... from-file to-file</code></pre></div></figure>\n<p>常用使用方式如下：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\"># 比较两个文件\ndiff nsswitch.conf nsswitch.conf.org\n\n# 使用 -w 选项，比较时忽略空格\ndiff -w nsswitch.conf nsswitch.conf.org\n\n# 使用 -y 选项，以并排的格式输出两个文件的比较结果\ndiff -y nsswitch.conf nsswitch.conf.org\n\n使用 -c 选项，以上下对比的格式输出两个文件的比较结果\ndiff -c nsswitch.conf nsswitch.conf.org</code></pre></div></figure>\n<h2 id=\"Linux-和UNIX-的新手培训教程\">Linux 和UNIX 的新手培训教程</h2>\n<h3 id=\"免费的新手Linux教程\">免费的新手Linux教程</h3>\n<ul>\n<li><a href=\"http://www.ibm.com/developerworks/linux/newto/\">Introduction to Linux</a> – 这是来自IBM的教程，用于给那些想学习Linux的人。</li>\n<li><a href=\"http://linux.about.com/c/ec/1.htm\">Linux Desktop 101</a> – 这是一个 14周 课时的教程，主要用于学校里教学生如何在一个PC上运行一个Linux操作系统。</li>\n<li><a href=\"http://tldp.org/LDP/intro-linux/html/index.html\">Hands-On Introduction to Linux</a> – Machtelt Garrels 的一个格式相当不错的教程。</li>\n<li><a href=\"http://www.isd.mel.nist.gov/projects/rtlinux/rtutorial-2.0/doc/tutorial.htm\">Real Time Linux Introduction</a> – 一系列的介绍Linux的教程，来自National Institute of Standards and Technology.</li>\n<li><a href=\"http://www.linux.org/lessons/beginner/index.html\">Getting Started with Linux</a> – 来自Linux Online 的20课时的用于新手的教程。</li>\n<li><a href=\"http://learnlinux.tsf.org.za/courses/web-fundamentals.html\">Linux Fundamentals Course</a> – 一个相当不错的基础教程，大约使用18个小时，让你知道Linux操作系统的最基础的知识。</li>\n<li><a href=\"http://www.beginlinux.org/course/view.php?id=15\">The 35-Command Tutorial</a> – <a href=\"http://xn--BeginLinux-vs0vy28v.org\">来自BeginLinux.org</a> 的一个最简单的教程，教你使用 35 个Linux用户必需了解的命令。</li>\n<li><a href=\"http://ocw.novell.com/novell-linux-desktop/getting-started-with-novell-linux-desktop\">Getting Started with Linux Desktop</a> – Novell的自学教程。</li>\n</ul>\n<h3 id=\"免费的UNIX-新手教程\">免费的UNIX 新手教程</h3>\n<ul>\n<li><a href=\"http://www.ee.surrey.ac.uk/Teaching/Unix/\">UNIX Tutorial for Beginners</a> – 来自The University of Surrey的新手指南，告诉你Unix系统最基本的特性。</li>\n<li><a href=\"http://snap.nlc.dcccd.edu/learn/idaho/unixindex.html\">A Basic UNIX Tutorial</a> – 这是来自 Idaho State University 教程，主要用于Unix计算的基础，其中有一些很不错的示例和练习。</li>\n<li><a href=\"http://www.devdaily.com/unix/unix-dnld.shtml\">UNIX Training Manual</a> – 这是一个 88页 的培训手册，主要用一些示例来教一个Unix文件系统的相关的命令。严格说来，这并不是一个教程，但也很有用。</li>\n<li><a href=\"http://www.mcsr.olemiss.edu/unixhelp/commanz/index.html\">UNIX Command Tutorial</a> – 来自University of Mississippi 的教学生如果使用Unix命令和操作系统交互的课程。</li>\n<li><a href=\"http://www.softlookup.com/tutorial/Unix/index.asp\">Learn UNIX Tutorial</a> – Soft Lookup 的一个全面的 UNIX 教程，完全可以让你从一个新手变成一个高手。</li>\n<li><a href=\"http://heather.cs.ucdavis.edu/~matloff/UnixAndC/Unix/UnixBareMn.pdf\">UNIX – The Bare Minimum</a> – 来自 UC Davis 教授，提供了一个简单的UNIX介绍。</li>\n<li><a href=\"http://www.upscale.utoronto.ca/GeneralInterest/Harrison/LearnLinux/\">Learning About UNIX</a> – 来自University of Toronto，提供了一些UNIX 和Linux 课程笔记。这个课程关注于UNIX 和Linux 工具。</li>\n<li><a href=\"http://www.unix-manuals.com/tutorials/unix/unix.html\">What is UNIX?</a> – 这个教程提供了一个简单的Unix介绍，以及一个初学者的论坛。</li>\n</ul>\n<h2 id=\"Linux-和-UNIX-专家培训教程\">Linux 和 UNIX 专家培训教程</h2>\n<h3 id=\"免费的Linux高手教程\">免费的Linux高手教程</h3>\n<ul>\n<li><a href=\"http://www.linux.org/lessons/advanced/index.html\">Linux Online’s Course for Advanced Users</a> – 这是一个来自Linux Online的高级教程，提供了一系Linux最流行的How-To文档。主要是给那些想了解更多关于Linux安装，配置和维护的人。</li>\n<li><a href=\"http://www.linuxtraining.co.uk/download/new_linux_course_modules.pdf\">Linux System Administration Course</a> – 通过28个课程为Linux系统管理员提供了一个全面的教程。</li>\n<li><a href=\"http://www.howtoforge.com/howtos/linux/kernel\">Kernel Tutorials</a> – 这是在HowToForge上的一个内核级的教程，这个教程相当不错，如果你要了解Linux的内核，你不能错过这个教程。</li>\n<li><a href=\"http://lartc.org/lartc.html\">Advanced Routing and Traffic Control Tutorial</a> – 一个关于Linux网络路由，过滤和传输的教程。</li>\n<li><a href=\"http://ocw.novell.com/suse-linux-enterprise\">Linux Enterprise Server Courses</a> – Novell Training Services 提供给高级用户的培训教程。</li>\n<li><a href=\"http://learnlinux.tsf.org.za/courses/web-net-admin.html\">Linux Network Administration Course</a> – 来自Shuttleworth Foundation的 Linux 网络管理员的基础课程。</li>\n<li><a href=\"http://www.advancedlinuxprogramming.com/\">Advanced Linux Programming</a> – 这是一本电子书可以免费下载。这本书主要教程序员们怎么在Linux下做软件和编程序。</li>\n<li><a href=\"http://www.ibm.com/developerworks/views/linux/libraryview.jsp?type_by=Tutorials\">IBM’s Technical Library</a> – IBM’s Technical Library 提供的一组给高级Linux用户的教程。</li>\n</ul>\n<h3 id=\"免费的UNIX高手教程\">免费的UNIX高手教程</h3>\n<ul>\n<li><a href=\"http://www.ussg.iu.edu/UAU/uau.html\">UNIX for Advanced Users</a> – Indiana University的 UNIX Workstation Support Group 提供的一个相当不错的面对UNIX 高级用户的教程。</li>\n<li><a href=\"http://people.ischool.berkeley.edu/~kevin/unix-tutorial/\">Kevin Heard’s UNIX Tutorial</a> – Kevin Heard (UC Berkeley) 的一个相当相当不错的三部教程，从Unix的基础开始，以高级话题结束。</li>\n<li><a href=\"http://members.unine.ch/philippe.renard/unix2.html\">Advanced UNIX Commands</a> – 虽然这是一个命令例表，但他是一个相当不错的索引的速查手册。</li>\n<li><a href=\"http://users.actcom.co.il/~choo/lupg/tutorials/parallel-programming-theory/parallel-programming-theory.html\">Parallel Programming Tutorial</a> – 这个UNIX 教程面对的是Unix下的并行编程 Parallel Programming。</li>\n<li><a href=\"http://tldp.org/LDP/abs/html/\">Advanced Bash Scripting Guide</a> – 来自于Linux Document Project 的教程，一个shell编程由浅入深的教程。</li>\n<li><a href=\"http://www.vtc.com/products/Unix-Shell-Scripting-Advanced-tutorials.htm\">UNIX Shell Scripting Advanced</a> – VTC 有一组视频的 UNIX 的教程。而这一个是指导高级用户如何进行脚本编程。</li>\n<li><a href=\"http://heather.cs.ucdavis.edu/~matloff/UnixAndC/Unix/CShellII.pdf\">Advanced C Shell Programming</a> – 这是UC Davis 的教程，主要教使用如何使用C shell 和tcsh 进行脚本编程。</li>\n</ul>\n<h2 id=\"参考-感谢\">参考&amp;感谢</h2>\n<ul>\n<li><a href=\"https://blinkfox.github.io/2018/10/09/ruan-jian-gong-ju/linux/chang-yong-bash-ming-ling-zheng-li-zhi-cha-kan-wen-jian-he-mu-lu/\">常用Bash命令整理之查看文件和目录</a></li>\n<li><a href=\"https://blinkfox.github.io/2018/10/13/ruan-jian-gong-ju/linux/chang-yong-bash-ming-ling-zheng-li-zhi-qi-ta-chang-yong-ming-ling/\">常用Bash命令整理之其他常用命令</a></li>\n<li><a href=\"https://blinkfox.github.io/2018/10/11/ruan-jian-gong-ju/linux/chang-yong-bash-ming-ling-zheng-li-zhi-wen-ben-chu-li/\">常用Bash命令整理之文本处理</a></li>\n<li><a href=\"https://blinkfox.github.io/2018/10/09/ruan-jian-gong-ju/linux/chang-yong-bash-ming-ling-zheng-li-zhi-cha-kan-wen-jian-he-mu-lu/\">常用Bash命令整理之查看文件和目录</a></li>\n<li><a href=\"https://www.lixl.cn/2021/082248231.html\">Linux常用命令</a></li>\n<li><a href=\"http://educhoices.org/articles/Useful_Tutorials_on_Linux_and_UNIX_for_Beginners_and_Experts_Alike.html\">Useful Tutorials on Linux and UNIX for Beginners and Experts Alike</a></li>\n</ul>\n<link rel=\"stylesheet\" href=\"https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css\"><script src=\"https://fastly.jsdelivr.net/npm/d3@7\"></script><script src=\"https://fastly.jsdelivr.net/npm/markmap-view@0.18.10\"></script><script src=\"https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10\"></script>\n<link rel=\"stylesheet\" href=\"/css/markmap.css\">\n\n<script src=\"/js/markmap.js\"></script>\n",
            "tags": [
                "linux",
                "bash"
            ]
        },
        {
            "id": "https://blog.17lai.site/posts/495db4d3/",
            "url": "https://blog.17lai.site/posts/495db4d3/",
            "title": "CMake快速入门教程",
            "date_published": "2021-10-12T04:25:00.000Z",
            "content_html": "<h2 id=\"1-cmake简介\">1.cmake简介</h2>\n<p>cmake是跨平台的makefile文件生成工具,是为了解决各个平台下面make工具不同造成的makefile文件格式不同的问题.也就是cmake是用来解决跨平台编译问题的.常见的还有autotool工具集，该工具集用于GNU软件协议的makefile文件生成，方便GNU包的编译和安装。</p>\n<h2 id=\"2-cmake文件编辑规则\">2.cmake文件编辑规则</h2>\n<ul>\n<li>1)<strong>命令不区分大小写，但是变量区分大小写</strong>。</li>\n<li>2)<strong>注释</strong>使用#符号</li>\n<li>3)命令如果有多个参数，互相之间用空格隔开</li>\n</ul>\n<h2 id=\"3-cmake保留变量\">3.cmake保留变量</h2>\n<p>cmake里面有很多的预定义变量,是程序环境固有的,比如CUDA_NVCC_FLAGS,不同的变量有固定的作用,比如CUDA_NVCC_FLAGS是nvcc的参数list,变量可以使用set命令和list命令进行赋值和追加值,要注意的是变量可能可以有多个值,值与值之间用分号分开,可以使用set(var a b c)给var赋值a b c,还可以使用list命令给var追加删除插入值等,不同的变量有不同的值域,需要查阅<a href=\"https://cmake.org/documentation/\">手册</a></p>\n<h2 id=\"4-cmake变量引用\">4.cmake变量引用</h2>\n<p>cmake里面变量的取值引用要使用${var}的形式,但是在赋值的时候是不需要的,和shell命令有点相似.</p>\n<h2 id=\"5-cmake指定Debug和Release版本\">5.cmake指定Debug和Release版本</h2>\n<p>指定Debug和Release一共有三种方法：</p>\n<p>1.使用ADD_COMPILE_OPTIONS()加入-g指定Debug版本.</p>\n<p>2.使用SET( CMAKE_BUILD_TYPE Debug/Rrelease)指定Debug<br>\n在下面加入：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-cmake\" data-language=\"cmake\" data-start=\"1\"><code class=\"language-cmake\">SET(CMAKE_CXX_FLAGS_DEBUG &quot;$ENV&#123;CXXFLAGS&#125; -O0 -Wall -g2 -ggdb&quot;)\nSET(CMAKE_CXX_FLAGS_RELEASE &quot;$ENV&#123;CXXFLAGS&#125; -O3 -Wall&quot;)</code></pre></div></figure>\n<p>上面的设置C++编译选项，对于C语言，设置CMAKE_C_FLAGS_DEBUG、CMAKE_._FLAGS_RELEASE变量，一般来说最好两个都设置原因是CMake 中有一个变量 CMAKE_BUILD_TYPE ,可以的取值是 Debug Release等.当这个变量值为 Debug 的时候,CMake 会使用变量 CMAKE_CXX_FLAGS_DEBUG 和 CMAKE_C_FLAGS_DEBUG 中的字符串作为编译选项生成 Makefile</p>\n<p>编译动态库or静态库时，最好通过修改CXXFLAGS和CFLAGS，以支持-fPIC，这个选项有时是默认开启，有时默认关闭，但为了以后的应用，库文件最好都使用-fPIC编译</p>\n<ol start=\"3\">\n<li>在使用cmake命令时加上-DCMAKE_BUILD_TYPE=Debug/Release</li>\n</ol>\n<h2 id=\"5-cmake指定生成文件\">5.cmake指定生成文件</h2>\n<p>CUDA_ADD_LIBRARY()指明目标文件是库文件,CUDA_ADD_EXECUTABLE()指明生成的文件为可执行文件</p>\n<h2 id=\"6-配置模板\">6.配置模板</h2>\n<p>通常我们要在工程目录下面创建include、src文件夹，include文件夹里面存放头文件，src文件夹里面存放源代码，注意这时候的源代码里面包含头文件的路径应该是“…/include/xx.h”，然后在工程根目录下面创建CMakeLists.txt文件，里面写入命令.在编译的时候为了不搞乱工程目录，在工程根目录下面创建build文件夹，在里面使用“cmake …”命令创建CMakefile,再make即可。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-cmake\" data-language=\"cmake\" data-start=\"1\"><code class=\"language-cmake\">#指定cmake最低版本号\ncmake_minimum_required(VERSION 3.2)\n\n#指定项目名称\nPROJECT(Liner_Struct)\n\n#指定头文件目录，不同目录用空格隔开,目录中有空格可用引号\n#如果是相对路径，相对于CMakeLists.txt文件\nINCLUDE_DIRECTORIES(include)\n\n#指定源文件目录，DIR_SRCS值自定义变量，下面的命令对其进行了赋值\nAUX_SOURCE_DIRECTORY(src DIR_SRCS)\n\n#设置变量用于存放所有的编译文件，\n#TEST_LINER_STRUCT是自定义变量，使用SET给其赋值\nSET(TEST_LINER_STRUCT $&#123;DIR_SRCS&#125;)\n\n#增加编译选项\n#判断是否为gcc编译器，如果是，增加编译选项\n#c99是c语言的标准，常用的还有c++标准c++11\n#下面的命令判断是否编译器是gcc\n#message命令是输出信息,例如下面的输出“optional:-std&#x3D;c99”\nif(CMAKE_COMPILER_IS_GNUCXX)\n    ADD_COMPILE_OPTIONS(-std&#x3D;c99)\n    message(STATUS &quot;optional:-std&#x3D;c99&quot;)\nendif(CMAKE_COMPILER_IS_GNUCXX)\n\n#配置生成文件\n#$&#123;PROJECT_NAME&#125;是cmake自带变量，其值和PROJECT()命令指定的一样\n#$&#123;TEST_LINER_STRUCT&#125;是自定义变量，上文赋值的\nADD_EXECUTABLE($&#123;PROJECT_NAME&#125; $&#123;TEST_LINER_STRUCT&#125;)</code></pre></div></figure>\n<h2 id=\"7-if-else语句\">7.<a href=\"https://cmake.org/cmake/help/v3.0/command/if.html\">if-else</a>语句</h2>\n<p>cmake中的if-else语句</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-cmake\" data-language=\"cmake\" data-start=\"1\"><code class=\"language-cmake\">if(exp)\n     cmdA\n     cmdB\nelseif(exp)\n      cmdC\nendif(exp)</code></pre></div></figure>\n<p>最简单得到一个应用</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-cmake\" data-language=\"cmake\" data-start=\"1\"><code class=\"language-cmake\">if(ARM)\n   #ARM平台\nelse()\n  #非ARM平台 \nendif()</code></pre></div></figure>\n<p>使用cmake -DARM=1 … 时编译ARM代码，使用cmake -DAMR=0 …编译非ARM代码</p>\n<h2 id=\"8-与平台编译器的结合\">8.与平台编译器的结合</h2>\n<h3 id=\"8-1windows\">8.1windows</h3>\n<p>在windows上运行cmake可以生成对应的VS的工程文件，然后使用相应的VS打开工程就可以进行编译。要注意的是如果使用VS2010及其以前的版本，C不支持C99，也就是变量的命名必须放在函数或者域的最前面，不能放在中间，特别麻烦。VS2015在安装后可能还需要打开VS，新建工程时选择VC<ins>可能相关组件还没有安装，如果这时候使用cmake会提示找不到C、C</ins>编译器（类似yuNo CMAKE_CXX_COMPILER could be found）的错误。安装了相关的组件后cmake即不会有错误。</p>\n<h3 id=\"8-2-为VS2015生成的项目\">8.2 为VS2015生成的项目</h3>\n<p>打开工程文件后可以看到有3个项目，其中只有一个和我们有直接关系，就是我们在CMakeLists.txt里面定义的PROJECT_NAME,剩下的两个是ALL_BUILD和ZERO_CHECK.</p>\n<p><strong>ZERO_CHECK</strong><br>\n该目标会检查生成工程的 CMake 配置文件（ CMakeLists.txt ）是否更新。如更新，将运行 CMake 重新生成工程文件。</p>\n<p>如果确信 CMakeLists.txt 不会被更新，或者希望手工运行 CMake 重新生成工程文件，可以在 CMakeLists.txt 配置文件中添加 set(CMAKE_SUPPRESS_REGENERATION FALSE) 命令， ZERO_CHECK 目标将不会生成。</p>\n<p><strong>ALL_BUILD</strong><br>\n该目标会导致工程中所有项目被构建，类似 Visual Studio 的 Build All 或者 make 的 make all命令。</p>\n<p>转载 <a href=\"https://lightzhan.xyz/index.php/2020/03/11/cmake-quick-tutorial/\">CMake快速入门教程</a></p>\n<link rel=\"stylesheet\" href=\"https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css\"><script src=\"https://fastly.jsdelivr.net/npm/d3@7\"></script><script src=\"https://fastly.jsdelivr.net/npm/markmap-view@0.18.10\"></script><script src=\"https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10\"></script>\n<link rel=\"stylesheet\" href=\"/css/markmap.css\">\n\n<script src=\"/js/markmap.js\"></script>\n",
            "tags": [
                "linux",
                "cmake",
                "develop"
            ]
        },
        {
            "id": "https://blog.17lai.site/posts/b1fe1bb8/",
            "url": "https://blog.17lai.site/posts/b1fe1bb8/",
            "title": "Debian Lenny Laptop安装记录",
            "date_published": "2021-08-18T08:25:00.000Z",
            "content_html": "<h2 id=\"Debian-Lenny-Laptop安装记录\">Debian Lenny Laptop安装记录</h2>\n<p>这是一篇非常有历史的文章了，写了十多年了。只在个人google doc中公开共享过。时至今日，参考价值还是非常大的。</p>\n<p>目的是完全采用Linux系统来完成所有工作。</p>\n<p>这篇文章当年我写了一周，每个步骤都是实践后仔细记录的。</p>\n<h2 id=\"摘-要\">摘 要</h2>\n<p>​        在现在电子信息化社会中，网络越来越重要，各种电子商务，网上银行，网络交友，SNS社区等越来越红火，各国政府都在进行电子信息化建设，准备网上办公，无纸化作业。信息化就是现代化的思想已经深入人心，然而信息化建设的基础硬件和软件：</p>\n<p>硬件：CPU、主板、内存，硬盘等</p>\n<p>软件：操作系统（Operate System如Linux,Windows,Mac OS等），浏览器(如Firefox，Opera，Maxthon，IE等)，文档处理（OpenOffice,WPS,Word等），媒体播放（Mplayer,Realplayer等），以及其它软件工具。</p>\n<p>则是其中的重中之重，电子信息化社会信息安全最为关键。因为你不知道微软的Windows中给你预留了多少漏洞和后门，你不知道Intel或者AMD在它们生产的硬件中留下了什么缺陷，了解一点软硬件知识的人都知道，软件后门可以使微软进入你的电脑如同自己的电脑一样，微软可以看到所有你的文档，照片，工作生活的数据，你的电脑中的数据对微软而言没有任何秘密而言；硬件缺陷同样可以做后门用，甚至发送一段短码瞬间可以使你的电脑崩溃。可见安全多么重要，那么如何提高安全了？</p>\n<p>​        答案就是使用开源！开源早已经形成了一套完整的套件，上面介绍的软件中每样的地一种都是开源工具，完全免费！而且开放源代码，你可以知道每行代码的作用，后门、间谍将不复存在！你常用的Windows工具每样Linux都有替代品，很多工具甚至本来就是Linux中移植到Windows中来的，如暴风影音，比特精灵，Vim，Emacs等。</p>\n<p>​        本文简单的介绍了开源操作系统Debian的安装和配置，包括操作系统的安装、配置，常用工具的安装等详细过程，下文所叙全部经过测试，稳定运行。通过本文，您可以了解Linux操作系统大体组成结构，并且获得一部完全自己定制的操作系统！</p>\n<p>[TOC]</p>\n<h2 id=\"一：前言\">一：前言</h2>\n<h3 id=\"从今天开始做个Debianer\">从今天开始做个Debianer</h3>\n<p>刚从OpenSuSE 换过来的，感觉Debian非常强大。SuSE的yast2真的非常强大，刚离开yast感觉很痛苦，Novll的yast系统设置几乎在里面实现，它包括了系统硬件，软件设置，网络配置，服务器配置，各种系统设置等等。它把很多底层配置都接管了，使用SuSE的用户会发现SuSE比其他Linux发行版少很多配置文件。SuSE的yast2有命令行和图形界面两种操作方式，还有zypper这种完全命令行包管理工具。不过Debian的apt包管理更加强大，比zypper强大多了。</p>\n<p>Debian以定制性非常强，运行稳定而著称，是最符合GNU精神的发行版，对各种硬件构架都支持，是世界上唯一一种几乎可以在所有硬件平台运行的操作系统。Ubuntu就是在Debian的基础上发行的衍生版。但是本人使用感觉Ubuntu的感觉不好，Ubuntu就像一个在Debian testing基础上优化过得Debian一样，而且阉割的厉害。不过正由于阉割的厉害，把用户管理的东西Ubuntu都自己设置了，Ubuntu才成为最容易操作的Linux操作系统，而且也是最流行的Linux操作系统。不过Ubuntu限制用户操作非常严，感觉这样很大程度上失去了Linux的自由，可定制等特性。对Linux新人来说一开始使用Debian会非常困难的，强烈建议对Linux包管理，运行结构了解大概后再开始使用Debian。</p>\n<p>推荐的发行版有：</p>\n<p><strong>OpenSuSE</strong>：优点是从Windows转过来几乎马上就可以上手，用户不需要改变多少使用习惯，并且图形界面非常华丽，号称是最华丽的Linux操作系统。默认的就比Windows XP漂亮多了，开启Compiz Fusion后的3D特效比Vista,Win 7都要漂亮。对一般用户家庭使用和办公使用完全可以满足要求。缺点就是国内源很少，官方源在国外比较慢，速度也不保证，升级只能是半夜了，不过采用DVD安装的话就没多大问题。SuSE的中文社区不完善也是一大缺点。</p>\n<p><strong>Fedora</strong>：著名的Redhat公司出品，国内源非常多，中文化非常好，中文社区也非常活跃，很多问题可以直接中文搜出结果。缺点是对习惯Windows的用户来说，一开始就使用Fedora对大家的入门门坎比OpenSuSE高。</p>\n<p><strong>Ubuntu</strong>：最流行的Linux发行版，使用非常简单，中文社区建设的非常好，源很多，缺点就是阉割的太厉害了。感觉这样的版本对深入了解Linux不好，个人看法，不过对非技术型用户使用到是个不错的选择。</p>\n<p><strong>Debian</strong>是最自由，定制性最高的发行版，当然对用户的入门要求就更高了。但是，一经你上手了，那么就再别无他求。Debian的好是谁用谁知道！</p>\n<p>刚用上Debian，总结下，下面可能有错误之处，希望大家指出来。参考了很多人的文章下来的，对他们表示感谢！</p>\n<p>注意：本教程为</p>\n<h2 id=\"二：安装Debian之前的准备工作\">二：安装Debian之前的准备工作</h2>\n<p>●   强烈建议新人刚开始装不要按《 Debian etch 简要安装指南》那篇文章来，特别是笔记本用户，除非你对你的硬件非常熟悉。建议大家安装的时候选择图形界面安装。安装的时候选择图形界面，把Base system,Loptop,Desktop都安装上，这样会少很多麻烦的，它装了多余的东西和服务还是等进入桌面后再自己删除比较好。发现这样安装还是非常干净的，比之SuSE，Fedora之类的发行版默认安装东西要少多了。</p>\n<p>●   阵痛了好几天了，这几天重装了好多次Debian了，现在终于差不多了，3d打开了，系统很稳定。</p>\n<p>笔记本是Dell Inspiron6400。</p>\n<p>●   强烈建议大家装机之前看看debian的官方wiki</p>\n<p>例如我，就看下面这个：</p>\n<p><a href=\"http://wiki.debian.org/InstallingDebianOn/Dell/Inspiron6400/lenny\">http://wiki.debian.org/InstallingDebianOn/Dell/Inspiron6400/lenny</a></p>\n<p>●   大家的笔记本其他型号的话到下面网址找对应的型号</p>\n<p><a href=\"http://wiki.debian.org/InstallingDebianOn/\">http://wiki.debian.org/InstallingDebianOn/</a></p>\n<p>上面网址的参考下就可以了，有些问题很多种解决方法的。</p>\n<h2 id=\"三：开始安装Debian\">三：开始安装Debian</h2>\n<h3 id=\"3-1：安装前的准备和安装方法选择\">3.1：安装前的准备和安装方法选择</h3>\n<p>debian提供了很多安装方法，有网络安装，光盘安装，U盘安装，硬盘安装等多种方法。这里介绍下载光盘安装，这是对大多数人来说最为方便的安装发放，下载第一张光盘CD或者DVD镜像准备刻录安装。</p>\n<p>注意：先备份好重要的资料！比如copy到移动硬盘，或者其它主机上等以免错误的操作造成不必要的损失。</p>\n<p>进入Bios中设置光驱第一启动，放入光盘，等加载内核界面过去后，就进入安装界面了。</p>\n<h3 id=\"3-2：开始安装Debian\">3.2：开始安装Debian</h3>\n<ol>\n<li>\n<p>选择安装程序使用的语言，推荐选择English，选中文会装zhcon。</p>\n</li>\n<li>\n<p>选择国家，首先选择 other ，然后在选择 Asia ，最后选上 China 。</p>\n</li>\n<li>\n<p>选择键盘，直接默认就好了，也就是 American English ，如果你的不是美式键盘，就选择相应的键盘。</p>\n</li>\n<li>\n<p>设置网络，如果是 DHCP ，填上主机名和所在的域名就好了，如果是静态 IP ，根据相应的填上就 OK。这里有无线网卡的朋友就有些郁闷了，记得先去下载你的无线驱动的deb包，放到u盘根目录插上usb结构，系统会自动安装你的无线驱动。（但是这里安装好了还是无法dhcp连上无线，我采用有线装的，不知道谁这里无线配成功了。装完系统后再使用＃apt-get install firmware-iwlwifi 也可以。）</p>\n</li>\n<li>\n<p>磁盘分区，根据个人的情况进行。这里要小心了，如果你有重要的资料的话，推荐手动分区。</p>\n</li>\n<li>\n<p>对分区进行确认后就开始安装基本的系统，等待一段时间。</p>\n</li>\n<li>\n<p>然后就是设置 root 账户的密码，以及日常使用的一个账户名称和密码。</p>\n</li>\n<li>\n<p>账户设置好后对源进行设置，这里推荐手工输入。选择最上面一项。</p>\n</li>\n</ol>\n<p>○   输入：<a href=\"http://debian.cn99.com\">debian.cn99.com</a> 或者：<a href=\"http://mirrors.163.com\">mirrors.163.com</a></p>\n<p>○   目录就是/debian/   不需要改动。这两个其实都是一个源，我看到主机ip地址一样。这个应该是国内最快的源了。至少对大部分人来说。</p>\n<ol start=\"9\">\n<li>\n<p>根据个人的情况选择安装软件，推荐选择base system,laptop,desktop。</p>\n</li>\n<li>\n<p>安装中，看网络状况时间不同，等待…。</p>\n</li>\n<li>\n<p>安装 GRUB ，Yes安装到 MBR。</p>\n</li>\n<li>\n<p>安装完毕，最后 Continue 回车重启进入期待已久的 Debian Lenny GNU/Linux。</p>\n</li>\n</ol>\n<h2 id=\"四：配置Debia的基本中文操作环境\">四：配置Debia的基本中文操作环境</h2>\n<p>他哦难过上面二、三步，到现在你已经获得了一个基本的Debian Lenny操作系统了。但是到现在为止说能够顺手使用还太早，在正是使用之前还有几个事情需要做。</p>\n<p>（注意＃号提示的是root用户权限）</p>\n<h3 id=\"4-1：中文语言环境\">4.1：中文语言环境</h3>\n<h4 id=\"4-1-1-重新配置locale，添加中文locale\">4.1.1:重新配置locale，添加中文locale</h4>\n<p>​        选择以下locale，以下为推荐语言环境，用户可以根据自己语言习惯自由选择：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#dpkg-reconfigure locales\nen_US ISO-8859-1\nen_US.UTF-8 UTF-8\nzh_CN GB2312\nzh_CN.GB18030 GB18030\nzh_CN.GBK GBK\nzh_CN.UTF-8 UTF-8\nzh_HK BIG5-HKSCS\nzh_HK.UTF-8 UTF-8\nzh_TW BIG5\nzh_TW.EUC-TW EUC-TW\nzh_TW.UTF-8 UTF-8</code></pre></div></figure>\n<p>选择默认的locale为en_US.UTF-8或者 zh_CN.UTF-8。</p>\n<h4 id=\"4-1-2-安装localepurge\">4.1.2:安装localepurge</h4>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">＃apt-get install localepurge</code></pre></div></figure>\n<p>​       在对话框中选择你要保留使用的locale，默认情况下它已经选好了你现前设置的那些locale，不过还是请仔细确认后再回车。当然你也可以使用 dpkg-reconfigure localepurge 来进行详细的配置。</p>\n<p>●   清除你用不着的locale，让他们释放你的磁盘空间</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">＃localepurge</code></pre></div></figure>\n<p>​       以后你不管安装什么软件，它都将自动帮你清除那些没用的locale。清除完，它会提示你释放了多少磁盘空间。当然你可以配置它让它显示清除了哪些locale。</p>\n<p>​       Linux下面还有其他工具清理,如BleachBit，这是一款专为Linux 设计的系统清理工具。使用BleachBit，你可以清理系统中的缓存、不要的语言文件，历史、临时文件、cookies 等不需要的东西，这样可以释放你空间。推荐，不过Stable的源中没有该包，需要手动下载安装。</p>\n<h3 id=\"4-2-实现root用户登录自动Tab补全\">4.2:实现root用户登录自动Tab补全</h3>\n<p>修改 .bashrc ，打开bash_completion，让apt-get install 在ROOT 登录的情况下自动补全，其他用户自动设置好了的，不用修改。你可以先用VI打开 /etc/bash.bashrc ,在最下面用命令模式下的V 再按上下左右键老选择，按y键复制，（默认打开VI就处于命令模式。i a o s键插入，编辑模式，ESC返回，：q! 退出。） 然后 vi ~/.bashrc 按p 键粘贴。最后象这样</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">if [ -f &#x2F;etc&#x2F;bash_completion ]; then\n. &#x2F;etc&#x2F;bash_completion\nfi</code></pre></div></figure>\n<p>当然你也可以用nano ,更简单。要复制功能,那么apt-get install gpm 然后 /etc/init.d/gpm start ，现在动下鼠标。是不是在动了，gpm是一个控制台下的鼠标服务。用鼠标左击拖动选中，右键粘贴。</p>\n<h3 id=\"4-3：将用户加入到sudoers列表中\">4.3：将用户加入到sudoers列表中</h3>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#chmod +w &#x2F;etc&#x2F;sudoers\n#vim &#x2F;etc&#x2F;sudoers</code></pre></div></figure>\n<p>添加一行：username ALL=(ALL) ALL</p>\n<p>其中username是你的用户名，保存</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#chmod 0440 &#x2F;etc&#x2F;sudoers</code></pre></div></figure>\n<p>这样，您的普通用户可以使用&quot;sudo + [命令]&quot;来执行需要管理员权限的操作</p>\n<h3 id=\"4-4-配置更新源并更新系统\">4.4:配置更新源并更新系统</h3>\n<h4 id=\"4-4-1-备份旧的源\">4.4.1:备份旧的源</h4>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">＃cp &#x2F;etc&#x2F;apt&#x2F;sources.list &#x2F;etc&#x2F;apt&#x2F;sources.list.old</code></pre></div></figure>\n<h4 id=\"4-4-2-配置新源\">4.4.2:配置新源</h4>\n<p>把下面的加进去，应该可以满足绝大多数人的要求了。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#gedit &#x2F;etc&#x2F;apt&#x2F;sources.list\n＃＃＃&#x3D;&#x3D;&#x3D;&#x3D;sources.list Begin&#x3D;&#x3D;&#x3D;＃＃＃\n##cn99\ndeb http:&#x2F;&#x2F;debian.cn99.com&#x2F;debian&#x2F; lenny main non-free contrib\ndeb-src http:&#x2F;&#x2F;debian.cn99.com&#x2F;debian&#x2F; lenny main non-free contrib\ndeb http:&#x2F;&#x2F;debian.cn99.com&#x2F;debian&#x2F; lenny-proposed-updates main non-free contrib\ndeb-src http:&#x2F;&#x2F;debian.cn99.com&#x2F;debian&#x2F; lenny-proposed-updates main non-free contrib\n \ndeb http:&#x2F;&#x2F;debian.cn99.com&#x2F;debian-security&#x2F; lenny&#x2F;updates main contrib non-free\ndeb-src http:&#x2F;&#x2F;debian.cn99.com&#x2F;debian-security&#x2F; lenny&#x2F;updates main contrib non-free\ndeb http:&#x2F;&#x2F;debian.cn99.com&#x2F;debian-backport&#x2F; lenny-backports main contrib non-free\ndeb-src http:&#x2F;&#x2F;debian.cn99.com&#x2F;debian-backport&#x2F; lenny-backports main contrib non-free\ndeb http:&#x2F;&#x2F;security.debian.org&#x2F; lenny&#x2F;updates main contrib non-free\ndeb-src http:&#x2F;&#x2F;security.debian.org&#x2F; lenny&#x2F;updates main contrib non-free\n\ndeb http:&#x2F;&#x2F;volatile.debian.org&#x2F;debian-volatile lenny&#x2F;volatile main contrib non-free\ndeb-src http:&#x2F;&#x2F;volatile.debian.org&#x2F;debian-volatile lenny&#x2F;volatile main contrib non-free \n\ndeb http:&#x2F;&#x2F;http.us.debian.org&#x2F;debian&#x2F; lenny main contrib non-free\ndeb-src http:&#x2F;&#x2F;http.us.debian.org&#x2F;debian&#x2F; lenny main contrib non-free\ndeb http:&#x2F;&#x2F;www.debian-multimedia.org&#x2F; lenny main\ndeb-src http:&#x2F;&#x2F;www.debian-multimedia.org&#x2F; lenny main \n\ndeb http:&#x2F;&#x2F;download.virtualbox.org&#x2F;virtualbox&#x2F;debian lenny non-free\n＃＃＃&#x3D;&#x3D;&#x3D;sources.list End&#x3D;&#x3D;&#x3D;＃＃＃</code></pre></div></figure>\n<p>注意：debian-multimedia.org的源需要安装KEY，在<a href=\"http://debian-multimedia.org\">http://debian-multimedia.org</a> 下载安装debian-multimedia-keyring_2008.10.16_all.deb</p>\n<p>Debian采用严格的GPG认证来保证安装包不被恶意篡改，使您已经安装就是最新最稳定的系统！</p>\n<h4 id=\"4-4-3-更新源并升级系统\">4.4.3:更新源并升级系统</h4>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#apt－get update</code></pre></div></figure>\n<p>这里就会提醒你有那些源没有GPG密匙，把错误密匙代号放到 iceweasel的搜索框，回车，就会看到大量的相关问题，随便点开2个就可以看到怎么样取得密匙。这个是偷懒的办法，但是非常有效！建议。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">＃apt-get update &amp;&amp; apt-get upgrade</code></pre></div></figure>\n<p>这次才是真的升级系统。如果通过网络安装，一般安装过程中就会自动选择最新的稳定的最新无漏洞包，一般来说没有更新包。</p>\n<h3 id=\"四：网卡，声卡及显卡驱动安装\">四：网卡，声卡及显卡驱动安装</h3>\n<h3 id=\"4-1-配置无线网卡和ADSL来上网\">4.1: 配置无线网卡和ADSL来上网</h3>\n<p>系统默认一般会识别有线的网卡驱动，Linux几乎可以识别现在所有的有线网卡，而无线网卡驱动由于是非</p>\n<h4 id=\"4-1-1-配置无线网卡\">4.1.1:配置无线网卡</h4>\n<p>●   驱动 这个看个文的硬件了</p>\n<p>​                   ＃apt-get install firmware-iwlwifi</p>\n<p>​                        ＃modprobe iwl3945   ＃加载内核模块</p>\n<p>​                   这个我的Dell Inspiron6400的无线网卡是Intel 3945，其他无线网卡型号的用户请自己查找相关驱动包。</p>\n<p>●   安装管理工具</p>\n<p>​                   apt-get install wifi-radar</p>\n<p>●   配置无线</p>\n<p>看大家的无线设置，选择Essid,加密方式，频段等。</p>\n<h4 id=\"4-1-2-使用PPPOE连接ADSL\">4.1.2:使用PPPOE连接ADSL</h4>\n<p>●   使用PPPOE连接Adsl</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#apt-get install pppoeconf\n#pppoeconf #设置用户名与密码\n#pon dsl-provider #连接\n#poff #断开</code></pre></div></figure>\n<h3 id=\"4-2-让alsa把你的声卡驱动起来\">4.2:让alsa把你的声卡驱动起来</h3>\n<p>#apt-get install alsa-base alsa-utils alsa-oss</p>\n<p>**配置声卡：**执行 alsaconf 一路回车。 再执行alsa-mixer 设置音量，M键取消静音，ESC 键退出。保存设置 alsactl store。</p>\n<p>**测试 声卡：**cat /dev/urandom &gt; /dev/dsp 你将会听到非常好听的声音，恭喜你，你的声卡工作了。</p>\n<p>ctrl+c 终止它，当然你喜欢它的话，可以不那么做<sup>_</sup></p>\n<p>到这里，你的X服务器和声卡就安装配置好了。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#apt-get install gnome-audio esound</code></pre></div></figure>\n<p>esound是gnome下的软件混音器</p>\n<h3 id=\"4-3-显卡驱动的安装及配置\">4.3:显卡驱动的安装及配置</h3>\n<p><a href=\"http://wiki.cchtml.com/index.php/Ubuntu_Dapper_Installation_Guide\">http://wiki.cchtml.com/index.php/Ubuntu_Dapper_Installation_Guide</a></p>\n<p>安装编译驱动所需的环境</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">sudo apt-get update\nsudo apt-get install module-assistant build-essential\nsudo apt-get install fakeroot dh-make debconf libstdc++5 linux-headers-$(uname -r)</code></pre></div></figure>\n<p>创建安装包</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">sudo .&#x2F;ati-driver-installer-8.x.x.run --buildpkg debian&#x2F;testing</code></pre></div></figure>\n<p>安装这些创建的包b</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">sudo dpkg -i xorg-driver-fglrx_8.x.x-1_i386.deb -f\nsudo dpkg -i fglrx-kernel-source_8.x.x-1_i386.deb -f\nsudo dpkg -i fglrx-control_8.x.x-1_i386.deb -f</code></pre></div></figure>\n<p>删除旧的源码包</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">sudo rm &#x2F;usr&#x2F;src&#x2F;fglrx-kernel*.deb</code></pre></div></figure>\n<p>编译并安装驱动模块</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">sudo module-assistant build fglrx\nsudo module-assistant install fglrx\nsudo depmod -a</code></pre></div></figure>\n<p>编辑你的/etc/X11/xorg.conf</p>\n<p>在 Section “Module” 中加入</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">Load &quot;fglrx&quot;\nLoad &quot;dri&quot;\nLoad &quot;glx&quot;</code></pre></div></figure>\n<p>在Section “Device” 中把驱动换成</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">Driver &quot;fglrx&quot;</code></pre></div></figure>\n<h4 id=\"4-3-1-ATI显卡驱动安装\">4.3.1:ATI显卡驱动安装</h4>\n<p>To build your own .deb packages you will need to install at least the following packages from the apt repositories:</p>\n<p>●   fakeroot</p>\n<p>●   debhelper</p>\n<p>●   build-essential</p>\n<p>●   make</p>\n<p>●   module-assistant</p>\n<h5 id=\"Installing-from-Debian-non-free\">Installing from Debian non-free</h5>\n<p>Note: in lenny, they’ve renamed fglrx-kernel-src to fglrx-source (but the following worked for me with that substitution).</p>\n<h5 id=\"Install-the-driver\">Install the driver</h5>\n<p>sudo apt-get update</p>\n<p>sudo apt-get install module-assistant fglrx-driver fglrx-kernel-src</p>\n<h5 id=\"build-and-install-the-module\">build and install the module</h5>\n<p>#:sudo module-assistant auto-install fglrx-kernel-src</p>\n<p>After this, you need</p>\n<p>#:sudo aticonfig --initial</p>\n<p>This will update your xorg.conf to use the new driver. Restart for the changes to take effect.</p>\n<p>＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝</p>\n<p><strong>1</strong> <strong>构建相应的系统驱动包：</strong></p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">.&#x2F;ati-driver-installer-8.41.7-x86.x86_64.run --buildpkg Debian&#x2F;unstable</code></pre></div></figure>\n<p>我们可以用下面的命令来列出所有可以构建的程序包：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">.&#x2F;ati-driver-installer-8.41.7-x86.x86_64.run --listpkg</code></pre></div></figure>\n<p>我们可以从这个输出中选择适合我们系统的参数来进行构建相应的程序包。</p>\n<p><strong>2</strong> <strong>安装所构建的程序包：</strong></p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\"># dpkg -i fglrx*.deb</code></pre></div></figure>\n<p><strong>3</strong> <strong>安装module-assistant工具：</strong></p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\"># apt-get install module-assistant</code></pre></div></figure>\n<p><strong>4</strong> <strong>使用m-a安装驱动模块</strong></p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\"># m-a prepare\n# m-a a-i fglrx</code></pre></div></figure>\n<p>驱动模块的安装需要相应的内核头文件，所以我们在进行这一步之前需要安装相应的头文件：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\"># apt-get install linux-headers-&#96;uname -r&#96;</code></pre></div></figure>\n<p>这样就可以自动来安装fglrx驱动模块了。</p>\n<p>此时我们可以通过下面的命令来测试fglrx驱动模块是否安装成功：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\"># modprobe fglrx </code></pre></div></figure>\n<p><strong>5</strong> <strong>配置Xorg.conf</strong></p>\n<p>在配置中我们要做的主要工作就要载入fglrx模块，在&quot;Deveice&quot;部分，将vesa驱动改为fglrx，重新启动X。如果一切正常，我们就可以享受到ATI驱动的带来的视觉效果了。</p>\n<p>我们可以用下面的命令来检测我们的ATI驱动是否安装成功：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">$ fglrxinfo</code></pre></div></figure>\n<p>我们应得到下面的输出：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">display: :0.0 screen: 0\nOpenGL vendor string: ATI Technologies Inc.\nOpenGL renderer string: ATI Mobility Radeon HD 2400 XT\nOpenGL version string: 2.1.7059 Release</code></pre></div></figure>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">$ glxinfo | grep direct</code></pre></div></figure>\n<p>我们希望的输出结果为：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">direct rendering: Yes</code></pre></div></figure>\n<p>而我们在源中也可以找到相应的fglrx程序包：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\"># apt-cache search fglrx</code></pre></div></figure>\n<p>个人觉得没有必要非得安装所谓的官方驱动包，因为由所谓的官方驱动包中所解出正是源中的几个程序包，而我在安装了官方的驱动程序包后进行了一下upgrade，居然更新其中的两个包，既然这样，我们还不如直接安装源中的驱动程序包方便：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\"># apt-get install fglrx* </code></pre></div></figure>\n<p>使用m-a安装驱动模块时，我们也可以使用分步的安装方式，先编译，再安装，而不必一步到位：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\"># m-a get fglrx\n# m-a build fglrx</code></pre></div></figure>\n<p>这 时就会在/usr/src/目录下生成一个fglrx的deb包。编译驱动程序模块时需要安装Linux内核头文件，我的内核是自己编译的2.6.23， 但是在源中却迟迟没有相应的头文件包，真是相当郁闷的说。但是即使是这样，我却依然得到了一个编译生成的fglrx的deb包。我们可以使用dpkg来进 行安装。</p>\n<p>最后需要进行Xorg的配置。最简单的就是将驱动改为fglrx。当然我们也可以使用ati所提供的相应工具来进行配置：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\"># aticonfig --initial --input&#x3D;&#x2F;etc&#x2F;X11&#x2F;xorg.conf</code></pre></div></figure>\n<p>这会进行相应的检测，并且修改xorg.conf文件。</p>\n<h4 id=\"4-3-2-NVIDIA显卡驱动的安装\">4.3.2:NVIDIA显卡驱动的安装</h4>\n<h2 id=\"五：常用软件安装及配置\">五：常用软件安装及配置</h2>\n<p>​            发现Debian 即使是选择了base system,laptop,desktop其实也没有装多少东西，很多还需要自己安装,例如alsa-oss,gnome-audio等默认没有安装（应该没有记错）。下面很多东西可能系统已经安装了，但是这么做没有错的，下面的都是几乎不可缺少的组件。</p>\n<h4 id=\"5-1-Gnome相关\">5.1:Gnome相关</h4>\n<h4 id=\"5-1-1-Gnome基本系统及基本管理工具\">5.1.1:Gnome基本系统及基本管理工具</h4>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#apt-get install xorg gnome-core gdm gdm-themes gnome-system-tools gconf-editor nautilus-open-terminal gnome-power-manager gnome-screensaver</code></pre></div></figure>\n<p>xorg X窗口系统</p>\n<blockquote>\n<p>gnome-core     gnome核型组件</p>\n<p>gdm  #gnome 默认的窗口管理器</p>\n<p>gnome-system-tools     服务、网络等系统工具</p>\n<p>gconf-editor     配置编辑器</p>\n<p>nautilus-open-terminal    在右键菜单中加入终端</p>\n<p>gnome-power-manager   #电源管理，休眠支持</p>\n<p>gnome-screensaver      #锁屏</p>\n<p>gconf-editor     #配置编辑器</p>\n<p>ntfs-3g  #支持NTFS文件格式的读写</p>\n<p>nautilus-gksu #以管理员权限打开目录</p>\n</blockquote>\n<h4 id=\"5-1-2-安装gnome主题、图标、背景\">5.1.2:安装gnome主题、图标、背景</h4>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#apt-get install  gnome-themes gnome-icon-theme-dlg-neu gnome-backgrounds</code></pre></div></figure>\n<h3 id=\"5-3-常用软件工具安装\">5.3:常用软件工具安装</h3>\n<h4 id=\"5-3-1-字体安装\">5.3.1:字体安装</h4>\n<h5 id=\"●-使用apt\">●   使用apt</h5>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">＃ apt-get install ttf-bitstream-vera ttf-arphic-uming  ttf-freefont #ttf-freefont 解决flash菜单可能的乱码，</code></pre></div></figure>\n<p>WQY点整字体: apt-get install xfonts-wqy</p>\n<p>ttf-wqy-zenhei #文泉驿正黑字体</p>\n<h5 id=\"●-手工安装字体\">●   手工安装字体</h5>\n<p>把字体&quot;.ttf&quot;字体copy到&quot;/usr/share/fonts&quot;下面的某目录中</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">sudo mkfontscale\nsudo mkfontdir\nsudo fc-cache</code></pre></div></figure>\n<h5 id=\"●-系统字体优化：\">●   系统字体优化：</h5>\n<p>1.右击桌面，打开外观管理器中的字体选项卡，将其中的字体全部改成雅黑字体，同时把窗口标题设置为加粗，并选择LCD模式。</p>\n<p>2.在终端里输入指令</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-none\" data-start=\"1\"><code class=\"language-none\">sudo gedit &#x2F;etc&#x2F;fonts&#x2F;conf.d&#x2F;49-sansserif.conf</code></pre></div></figure>\n<p>将其中的字体全部改成雅黑，该操作也可以同时解决flash中出现方框的问题。</p>\n<h4 id=\"\"></h4>\n<p>5.3.2:输入法</p>\n<p>●   安装scim中文输入法，可选其他的如fcitx</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#apt-get install scim scim-pinyin scim-tables-zh im-switch\n#im-switch -z en_US -s scim #英文系统下使用SCIM：\nscim-qtimm #scim兼容QT程序\n#im-switch -s scim -z default</code></pre></div></figure>\n<p>●   光标跟随</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#gedit &#x2F;etc&#x2F;X11&#x2F;xinit&#x2F;xinput.d&#x2F;scim\n#GTK_IM_MODULE&#x3D;xim\n#QT_IM_MODULE&#x3D;xim\nGTK_IM_MODULE&#x3D;scim\nQT_IM_MODULE&#x3D;scim</code></pre></div></figure>\n<p>●   或者选择fctix</p>\n<p>不管你是kde还是gnome 安装fcitx就这样：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">apt-get install fcitx im-switch\nim-switch -s fcitx -z default</code></pre></div></figure>\n<h4 id=\"5-3-3-双击安装deb文件\">5.3.3:双击安装deb文件</h4>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#apt-get install gdeb</code></pre></div></figure>\n<h4 id=\"5-3-4-压缩与解压缩\">5.3.4:压缩与解压缩</h4>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#apt-get install file-roller p7zip-full cabextract rar unrar  p7zip-rar rar unrar cabextract#7z,rar，cab\n\n＃apt-get install gnochm</code></pre></div></figure>\n<h4 id=\"gnochm-CHM阅读，或者chmsee\">gnochm #CHM阅读，或者chmsee</h4>\n<p>5.3.5:安装OpenOffice.org</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#apt-get install openoffice.org-writer openoffice.org-calc openoffice.org-math openoffice.org-impress openoffice.org-gtk openoffice.org-help-en-us\n#apt-get install openoffice.org-l10n-zh-cn openoffice.org-help-zh-cn #中文界面和中文帮助</code></pre></div></figure>\n<h4 id=\"5-3-6-安装视频播放器\">5.3.6:安装视频播放器</h4>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#apt-get install mplayer w32codecs smplayer</code></pre></div></figure>\n<p>w32codecs #多媒体库</p>\n<h4 id=\"5-3-7-PDF阅读\">5.3.7:PDF阅读</h4>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#apt-get install evince xpdf xpdf-chinese-simplified xpdf-chinese-traditional poppler-data</code></pre></div></figure>\n<p>xpdf-chinese-simplified xpdf-chinese-traditional poppler-data完美中文支持</p>\n<h4 id=\"5-3-8-图像处理\">5.3.8:图像处理</h4>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#apt-get install gimp</code></pre></div></figure>\n<h4 id=\"5-3-9-网络通讯\">5.3.9:网络通讯</h4>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#apt-get install pidgin</code></pre></div></figure>\n<ol start=\"11\">\n<li>编程环境支持</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#apt-get install build-essential libgtk2.0-dev freeglut3-dev libtool autoconf automake subversion</code></pre></div></figure>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">deb http:&#x2F;&#x2F;apt.jenslody.de&#x2F; any main\ndeb-src http:&#x2F;&#x2F;apt.jenslody.de&#x2F; any main\ndeb http:&#x2F;&#x2F;apt.wxwidgets.org&#x2F; etch-wx main\n#KEY：\nwget -q http:&#x2F;&#x2F;apt.jenslody.de&#x2F;jens.asc -O- | sudo apt-key add -\nwget -q http:&#x2F;&#x2F;apt.wxwidgets.org&#x2F;key.asc -O- | sudo apt-key add -</code></pre></div></figure>\n<ol start=\"4\">\n<li>其他安装</li>\n</ol>\n<p>安装Multiget：<a href=\"https://multiget.sourceforge.net/download.html\">http://multiget.sourceforge.net/download.html</a></p>\n<p>安装Opera：<a href=\"https://www.opera.com/download/\">http://www.opera.com/download/</a></p>\n<p>安装RealPlayer：<a href=\"https://www.real.com/linux\">http://www.real.com/linux</a></p>\n<p>安装AdobeReader：<a href=\"https://www.adobe.com/products/acrobat/readstep2_allversions.html\">http://www.adobe.com/products/acrobat/readstep2_allversions.html</a></p>\n<p>安装FlashPlayer：<a href=\"https://www.adobe.com/shockwave/download/download.cgi?P1_Prod_Version=ShockwaveFlash&amp;P2_Platform=Linux\">http://www.adobe.com/shockwave/download/download.cgi?P1_Prod_Version=ShockwaveFlash&amp;P2_Platform=Linux</a></p>\n<p>编译CodeBlocks的SVN版本：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">svn checkout svn:&#x2F;&#x2F;svn.berlios.de&#x2F;codeblocks&#x2F;trunk ~&#x2F;Downloads&#x2F;CodeBlocks</code></pre></div></figure>\n<p>安装CodeBlocks：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">sudo apt-get install codeblocks</code></pre></div></figure>\n<p>alien    a package converter,将rpm,dpkg,stampede slp己slackware tgz档格式间的转换</p>\n<p>pdfedit 修改pdf文件</p>\n<p>linux开发工具： gcc,make,autoconf,diff,patch,rcs,emacs</p>\n<p>mysql-admin,mysql-navigator,mysql-query-browser</p>\n<p>安装版本控制软件</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">sudo apt-get install subversion cvs</code></pre></div></figure>\n<p>安装中文输入法</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">sudo apt-get install scim-pinyin</code></pre></div></figure>\n<p>安装词典 <a href=\"http://stardict.sourceforge.net\">http://stardict.sourceforge.net</a></p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">sudo apt-get install stardict sox</code></pre></div></figure>\n<p>/usr/share/stardict/dic/stardict-langdao-ce-gb-2.4.2 (郎道汉英辞典)</p>\n<p>/usr/share/stardict/dic/stardict-langdao-ec-gb-2.4.2 (郎道英汉辞典)</p>\n<p>/usr/share/WyabdcRealPeopleTTS (英文语音词库)</p>\n<p>安装邮件客户端</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">sudo apt-get install thunderbird</code></pre></div></figure>\n<p>安装 win-xchm查看器</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">sudo apt-get install xchm</code></pre></div></figure>\n<p>安装 msn for linux</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">sudo apt-get install emesene</code></pre></div></figure>\n<p>安装下载工具 ( bt 工具 transmission 默认已安装 ; amule 对应windows平台的 emule)</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">sudo apt-get install gwget amule</code></pre></div></figure>\n<p>安装 rss 订阅工具</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">sudo apt-get install liferea</code></pre></div></figure>\n<p>硬件监控工具</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">sudo apt-get install sensors-applet</code></pre></div></figure>\n<p>远程桌面管理,RDP默认已安装</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">sudo apt-get install xvnc4viewer</code></pre></div></figure>\n<p>安装视频/音频解码器</p>\n<p>gnome 平台推荐用 totem+gstreamer*, 直接点击多媒体文件,totem会自动搜索匹配解码器安装</p>\n<p>特殊的rm, rmvb格式文件, RealPlayer 11 for Linux 刚发布 (<a href=\"http://www.real.com/linux\">http://www.real.com/linux</a>) ,效果不错,可以不用 w32codecs 了.</p>\n<p>安装 flash for firefox, 新版多了一个选项”swfdec player”, 推荐, 其对CPU消耗改善了</p>\n<ol>\n<li>\n<p>swfdec player for adobe/macromedia flash</p>\n</li>\n<li>\n<p>adobe flash player</p>\n</li>\n<li>\n<p>gnash swf player</p>\n</li>\n</ol>\n<p>中文编码配置</p>\n<p>sudo vi /var/lib/locales/supported.d/zh</p>\n<p>加入以下编码支持</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">zh_CN.GB18030 GB18030\nzh_CN.GBK GBK\nzh_CN.GB2312 GB2312\nzh_HK.BIG5 BIG5\nzh_TW.BIG5 BIG5</code></pre></div></figure>\n<p>立即应用更新</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">sudo locale-gen</code></pre></div></figure>\n<p>安装 vim</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">sudo apt-get install vim</code></pre></div></figure>\n<p>配置 vim</p>\n<p>sudo vi /etc/vim.local</p>\n<p>加入以下设置(个人喜好)</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">syntax on\n\nset expandtab\n\nset tabstop&#x3D;4\n\nset shiftwidth&#x3D;4\n\nset sts&#x3D;4\n\nset autoindent\n\nset smartindent\n\nset cindent\n\nset number\n\nlet &amp;termencoding&#x3D;&amp;encoding\n\nset fileencodings&#x3D;utf-8,gb18030,gbk,gb2312,big5</code></pre></div></figure>\n<p>配置 gedit</p>\n<p>执行 sudo gconf-editor</p>\n<p>选择 apps/gedit-2/preferences/encodings</p>\n<p>找到 auto_detected 编辑，在Values中分别加入 GB18030,GBK,GB2312,BIG5</p>\n<p>界面风格 <a href=\"http://art.gnome.org\">http://art.gnome.org</a></p>\n<p>Ubuntu 默认的橘黄风格让我”焦躁”,一直偏向用蓝,灰的风格</p>\n<p>窗体用 SimpleBox (2.6 kb, 下载安装)</p>\n<p>图标用 tango ( apt-get install tango-icon-theme )</p>\n<p>Others</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">apt-show-source apt-show-versions archmage chmsee aria2 debian-faq-zh-cn fontforge gedit-plugins gtkcookie gupnp-tools htmldoc powersaved tor ttf-bitstream-vera vim-addon-manager</code></pre></div></figure>\n<h2 id=\"六：笔记本配置专辑\">六：笔记本配置专辑</h2>\n<p><strong>Dell Inspiron 6400</strong></p>\n<table>\n<thead>\n<tr>\n<th><img src=\"https://cimg1.17lai.site/data/2021/08/1820210818223005.jpg\" alt=\"\"></th>\n<th>- Video card: Intel Corporation- Mobile 945GM/GMS/940GML Express Integrated Graphics Controller- RAM: 2Go- Hard disk drive: 100Go- Processor: Pentium Dual-core 1.86GHz <em>(T2130)</em>- Ethernet card: Broadcom Corporation BCM4401-B0 100Base-TX- Wifi Card: Intel Corporation PRO/Wireless 3945ABG Network Connection- Optical device: DVD+RW- Screen WSXGA+: resolution=1200x800, size=15,4&quot; wide</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"Overall-Status\">Overall Status</h2>\n<table>\n<thead>\n<tr>\n<th><strong>Core Components</strong></th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Boot Standard Kernel:</td>\n<td><img src=\"https://cimg1.17lai.site/data/2021/08/1820210818223057.gif\" alt=\"\"></td>\n<td></td>\n</tr>\n<tr>\n<td>LAN network card:</td>\n<td><img src=\"https://cimg1.17lai.site/data/2021/08/1820210818223104.gif\" alt=\"\"></td>\n<td></td>\n</tr>\n<tr>\n<td>Detect CD/DVD:</td>\n<td><img src=\"https://cimg1.17lai.site/data/2021/08/1820210818223104.gif\" alt=\"\"></td>\n<td></td>\n</tr>\n<tr>\n<td>Detect hard drives:</td>\n<td><img src=\"https://cimg1.17lai.site/data/2021/08/1820210818223119.gif\" alt=\"\"></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>Extra Features</strong></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://wiki.debian.org/InstallingDebianOn/Dell/Inspiron6400/lenny#cpu\">CPU Frequency Scaling</a></td>\n<td><img src=\"https://cimg1.17lai.site/data/2021/08/1820210818223130.gif\" alt=\"\"></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://wiki.debian.org/InstallingDebianOn/Dell/Inspiron6400/lenny#power\">Hibernation</a></td>\n<td><img src=\"https://cimg1.17lai.site/data/2021/08/1820210818223136.gif\" alt=\"\"></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://wiki.debian.org/InstallingDebianOn/Dell/Inspiron6400/lenny#power\">Sleep / Suspend</a></td>\n<td><img src=\"https://cimg1.17lai.site/data/2021/08/1820210818223136.gif\" alt=\"\"></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://wiki.debian.org/InstallingDebianOn/Dell/Inspiron6400/lenny#display\">Xorg</a></td>\n<td><img src=\"https://cimg1.17lai.site/data/2021/08/1820210818223148.gif\" alt=\"\"></td>\n<td></td>\n</tr>\n<tr>\n<td>- OpenGL</td>\n<td><img src=\"https://cimg1.17lai.site/data/2021/08/1820210818223200.gif\" alt=\"\"></td>\n<td></td>\n</tr>\n<tr>\n<td>- Resize-and-Rotate(randr)</td>\n<td><img src=\"https://cimg1.17lai.site/data/2021/08/1820210818223209.gif\" alt=\"\"></td>\n<td></td>\n</tr>\n<tr>\n<td>Switch to External Screen</td>\n<td><img src=\"https://cimg1.17lai.site/data/2021/08/1820210818223223.gif\" alt=\"\"></td>\n<td></td>\n</tr>\n<tr>\n<td>Mouse</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>- Built-in (Trackpoint)</td>\n<td>[-]</td>\n<td></td>\n</tr>\n<tr>\n<td>- Built-in (Touchpad)</td>\n<td><img src=\"https://cimg1.17lai.site/data/2021/08/1820210818223231.gif\" alt=\"\"></td>\n<td></td>\n</tr>\n<tr>\n<td>Modem</td>\n<td>[?]</td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://wiki.debian.org/InstallingDebianOn/Dell/Inspiron6400/lenny#wifi\">Wireless/Wifi</a></td>\n<td><img src=\"https://cimg1.17lai.site/data/2021/08/1820210818223237.gif\" alt=\"\"></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://wiki.debian.org/InstallingDebianOn/Dell/Inspiron6400/lenny#keys\">Keyboard’s Hotkeys</a></td>\n<td><img src=\"https://cimg1.17lai.site/data/2021/08/1820210818223238.gif\" alt=\"\"></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<p>Legend :</p>\n<ul>\n<li>\n<p><img src=\"https://cimg1.17lai.site/data/2021/08/1820210818223249.gif\" alt=\"\"> = OK ;</p>\n</li>\n<li>\n<p><img src=\"https://cimg1.17lai.site/data/2021/08/1820210818223256.gif\" alt=\"\"> Unsupported(No Driver) ;</p>\n</li>\n<li>\n<p><img src=\"https://cimg1.17lai.site/data/2021/08/1820210818223302.gif\" alt=\"\"> = Error (Couldn’t get it working);</p>\n</li>\n<li>\n<p>[?] Unknown, Not Test ;</p>\n</li>\n<li>\n<p>[-] Not-applicable</p>\n</li>\n<li>\n<p><img src=\"https://cimg1.17lai.site/data/2021/08/1820210818223346.gif\" alt=\"\"> = Configuration Required;</p>\n</li>\n<li>\n<p><img src=\"https://cimg1.17lai.site/data/2021/08/1820210818223308.gif\" alt=\"\"> = Only works with a non-free driver/firmware</p>\n</li>\n</ul>\n<h2 id=\"Configuration\">Configuration</h2>\n<h2 id=\"Display\">Display</h2>\n<p>You will need to install the 915resolution package:</p>\n<p># apt-get install 915resolution xserver-xorg-video-intel</p>\n<p># 915resolution</p>\n<p>The 915resolution will try to get highest resolution, you can change this at /etc/default/915resolution.</p>\n<p>If you wish to enable DRI, GLX, etc. see <a href=\"https://wiki.debian.org/InstallingDebianOn/Dell/Inspiron6400/lenny?action=AttachFile&amp;do=view&amp;target=Xorg.conf_Lenny_DellInspiron6400.txt\">Xorg.conf_Lenny_DellInspiron6400.txt</a> . My configuration works fine with <a href=\"https://wiki.debian.org/Compiz\">Compiz</a>.</p>\n<p>If using newer “xserver-xorg” (version 7.3 +), do not install “915resolution” as it conflicts with “xserver-xorg-video-all” and “xserver-xorg-video-intel”. Also install “libgl1-mesa-dri” (and this also installs “libgl1-mesa-glx”) for OpenGL support. Use “glxinfo | grep direct” to check for direct rendering. The “glxinfo” util comes with the “mesa-utils” package. (Thanks to enouf and Nemoder on #debian@OFTC)</p>\n<h2 id=\"Hibernation-and-Sleep-Suspend\">Hibernation and Sleep/Suspend</h2>\n<p>Works fine. Install,</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-none\" data-start=\"1\"><code class=\"language-none\"># apt-get install acpid hal pm-utils uswsusp powermgmt-base</code></pre></div></figure>\n<p>We will need to unload the “b44” module before hibernating, add the following to “/etc/pm/config.d/unload_modules”:</p>\n<p>SUSPEND_MODULES=“b44”</p>\n<p>The wireless drivers will be automatically handled by pm-utils. You should then be able to hibernate:</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-none\" data-start=\"1\"><code class=\"language-none\"># pm-hibernate</code></pre></div></figure>\n<p>And suspend:</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-none\" data-start=\"1\"><code class=\"language-none\"># pm-suspend</code></pre></div></figure>\n<p>Note that if you are trying to hibernate/suspend from within GNOME, you will need to be a member of the &quot; powerdev&quot; group.</p>\n<h2 id=\"CPU-Power-Scaling\">CPU Power Scaling</h2>\n<p>Add a few modules to be loaded,</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\"># echo &quot;acpi-cpufreq&quot; &gt;&gt; &#x2F;etc&#x2F;modules\n# echo &quot;speedstep_centrino&quot; &gt;&gt; &#x2F;etc&#x2F;modules</code></pre></div></figure>\n<p>Then, install the “powernowd” daemon:</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\"># apt-get install powernowd</code></pre></div></figure>\n<p>Powenowd’s default settings should be OK for most people.</p>\n<h2 id=\"Hotkeys\">Hotkeys</h2>\n<p>These are automatically configures by:</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\"># apt-get install hotkey-setup</code></pre></div></figure>\n<h2 id=\"WiFi\">WiFi</h2>\n<p>We need to install the firmware:</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\"># apt-get install firmware-iwlwifi</code></pre></div></figure>\n<p>And it should work. If you get an error like “Kill switch must be turned off in order for wireless networking to work.” during system boot, you need to press the magic Fn + F2 button.</p>\n<h2 id=\"七：其他问题\">七：其他问题</h2>\n<h3 id=\"0-多源混合使用\">0.多源混合使用</h3>\n<p>安装完稳定版系统，请先为整个系统所有软件包设置 hold on 状态，aptitude 可以很容易的完成此任务。 接着，添加多个版本的源，即由上而下依次为： stable stable-backports （当前是 lenny-backports，<a href=\"http://wiki.debian.org/Backports%EF%BC%89\">http://wiki.debian.org/Backports）</a> testing sid experimental， 然后，请针对特定软件包的特定版本升级，注意一次升级一个包彻底解决一个包，勿贪心。 升级完成，再次设置 hold on 状态，如此反复。</p>\n<p>有时需要人工介入满足特定软件包的依赖关系。 如，为了使用 DRI，给 lenny 安装新版 ati 开源驱动 radeon 软件包， 需要先手工升级 mesalib-7.4.<em>、xorg-server-1.6.</em> 等， 再手工安装 radeon 软件包，而不能直接安装 radeon 软件包的新版本， 混用多个版本的源时，aptitude 自动计算的依赖关系并不总是可靠的。</p>\n<p>如果仍不够新，那就要自己动手配置编译。 如果愿意可以使用 debian 方式编译打包。</p>\n<p>如果升级的软件包依赖一些基本的软件包如 glibc，最终得到的系统将不再是 debian 稳定版。</p>\n<ol>\n<li>\n<h3 id=\"自动挂载U盘中文文件名乱码问题\">自动挂载U盘中文文件名乱码问题</h3>\n</li>\n</ol>\n<p>解决方法：系统工具-&gt;配置编辑-&gt;/system/storage/default_options/vfat，双击mount_options，”添加”，在“新列表值”中填入“utf8”。</p>\n<ol start=\"2\">\n<li>\n<h3 id=\"apt-get与dpkg的基本用法\">apt-get与dpkg的基本用法</h3>\n</li>\n</ol>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#apt-get install packagename #安装一个新软件包\n#apt-get remove packagename #卸载一个已安装的软件包（保留配置文件）\n#apt-get --purge remove packagename #卸载一个已安装的软件包（删除配置文件）\n#dpkg --force-all --purge packagename #强制卸载，风险大！\n#apt-get upgrade #更新所有已安装的软件包\n#apt-get dist-upgrade #将系统升级到新版本\n$apt-cache search 正则表达式 #在软件包列表中搜索字符串\n$dpkg -l 正则表达式 #列出所有与模式相匹配的软件包\n#apt-get clean #清理所有软件缓存\n#apt-get autoclean #清理旧版本的软件缓存\n#apt-get autoremove #删除系统不再使用的孤立软件\n#apt-cdrom add #增加一个光盘源\n$dpkg -l |grep ^rc|awk &#39;&#123;print $2&#125;&#39; | #xargs dpkg -P #清除所有已删除包的残馀配置文件\n#auto-apt run .&#x2F;configure #编译时缺少h文件的自动处理</code></pre></div></figure>\n<ol start=\"3\">\n<li>\n<h3 id=\"安装RealPlay\">安装RealPlay</h3>\n</li>\n</ol>\n<p>下载bin包，到realplayer主页上下载 <a href=\"https://www.real.com/linux\">http://www.real.com/linux</a></p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#chmod 755 .&#x2F;*.bin #或chmod +x .&#x2F;*.bin</code></pre></div></figure>\n<p>#./*.bin #一定要root安装，否则安装后无法启动。</p>\n<ol start=\"4\">\n<li>\n<h3 id=\"安装FlashPlayer\">安装FlashPlayer</h3>\n</li>\n</ol>\n<p>在iceweasel提示安装时选择安装，如果安装失败：</p>\n<p>下载install_flash_player_9_linux.tar.gz并解压，进入解压目录，执行</p>\n<p>安装：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">sudo .&#x2F;flashplayer-installer</code></pre></div></figure>\n<p>若flashplayer菜单有乱码问题的话，执行：sudo mv /etc/fonts/conf.d/49-sansserif.conf /etc/fonts/conf.d/49-sansserif.conf.bak</p>\n<p>安装ttf-freefont字体可解决swf文件中文乱码。</p>\n<ol start=\"5\">\n<li>编译Code::Blocks的SVN版本</li>\n</ol>\n<p>(a) 下载源码</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">svn checkout svn:&#x2F;&#x2F;svn.berlios.de&#x2F;codeblocks&#x2F;trunk ~&#x2F;Sources&#x2F;CodeBlocks</code></pre></div></figure>\n<p>(b) 编译</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">export ACLOCAL_FLAGS&#x3D;&quot;-I &#96;wx-config --prefix&#96;&#x2F;share&#x2F;aclocal&quot;\n\n.&#x2F;bootstrap\n\n.&#x2F;configure 或 .&#x2F;configure --with-contrib-plugins&#x3D;all\n\nmake\n\nsudo make install</code></pre></div></figure>\n<p>© 缷载</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">sudo make uninstall</code></pre></div></figure>\n<p>(d) 重新编译</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">make clean\nmake distclean\nmake clean-bin\nmake clean-zipfiles</code></pre></div></figure>\n<p>详情：<a href=\"https://wiki.codeblocks.org/index.php?title=Installing_Code::Blocks_from_source_on_Linux\">http://wiki.codeblocks.org/index.php…ource_on_Linux</a></p>\n<p>●   关于64位系统使用32位软件额外需求</p>\n<p>64位系统同样能使用32位的软件，只要在终端输入以下命令，安装相应的32位包：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">sudo apt-get install ia32-libs ia32-libs-gtk linux32 lib32asound2</code></pre></div></figure>\n<h2 id=\"●-MLdonkey-sancho安装\">●   MLdonkey+sancho安装</h2>\n<p>MLdonkey被誉为<a href=\"https://forum.ubuntu.org.cn/viewtopic.php?t=42337&amp;highlight=mldonkey\">速度最快的电驴</a>，同时支持很多种P2P的下载协议，包括edonkey2000、gnutella、gnutella2、bt、FileTP</p>\n<p>等等。网上有很多安装和设置的文章，但是有点乱，有些也不够完整，今天有空将它整理如下</p>\n<p>下载最新版 <a href=\"https://sourceforge.net/project/showfiles.php?group_id=156414&amp;package_id=174487\">MLdonkey</a> &amp; <a href=\"https://sancho-gui.sourceforge.net/download.phtml\">sancho</a>（左键点击）</p>\n<h3 id=\"一-安装-mldonkey：\">一.安装 mldonkey：</h3>\n<p>解压缩mldonkey源代码并进入其目录，然后</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">$ sudo apt-get install ocaml\n$ .&#x2F;configure\n$ make\n$ make install</code></pre></div></figure>\n<p>（使用新版本的mldonkey源代码编译安装后已不会有下载后文件名不支持中文的问题）</p>\n<h3 id=\"二-安装-sancho：\">二.安装 sancho：</h3>\n<p>sancho是mldonkey最好用的一个前端，下载回来的sancho只有一个文件，是一个脚本，先右键单击它，找到属性-权限部分，钩上“可执行”，然后在终端中运行之：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">$ .&#x2F;sancho-*-linux-gtk.sh</code></pre></div></figure>\n<p>然后会显示</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">Extract to directory [&lt;sancho-*-linux-gtk&gt;]:</code></pre></div></figure>\n<p>输入自定义安装目录，随便你，我安装在/usr/local/sancho</p>\n<p>稍等一会就装好了，在/usr/local/sancho/下有个sancho，双击它就能运行sancho</p>\n<p># 下载 sancho 后用 root权限安装</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">user@~$ sudo sh sancho-0.9.4-59-linux-gtk.sh</code></pre></div></figure>\n<p># 选择安装目录, 这里我安装在 /opt/sancho/</p>\n<p># 修改用户配置文件目录的权限</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">user@~$ sudo chown user:user -R ~&#x2F;.sancho&#x2F;</code></pre></div></figure>\n<p># 把 user 改成自己的用户名</p>\n<h3 id=\"三-sancho设置\">三.sancho设置</h3>\n<p>先运行mlnet，在/usr/local/bin或/usr/bin下，然后运行sancho，首次运行会有配置向导，需要设置mlnet位置。在sancho里面也可以设置mlnet的运行路径</p>\n<p>在<strong>工具</strong>-&gt;<strong>首选项</strong>-&gt;**sancho:**<strong>主要</strong>-&gt;<strong>可选的可执行core</strong> 那里填上你的mlnet路径。这样以后就可以直接启动sancho。</p>\n<p>设置中文: 在<strong>工具</strong>-&gt;<strong>首选项</strong>-&gt;**sancho:**<strong>主要</strong>-&gt;<strong>使用本地文件</strong> 选择zh-CN,重启sancho后即为中文。</p>\n<p>在<strong>工具</strong>-&gt;<strong>首选项</strong>-&gt;<strong>Main</strong> 设置 <strong>client_name</strong> 推荐设置成[CHN][VeryCD]<strong>yourname</strong>的形式，支持中文。</p>\n<p>在<strong>工具</strong>-&gt;<strong>首选项</strong>-&gt;<strong>Bandwidth</strong> 设置 <strong>max_hard_upload_rate</strong> 和 <strong>max_hard_download_rate</strong> 分别是上传和下载速度，单位是KB</p>\n<p>在<strong>工具</strong>-&gt;<strong>首选项</strong>-&gt;<strong>Networks</strong> 勾选 <strong>enable_overnet</strong> 和 <strong>enable_kademlia</strong></p>\n<p>在<strong>工具</strong>-&gt;<strong>首选项</strong>-&gt;<strong>Networks</strong>-&gt;<strong>Donkey</strong>有这两项：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">ED2K-force_client_high_id\nED2K-force_high_id</code></pre></div></figure>\n<p>如果你是公网用户，或者你是内网，且设置了端口映射，则勾选它们，如果你打死都是内网低ID用户，就不要选了，否则会很难连上服务器。</p>\n<p>你可以选上试试看，不行再取消。</p>\n<p>在<strong>工具</strong>-&gt;<strong>首选项</strong>-&gt;<strong>Networks</strong>-&gt;<strong>Donkey</strong>-&gt;<strong>ED2K-port</strong> 设置端口，如果你有windows下的emule，最好把他们的端口(tcp的)设成一样，因为有些路由器有记忆功能，导致windows下的端口在重启后仍然保留。一般emule默认端口为4662,但有些宽带运营商会封掉该端口，建议改掉。</p>\n<p>在<strong>工具</strong>-&gt;<strong>首选项</strong>-&gt;<strong>Networks</strong>-&gt;<strong>Donkey</strong>-&gt;<strong>ED2K-max_connected_servers</strong> 设置服务器最大连接数，默认为3，不用太大，大了也没用，一般稳定下来也就三四个左右，我把它设为7</p>\n<p>打开sancho主界面，点击控制台，然后在最下方的命令输入框那里</p>\n<p>用如下命令导入服务器</p>\n<p>servers <a href=\"http://www.emule.org.cn/server.met\">http://www.emule.org.cn/server.met</a></p>\n<p>用ov_load命令导入overnet的node列表，推荐下载<a href=\"https://download.overnet.org/contact.dat\">http://download.overnet.org/contact.dat</a></p>\n<p>用kad_load命令导入kad的node列表，推荐下载<a href=\"https://www.emule-inside.net/nodes.dat\">http://www.emule-inside.net/nodes.dat</a></p>\n<p>或<a href=\"https://renololo1.free.fr/e/nodes.dat\">http://renololo1.free.fr/e/nodes.dat</a>，也可使用eMule的nodes.data</p>\n<p>对于ov_load和kad_load，需要先下载回本地，比如把contact.dat下载到桌面后，输入：</p>\n<p>ov_load /home/xxb/桌面/contact.dat</p>\n<p>路径请修改为适合你自己的。</p>\n<p>修改下载目录和temp目录: 默认目录分别为 ~/.mldonkey/incoming/files （BT则为~/.mldonkey/incoming/directories) 和 ~/.mldonkey/temp</p>\n<p>修改 ~/.mldonkey/downloads.ini，找到“SECTION : Paths”，然后修改第一段和倒数第二段的路径，注意这里是相对路径。下载目录和temp目录最好放在同一个硬盘分区，否则下载完成转移临时文件时，硬 盘灯会狂闪。或者通过建立软链接来更改下载目录也可以（推荐）。</p>\n<p>比如我把下载目录和临时目录都移到/home/xxb/Videos/下，则把~/.mldonkey/下的incoming和temp目录都剪切到/home/xxb/Videos/下，然后建立软链接：</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">$ ln -s ~&#x2F;Videos&#x2F;incoming ~&#x2F;.mldonkey&#x2F;incoming\n\n$ ln -s ~&#x2F;Videos&#x2F;temp ~&#x2F;.mldonkey&#x2F;temp</code></pre></div></figure>\n<h3 id=\"四-设置浏览器关联\">四.设置浏览器关联</h3>\n<p>这里只说firefox的关联，如果需要设置其它浏览器，请参考<a href=\"https://forum.ubuntu.org.cn/viewtopic.php?t=47733&amp;highlight=mldonkey+%E5%85%B3%E8%81%94\">mldonkey 和浏览器关联的办法,适用 firefox, konqueror</a></p>\n<p>先建立脚本,这里我们把它取名为 submit, 放在 ~/.mldonkey 下面。内容如下:</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-none\" data-start=\"1\"><code class=\"language-none\">#!&#x2F;bin&#x2F;bash\n\necho dllink $*|nc -q 1 127.0.0.1 4000</code></pre></div></figure>\n<p>如果系统是ArchLinux，则需安装netcat(gnu-netcat),并改为</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-none\" data-start=\"1\"><code class=\"language-none\">#!&#x2F;bin&#x2F;bash\n\necho dllink $*|nc 127.0.0.1 4000</code></pre></div></figure>\n<p>然后右键单击它，找到属性-权限部分，钩上“可执行”</p>\n<p>接下来在firefox地址栏输入 about:config</p>\n<p>新建 字符串(string)</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-none\" data-start=\"1\"><code class=\"language-none\">network.protocol-handler.app.ed2k</code></pre></div></figure>\n<p>值为submit 脚本的位置，比如我的是 /home/xxb/.mldonkey/submit</p>\n<p>也可以安装firefox扩展，以关联ed2k、bt等，解压后的mldoneky-distrib-xxx/ed2k_mozilla/文件夹下 有个 mldonkey_protocol_handler-xx.xpi，把它拖到fx窗口选择安装。重启后就可以双击MLdonkey Protocal Handler这个扩展设置关联了，这个扩展也可以关联到amule。不过扩展当然是能不装就不装，所以推荐使用submit脚本的方法。</p>\n<h3 id=\"五-WEB界面\">五.WEB界面</h3>\n<p>你也可以用浏览器控制和观察mldonkey，地址是 <a href=\"https://localhost:4080/\">http://localhost:4080/</a></p>\n<p>我比较推崇用这个，不占额外资源（不必一直开着sancho，毕竟java的东西会占不少内存和cpu），设置更强，不过是英文的。你还可以编辑~/.mldonkey下的各个文件进行设置，这里不再敖述。</p>\n<h3 id=\"六-端口映射\">六.端口映射</h3>\n<p>打开 <a href=\"https://localhost:4080/\">http://localhost:4080/</a>后，点击<strong>Help+</strong>-&gt;<strong>Sysinfo</strong> 这里可以查看mldonkey的端口使用情况，除了core那3个，建议其余的都在路由器里设置端口映射，如果有防火墙，还要打开相应端口。</p>\n<p><a href=\"https://www.emule.org.cn/topic/nat/\">点击查看各种主流路由器映射的设置方法</a></p>\n<h3 id=\"七-其它\">七.其它</h3>\n<p>本文基本只涉及电驴部分，如果还需要其它比如BT功能，请自行摸索，附一些主要的配置文件：</p>\n<ul>\n<li>\n<p>~/.mldonkey/downloads.ini 基本的设置( 这个是for edonkey和其他协议的)</p>\n</li>\n<li>\n<p>~/.mldonkey/servers.ini 服务器列表文件</p>\n</li>\n<li>\n<p>~/.mldonkey/files.ini 当前已经完成的和未完成的文件列表</p>\n</li>\n<li>\n<p>~/.mldonkey/friends.ini 好友列表</p>\n</li>\n<li>\n<p>~/.mldonkey_gui.ini 图形前端的配置文件</p>\n</li>\n</ul>\n<p>另外其他的网络协议都有其单独的配置文件，一般都放在~/.mldonkey目录下</p>\n<p>祝骑驴愉快 <sup>_</sup></p>\n<link rel=\"stylesheet\" href=\"https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css\"><script src=\"https://fastly.jsdelivr.net/npm/d3@7\"></script><script src=\"https://fastly.jsdelivr.net/npm/markmap-view@0.18.10\"></script><script src=\"https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10\"></script>\n<link rel=\"stylesheet\" href=\"/css/markmap.css\">\n\n<script src=\"/js/markmap.js\"></script>\n",
            "tags": [
                "driver",
                "debian",
                "laptop",
                "ed2k",
                "ati"
            ]
        },
        {
            "id": "https://blog.17lai.site/posts/7b4e434c/",
            "url": "https://blog.17lai.site/posts/7b4e434c/",
            "title": "宝塔linux面板重启、重置等命令整合",
            "date_published": "2021-07-31T11:25:00.000Z",
            "content_html": "<h2 id=\"宝塔linux面板重启、重置等命令整合\">宝塔linux面板重启、重置等命令整合</h2>\n<p>宝塔对新手入门还是比较友好的，方便了入门小站搭建。入门可用，一些新东西也可以在里面看看。大型应用还是的自己搭建。</p>\n<p>来源于网络，原作已经不可考据，整理更新到目前最新版。</p>\n<p>现在有很多网友都在使用宝塔主机管理系统、对一些不懂linux操作的朋友来说，是一个很好的管理系统、但是有些朋友重启服务器以后，有可能造成一些服务无法重启。今天我们搜集下关于宝塔面板的命令集锦</p>\n<h2 id=\"Linux面板7-6-0安装命令：\"><strong>Linux面板7.6.0安装命令：</strong></h2>\n<h3 id=\"Centos安装命令：\"><strong>Centos安装命令：</strong></h3>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">yum install -y wget &amp;&amp; wget -O install.sh http:&#x2F;&#x2F;download.bt.cn&#x2F;install&#x2F;install_6.0.sh &amp;&amp; sh install.sh</code></pre></div></figure>\n<p><a href=\"https://www.bt.cn/offline\">咨询离线安装版本</a></p>\n<p><strong>试验性Centos/Ubuntu/Debian安装命令</strong> <strong>独立运行环境（py3.7） 可能存在少量兼容性问题 不断优化中</strong></p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">curl -sSO http:&#x2F;&#x2F;download.bt.cn&#x2F;install&#x2F;install_panel.sh &amp;&amp; bash install_panel.sh</code></pre></div></figure>\n<h3 id=\"Ubuntu-Deepin安装命令：\"><strong>Ubuntu/Deepin安装命令：</strong></h3>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">wget -O install.sh http:&#x2F;&#x2F;download.bt.cn&#x2F;install&#x2F;install-ubuntu_6.0.sh &amp;&amp; sudo bash install.sh</code></pre></div></figure>\n<h3 id=\"Debian安装命令：\"><strong>Debian安装命令：</strong></h3>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">wget -O install.sh http:&#x2F;&#x2F;download.bt.cn&#x2F;install&#x2F;install-ubuntu_6.0.sh &amp;&amp; bash install.sh</code></pre></div></figure>\n<h3 id=\"Fedora安装命令\"><strong>Fedora安装命令:</strong></h3>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">wget -O install.sh http:&#x2F;&#x2F;download.bt.cn&#x2F;install&#x2F;install_6.0.sh &amp;&amp; bash install.sh</code></pre></div></figure>\n<p><strong>Linux面板7.6.0升级命令：</strong><code>curl http://download.bt.cn/install/update6.sh|bash</code></p>\n<p>以上节点无法使用的情况下，请使用下面的备用节点：</p>\n<h3 id=\"备用节点【香港】：\"><strong>备用节点【香港】：</strong></h3>\n<p><strong>（宝塔推荐使用CN2 双程GIA高品质，免备案的</strong><a href=\"https://www.zun.com/server/buy.html?lineid=1671157323431053\"><strong>尊云zun.com</strong></a><strong>香港云服务器安装）</strong></p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">yum install -y wget &amp;&amp; wget -O install.sh http:&#x2F;&#x2F;103.224.251.67:5880&#x2F;install&#x2F;install_6.0.sh &amp;&amp; sh install.sh</code></pre></div></figure>\n<h2 id=\"管理宝塔\">管理宝塔</h2>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#停止\n&#x2F;etc&#x2F;init.d&#x2F;bt stop\n#启动\n&#x2F;etc&#x2F;init.d&#x2F;bt start\n#重启\n&#x2F;etc&#x2F;init.d&#x2F;bt restart\n#卸载\n&#x2F;etc&#x2F;init.d&#x2F;bt stop &amp;&amp; chkconfig --del bt &amp;&amp; rm -f &#x2F;etc&#x2F;init.d&#x2F;bt &amp;&amp; rm -rf &#x2F;www&#x2F;server&#x2F;panel\n#查看当前面板端口\ncat &#x2F;www&#x2F;server&#x2F;panel&#x2F;data&#x2F;port.pl\n#修改面板端口，如要改成8881（centos 6  系统）\necho &#39;8881&#39;  &gt;  &#x2F;www&#x2F;server&#x2F;panel&#x2F;data&#x2F;port.pl &amp;&amp;  &#x2F;etc&#x2F;init.d&#x2F;bt restart\niptables -I INPUT -p tcp -m state --state NEW -m tcp --dport 8881  -j ACCEPT\nservice iptables save\nservice iptables restart\n#修改面板端口，如要改成8881（centos 7  系统）\necho &#39;8881&#39;  &gt;  &#x2F;www&#x2F;server&#x2F;panel&#x2F;data&#x2F;port.pl &amp;&amp;  &#x2F;etc&#x2F;init.d&#x2F;bt restart\nfirewall-cmd --permanent --zone&#x3D;public  --add-port&#x3D;8881&#x2F;tcp\nfirewall-cmd --reload\n#强制修改MySQL管理(root)密码，如要改成123456\ncd &#x2F;www&#x2F;server&#x2F;panel &amp;&amp; python tools.pyc root 123456\n#修改面板密码，如要改成123456\ncd &#x2F;www&#x2F;server&#x2F;panel &amp;&amp; python tools.pyc panel 123456\n#查看宝塔日志\ncat &#x2F;tmp&#x2F;panelBoot.pl\n#查看软件安装日志\ncat &#x2F;tmp&#x2F;panelExec.log\n#站点配置文件位置\n&#x2F;www&#x2F;server&#x2F;panel&#x2F;vhost\n#删除域名绑定面板\nrm -f &#x2F;www&#x2F;server&#x2F;panel&#x2F;data&#x2F;domain.conf\n#清理登陆限制\nrm -f &#x2F;www&#x2F;server&#x2F;panel&#x2F;data&#x2F;*.login\n#查看面板授权IP\ncat &#x2F;www&#x2F;server&#x2F;panel&#x2F;data&#x2F;limitip.conf\n#关闭访问限制\nrm -f &#x2F;www&#x2F;server&#x2F;panel&#x2F;data&#x2F;limitip.conf\n#查看许可域名\ncat &#x2F;www&#x2F;server&#x2F;panel&#x2F;data&#x2F;domain.conf\n#关闭面板SSL\nrm -f &#x2F;www&#x2F;server&#x2F;panel&#x2F;data&#x2F;ssl.pl &amp;&amp; &#x2F;etc&#x2F;init.d&#x2F;bt restart\n#查看面板错误日志\ncat &#x2F;tmp&#x2F;panelBoot\n#查看数据库错误日志\ncat &#x2F;www&#x2F;server&#x2F;data&#x2F;*.err\n#站点配置文件目录(nginx)\n&#x2F;www&#x2F;server&#x2F;panel&#x2F;vhost&#x2F;nginx\n#站点配置文件目录(apache)\n&#x2F;www&#x2F;server&#x2F;panel&#x2F;vhost&#x2F;apache\n#站点默认目录\n&#x2F;www&#x2F;wwwroot\n#数据库备份目录\n&#x2F;www&#x2F;backup&#x2F;database\n#站点备份目录\n&#x2F;www&#x2F;backup&#x2F;site\n#站点日志\n&#x2F;www&#x2F;wwwlogs\n# 执行宝塔Linux面板升级命令\ncurl https:&#x2F;&#x2F;download.bt.cn&#x2F;install&#x2F;update_panel.sh|bash</code></pre></div></figure>\n<h2 id=\"Nginx服务管理\">Nginx服务管理</h2>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#nginx安装目录\n&#x2F;www&#x2F;server&#x2F;nginx\n#启动\n&#x2F;etc&#x2F;init.d&#x2F;nginx start\n#停止\n&#x2F;etc&#x2F;init.d&#x2F;nginx stop\n#重启\n&#x2F;etc&#x2F;init.d&#x2F;nginx restart\n#启载\n&#x2F;etc&#x2F;init.d&#x2F;nginx reload\n#nginx配置文件\n&#x2F;www&#x2F;server&#x2F;nginx&#x2F;conf&#x2F;nginx.conf</code></pre></div></figure>\n<h2 id=\"Apache服务管理\">Apache服务管理</h2>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#apache安装目录\n&#x2F;www&#x2F;server&#x2F;httpd\n#启动\n&#x2F;etc&#x2F;init.d&#x2F;httpd start\n#停止\n&#x2F;etc&#x2F;init.d&#x2F;httpd stop\n#重启\n&#x2F;etc&#x2F;init.d&#x2F;httpd restart\n#启载\n&#x2F;etc&#x2F;init.d&#x2F;httpd reload\n#apache配置文件\n&#x2F;www&#x2F;server&#x2F;apache&#x2F;conf&#x2F;httpd.conf</code></pre></div></figure>\n<h2 id=\"MySQL服务管理\">MySQL服务管理</h2>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#mysql安装目录\n&#x2F;www&#x2F;server&#x2F;mysql\n#phpmyadmin安装目录\n&#x2F;www&#x2F;server&#x2F;phpmyadmin\n#数据存储目录\n&#x2F;www&#x2F;server&#x2F;data\n#启动\n&#x2F;etc&#x2F;init.d&#x2F;mysqld start\n#停止\n&#x2F;etc&#x2F;init.d&#x2F;mysqld stop\n#重启\n&#x2F;etc&#x2F;init.d&#x2F;mysqld restart\n#启载\n&#x2F;etc&#x2F;init.d&#x2F;mysqld reload\n#mysql配置文件\n&#x2F;etc&#x2F;my.cnf</code></pre></div></figure>\n<h2 id=\"FTP服务管理\">FTP服务管理</h2>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#ftp安装目录\n&#x2F;www&#x2F;server&#x2F;pure-ftpd\n#启动\n&#x2F;etc&#x2F;init.d&#x2F;pure-ftpd start\n#停止\n&#x2F;etc&#x2F;init.d&#x2F;pure-ftpd stop\n#重启\n&#x2F;etc&#x2F;init.d&#x2F;pure-ftpd restart\n#ftp配置文件\n&#x2F;www&#x2F;server&#x2F;pure-ftpd&#x2F;etc&#x2F;pure-ftpd.conf</code></pre></div></figure>\n<h2 id=\"PHP服务管理\">PHP服务管理</h2>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#php安装目录\n&#x2F;www&#x2F;server&#x2F;php\n#启动(请根据安装PHP版本号做更改，例如：&#x2F;etc&#x2F;init.d&#x2F;php-fpm-54 start)\n&#x2F;etc&#x2F;init.d&#x2F;php-fpm-&#123;52|53|54|55|56|70|71&#125; start\n#停止(请根据安装PHP版本号做更改，例如：&#x2F;etc&#x2F;init.d&#x2F;php-fpm-54 stop)\n&#x2F;etc&#x2F;init.d&#x2F;php-fpm-&#123;52|53|54|55|56|70|71&#125; stop\n#重启(请根据安装PHP版本号做更改，例如：&#x2F;etc&#x2F;init.d&#x2F;php-fpm-54 restart)\n&#x2F;etc&#x2F;init.d&#x2F;php-fpm-&#123;52|53|54|55|56|70|71&#125; restart\n#启载(请根据安装PHP版本号做更改，例如：&#x2F;etc&#x2F;init.d&#x2F;php-fpm-54 reload)\n&#x2F;etc&#x2F;init.d&#x2F;php-fpm-&#123;52|53|54|55|56|70|71&#125; reload\n#配置文件(请根据安装PHP版本号做更改，例如：&#x2F;www&#x2F;server&#x2F;php&#x2F;52&#x2F;etc&#x2F;php.ini)\n&#x2F;www&#x2F;server&#x2F;php&#x2F;&#123;52|53|54|55|56|70|71&#125;&#x2F;etc&#x2F;php.ini</code></pre></div></figure>\n<h2 id=\"Redis服务管理\">Redis服务管理</h2>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#redis安装目录\n&#x2F;www&#x2F;server&#x2F;redis\n#启动\n&#x2F;etc&#x2F;init.d&#x2F;redis start\n#停止\n&#x2F;etc&#x2F;init.d&#x2F;redis stop\n#redis配置文件\n&#x2F;www&#x2F;server&#x2F;redis&#x2F;redis.conf</code></pre></div></figure>\n<h2 id=\"Memcached服务管理\">Memcached服务管理</h2>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#memcached安装目录\n&#x2F;usr&#x2F;local&#x2F;memcached\n#启动\n&#x2F;etc&#x2F;init.d&#x2F;memcached start\n#停止\n&#x2F;etc&#x2F;init.d&#x2F;memcached stop\n#重启\n&#x2F;etc&#x2F;init.d&#x2F;memcached restart\n#启载\n&#x2F;etc&#x2F;init.d&#x2F;memcached reload</code></pre></div></figure>\n<h2 id=\"参考\">参考</h2>\n<ul>\n<li><a href=\"https://www.bt.cn/new/btcode.html\">bt doc</a></li>\n<li><a href=\"https://www.kancloud.cn/chudong/bt2017\">宝塔面板手册</a></li>\n</ul>\n<h2 id=\"附赠\">附赠</h2>\n<h3 id=\"强制升级宝塔数据库版本\">强制升级宝塔数据库版本</h3>\n<p>方法一</p>\n<ol>\n<li>\n<p>打开/www/server/panel/class目录下的panelPlugin.py文件</p>\n</li>\n<li>\n<p>修改如下所示的部分代码</p>\n</li>\n</ol>\n<p>注释下面代码</p>\n<p>8.0.0版本约802行</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-python\" data-language=\"python\" data-start=\"1\"><code class=\"language-python\">if not self.check_mem_limit(versionInfo[&#39;mem_limit&#39;]):\n    return public.returnMsg(\n        False,\n        &#39;至少需要[%dMB]内存才能安装&#39; % versionInfo[&#39;mem_limit&#39;])</code></pre></div></figure>\n<ol start=\"3\">\n<li>重启宝塔面板</li>\n</ol>\n<p>此时就可以顺利升级数据库版本了！</p>\n<p>方法二：修改宝塔面板文件<code>/www/server/panel/date/plugin.json</code>在宝塔面板文件中找到<code>/www/server/panel/date</code>，修改<code>plugin.json</code>文件。搜索</p>\n<p><code>/www/server/mysql/bin/mysql</code></p>\n<p>根据所要安装的mysql版本修改对应的配置，mem_limit是内存限制，CPU_limit是CPU限制。将对应值修改为小于你服务器你内存或者CPU的值。</p>\n<link rel=\"stylesheet\" href=\"https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css\"><script src=\"https://fastly.jsdelivr.net/npm/d3@7\"></script><script src=\"https://fastly.jsdelivr.net/npm/markmap-view@0.18.10\"></script><script src=\"https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10\"></script>\n<link rel=\"stylesheet\" href=\"/css/markmap.css\">\n\n<script src=\"/js/markmap.js\"></script>\n",
            "tags": [
                "linux",
                "宝塔",
                "vps",
                "建站",
                "nginx",
                "apache",
                "mysql"
            ]
        },
        {
            "id": "https://blog.17lai.site/posts/bb600b4b/",
            "url": "https://blog.17lai.site/posts/bb600b4b/",
            "title": "PT 工具集，Linux硬链接助手",
            "date_published": "2021-07-09T09:25:00.000Z",
            "content_html": "<p>由于自我需求，写了两个脚本完成PT下载和保种两全其美的硬链接 Linux shell 脚本方案。</p>\n<h2 id=\"PTtool\">PTtool</h2>\n<blockquote>\n<p>Github: <a href=\"https://github.com/appotry/PTtool\">appotry/PTtool</a></p>\n<p>纯Bash Shell硬链接工具！支持所有Linux， BSD， Mac，<strong>群辉</strong>，<strong>威联通</strong>等支持标准Shell的操作系统！</p>\n</blockquote>\n<hr>\n<h2 id=\"PT工具集合\">PT工具集合</h2>\n<ul>\n<li><a href=\"https://github.com/appotry/PTtool/\">硬链接工具</a> 自动硬链接工具</li>\n<li><a href=\"https://github.com/appotry/flexget-nexusphp\">flexget-nexusphp</a>, 自动下载刷流工具。Flexget插件，增强对NexusPHP的过滤</li>\n<li><a href=\"https://github.com/nastool/nas-tools\">nas-tools</a> <a href=\"https://github.com/wangyan/nas-tools\">源码备份</a>，<strong>已经停止开发</strong>！<strong>注意</strong>暂时功能不够完善，Bug较多，评价是试用，尝鲜，还不能胜任主力！后续Bug得不到修正，强烈建议切换到Sonarr，radarr，flexget。</li>\n<li><a href=\"https://github.com/jxxghp/MoviePilot\">MoviePilot</a> nas-tools 作者重构项目，提升了速度，在功能，bug稳定性方面还待提升。可以提前试用</li>\n<li><a href=\"https://github.com/ngfchl/ptools\">PTools</a> 一个新的自动签到，种子推送工具，刚出来，可以关注</li>\n<li><a href=\"https://github.com/appotry/IYUUAutoReseed\">IYUUAutoReseed</a> 自动辅种助手。<strong>PT三剑客</strong></li>\n<li><a href=\"https://github.com/appotry/PT-Plugin-Plus\">PTPP</a> 浏览器辅种助手。<strong>PT三剑客</strong></li>\n<li><a href=\"https://hub.docker.com/r/crazyq/pt_helper\">pt_helper</a>, <strong>非开源软件</strong> 自动刷流与签到。<strong>PT三剑客</strong> <a href=\"https://github.com/jxxghp/nas-tools\">nas-tools</a>可以替代刷流</li>\n<li><a href=\"https://github.com/appotry/universal-torrent-gallery\">PT站生成海报墙</a></li>\n<li><a href=\"https://github.com/appotry/easy-upload\">一键转种脚本</a> PT一键转种脚本（树大版）</li>\n<li><a href=\"https://github.com/appotry/PT_signin\">PT_signin PT自动签到 Github Action 版</a></li>\n<li><a href=\"https://github.com/appotry/flexget_qbittorrent_mod\">flexget qbittorrent删种、辅种 自动签到 插件</a></li>\n<li><a href=\"https://github.com/dongshuyan/Auto_Upload\">Auto_Upload 自动发种机</a> 全自动将本地资源发布到 PT 站并自动辅种   <a href=\"https://pypi.org/project/auto-upload/\">使用教程</a></li>\n<li><a href=\"https://github.com/dongshuyan/Upload_Machine\">Upload_Machine 自动将本地资源发布到PT站</a> 看简介比 Auto_Upload 功能更强大</li>\n<li><a href=\"https://github.com/Nriver/qb-rss-manager\">qBittorrent rss订阅规则管理</a></li>\n<li><a href=\"https://github.com/MkvAutoSubset/MkvAutoSubset\">Mkv Auto Subset</a> ASS字幕字体子集化 MKV批量提取/生成</li>\n<li><a href=\"https://github.com/LuckyPuppy514/jproxy\">jproxy</a> 优化 Sonarr 对资源的识别率，主要是针对动漫</li>\n<li><a href=\"https://xarr-doc.52nyg.com/xarr-rss/#/\">xarr-rss</a> 剧情Rss订阅处理器 目前非开源？</li>\n<li><a href=\"https://github.com/inerfire/pter_scripts\">pter 猫站使用脚本集合</a></li>\n<li><a href=\"https://github.com/EstrellaXD/Auto_Bangumi\">auto-bangumi 基于Mikan Project的中文自动追番解决方案</a> 解决中文自动追番痛点</li>\n<li><a href=\"https://github.com/RanKKI/BangumiBot\">BangumiBot</a> 类似auto-bangumi的中文自动追番工具，只是auto-bangumi支持Qbittorrent，BangumiBot支持Aria2/Tr</li>\n<li><a href=\"https://github.com/bpking1/embyExternalUrl\">embyExternalUrl</a> Emby调用外部播放器播放视频，以使用本地解码能力</li>\n<li><a href=\"https://github.com/gnehs/subtitle-translator-electron\">subtitle-translator-electron</a> Translate subtitle using ChatGPT，使用ChatGPT翻译字幕</li>\n</ul>\n<h2 id=\"相关教程\">相关教程</h2>\n<ul>\n<li><a href=\"/posts/9806d7f1/\">从零开始玩PT-入门到精通</a></li>\n<li><a href=\"/posts/dc1c8194/\">如何建立自己的私人电子图书馆–出版书籍，网络小说，漫画一网打尽!</a></li>\n<li><a href=\"/posts/db7bf49b/\">视频图书和音乐完全自动化管理框架图解</a></li>\n<li><a href=\"/posts/e6d40157/\">如何使用tinyMediaManager刮削电影和电视剧，动画，并自动下载字幕</a></li>\n<li><a href=\"/posts/9912bd5d/\">使用jeckett,sonarr,iyuu,qt,emby打造全自动追剧流程</a></li>\n<li><a href=\"/posts/dc1c8194/\">如何建立自己的私人电子图书馆–出版书籍，网络小说，漫画一网打尽!</a></li>\n<li><a href=\"/posts/f6b32521/\">qBittorrent 参数详细设置教程</a></li>\n<li><a href=\"/posts/8f76d9dd/\">transmission 使用及其配置</a></li>\n<li><a href=\"/posts/2f8fb473/\">Potplayer终极优化教程实现PC视频播放最强画质</a></li>\n</ul>\n<h3 id=\"框架自动化构架图解\">框架自动化构架图解</h3>\n<ul>\n<li>点击放大<br>\n<a href=\"https://cimg1.17lai.site/data/2022/05/09/20220509113832.webp\"><img src=\"https://cimg1.17lai.site/data/2022/05/09/20220509113832.webp\" alt=\"框架自动化构架图解\"></a></li>\n</ul>\n<pre><code class=\"mermaid\">graph LR\n    1[Sonarr &#x2F; Radarr] &#x3D;&#x3D; 请求 Jackett &#x2F; Prowlarr Torznab 接口 &#x3D;&#x3D;&gt; 2(JProxy) &#x3D;&#x3D; 代理 Sonarr &#x2F; Radarr 请求 &#x3D;&#x3D;&gt; 3(Jackett &#x2F; Prowlarr) \n\n    3(Jackett &#x2F; Prowlarr) &#x3D;&#x3D; 返回原始结果 &#x3D;&#x3D;&gt; 2(JProxy) &#x3D;&#x3D; 返回格式化结果 &#x3D;&#x3D;&gt; 1(Sonarr &#x2F; Radarr)\n    \n    2(JProxy) &#x3D;&#x3D; 优化查询关键字 &#x3D;&#x3D;&gt; 2(JProxy)\n    2(JProxy) &#x3D;&#x3D; 格式化查询结果 &#x3D;&#x3D;&gt; 2(JProxy)</code></pre>\n<p>jproxy 使用图解</p>\n<h2 id=\"硬链接工具\">硬链接工具</h2>\n<hr>\n<h2 id=\"设计目的\">设计目的</h2>\n<p>方便PT用户硬链接文件，在最大可能情况下节约空间，并保持做种。小于1M的文件直接复制，方便emby，tmm等工具刮削修改nfo等小文件。大于1M的文件硬链接到目的目录，可以修改文件名，但是不能修改文件内容！</p>\n<p>例如：<br>\n/share/Download/src #保存下载的PT文件<br>\n/share/Download/dst #保存你自己处理过的视频文件，把emby，tmm的目录设置到dst下面下载脚本后chmod +x mklink.sh给与执行权限使用mklink脚本修改如下，<a href=\"http://xn--mklink-9h6j334h9rzb9lqp0cw3s.sh\">然后直接运行mklink.sh</a>。就可以把src下面的文件全部硬链接到dst目录。mklink适合一次性把源文件夹链接到目的文件夹</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-none\" data-start=\"1\"><code class=\"language-none\">SRC&#x3D;&quot;&#x2F;share&#x2F;Download&#x2F;src&quot;\nDST&#x3D;&quot;&#x2F;share&#x2F;Download&#x2F;dst&quot;</code></pre></div></figure>\n<p>注意：</p>\n<blockquote>\n<p>源目录，目的目录需要在一个硬盘分区里面。硬链接不能跨分区。</p>\n<p>硬链接过的文件可以使用mv来修改存储目录，不影响硬链接效果。但是cp会增加一份存储空间。所以对于已经硬链接过的文件，使用mv，不要使用cp。</p>\n</blockquote>\n<h2 id=\"解决的问题\">解决的问题</h2>\n<p>tmm，emby刮削的时候，必定修改nfo文件，下载的封面等图片不同刮削站点都不同，所以小文件复制，不怕修改。大文件硬链接，占有一份空间被硬链接过的文件，同时存在多个地方，但是都指向一个存储空间，只有所有的硬链接都删除了，这个文件才会被系统删除。同时，所有的硬链接文件，修改其中一个，其它所有指向这个位置的硬链接文件都被修改了。</p>\n<h2 id=\"使用说明\">使用说明</h2>\n<p>下载资源目录/share/Download，qbittorrent资源分类下载到/share/Download/src/下面的各个子目录，例如tv, anime, tv, movie, 4k, soft等等创建一个资源整理使用目录/share/Download/dst/目录，然后就可以把/share/Download/src和/share/Download/dst目录作为下面2个脚本的输入目录，来使用了</p>\n<p>小文件直接复制，方便tmm刮削修改nfo文件，大文件硬链接，只占有一份空间，但有2分文件，可以改名，移动目录，方便tmm整理刮削。 做种，emby使用两不误！</p>\n<h3 id=\"建议目录结构\">建议目录结构</h3>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-none\" data-start=\"1\"><code class=\"language-none\">&#x2F;share&#x2F;Downlosd&#x2F;src       # BT下载工具默认保存主目录\n&#x2F;share&#x2F;Download&#x2F;dst       # 硬链接目的目录，Emby，tmm，使用的目录，保存各种刮削信息。以及个人文件名修改，目录结构修改。\n在src目录下面建立子目录movie,music,anime,tv,4k等等，在qbittorrent里面设置分类，\n指向这里的movie,music,anime，tv等子目录。下载完后使用下面的硬链接脚本，\n把文件硬链接到目的文件夹。tmm，emby使用目的文件夹刮削数据。</code></pre></div></figure>\n<h4 id=\"qbittorrent使用设置\">qbittorrent使用设置</h4>\n<ul>\n<li>移动种子保存位置在qt的web界面种子上面右键，选择菜单保存位置</li>\n<li>设置分类目录在qt的web界面种子上面右键，选择分类-&gt;新分类，先写分类名称和路径。对于多文件种子，种子添加时选择自动管理。对于单文件种子，请自行添加子文件夹，或强制创建子文件夹。</li>\n</ul>\n<h2 id=\"mklink-sh\"><a href=\"http://mklink.sh\">mklink.sh</a></h2>\n<p>修改脚本参数源目录，目的目录,替换为你自己的目录。脚本将把源目录所有文件硬链接到目的目录，小于1M的文件直接复制到目的目录。方便nfo等小文件刮削修改，大于1M的文件硬链接到目的目录，以节约空间，2份文件只占有一份空间。</p>\n<p>mklink 直接针对2个文件夹做硬链接，小于1m的复制，但是没有判断是否已经硬链接过。<strong>适合全新的没有硬链接过的目录</strong>。</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#mklink.sh sourcedir dstdir\nmklink.sh &#x2F;share&#x2F;Download&#x2F;tmp&#x2F;src &#x2F;share&#x2F;Download&#x2F;tmp&#x2F;dst</code></pre></div></figure>\n<h2 id=\"dirlink-sh\"><a href=\"http://dirlink.sh\">dirlink.sh</a></h2>\n<p>设计原理：<a href=\"http://xn--islinked-z09lqdy6js7k9qcszh77bm28c7pcpywozav39f0wam3gk9g934jdmwb798e6ijf38a.lk\">针对输入原路径下一级子目录判断是否有文件islinked.lk</a>，有这个文件就跳过，没有就硬链接这个子目录到目的目录生成对应的子目录。小于1M的文件复制，大于1M的文件硬链接。</p>\n<p>可以直接修改脚本源目录，目的目录参数，也可以从参数$!,$2输入源目录，目的目录。此脚本和mklink.sh区别在于，将检查每个目录是否已经被硬链接过，已经连接过的将跳过去不再硬链接。<a href=\"http://xn--islinked-t39ly9eba963iwhd9vr0qh8m0aj8xfa892a0t3ditcxx9bd8n.lk\">原理是在源文件夹目录下添加文件islinked.lk</a>，通过检测这个文件来判断是否硬链接过</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">SRC&#x3D;&quot;&#x2F;share&#x2F;Download&#x2F;tmp&#x2F;src&#x2F;movie&quot;\nDST&#x3D;&quot;&#x2F;share&#x2F;Download&#x2F;tmp&#x2F;dst&#x2F;movie&quot;</code></pre></div></figure>\n<p>注意：src目录下面的文件需要放到各个子目录下面去，例如src/anime/amine1,src/tv/tv2，这样才能保证islinked.lk工作正常目录设置可以直接修改脚本，也可以命令行参数输入</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#dirlink.sh sourcedir dstdir\ndirlink.sh &#x2F;share&#x2F;Download&#x2F;tmp&#x2F;src &#x2F;share&#x2F;Download&#x2F;tmp&#x2F;dst</code></pre></div></figure>\n<h3 id=\"重新建立连接，一次性删除所有islinked-lk文件\">重新建立连接，一次性删除所有islinked.lk文件</h3>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">find &#x2F;share&#x2F;Download&#x2F;tmp -name &quot;islinked.lk&quot; | xargs rm -f</code></pre></div></figure>\n<p>替换前面的路径/share/Download/tmp为你自己的路径，操作和rm相关的命令一定<strong>注意不要输入错误</strong>，删错文件代价极大！</p>\n<h3 id=\"一次性硬链接多个目录\">一次性硬链接多个目录</h3>\n<p><a href=\"http://xn--link-494f902dwno9ijr24b9pq.sh\">如下所示脚本link.sh</a></p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">#!&#x2F;bin&#x2F;sh\n&#x2F;share&#x2F;Download&#x2F;source&#x2F;dirlink.sh &#x2F;share&#x2F;Download&#x2F;source&#x2F;anime &#x2F;share&#x2F;Download&#x2F;dst&#x2F;anime\n&#x2F;share&#x2F;Download&#x2F;source&#x2F;dirlink.sh &#x2F;share&#x2F;Download&#x2F;source&#x2F;movie &#x2F;share&#x2F;Download&#x2F;dst&#x2F;movie\n&#x2F;share&#x2F;Download&#x2F;source&#x2F;dirlink.sh &#x2F;share&#x2F;Download&#x2F;source&#x2F;tv &#x2F;share&#x2F;Download&#x2F;dst&#x2F;tv</code></pre></div></figure>\n<h2 id=\"修改限制2M大小以下的复制\">修改限制2M大小以下的复制</h2>\n<p>修改脚本参数FILEGIG，原脚本是1M大小，修改为下面这样就是2M大小</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">FILEGIG&#x3D;2000000c</code></pre></div></figure>\n<p>1000000c 表示 1000000 字节，也就是 1MB。在 find 命令中，可以使用 c 表示字节，k 表示千字节，M 表示兆字节，G 表示吉字节等，这些后缀可以用来指定 -size 选项所匹配的文件大小。</p>\n<p>如果要计算具体的字节大小，可以使用以下转换关系：</p>\n<p>1 字节（Byte）= 8 比特（Bit）</p>\n<p>1 千字节（KB）= 1024 字节</p>\n<p>1 兆字节（MB）= 1024 KB</p>\n<p>1 吉字节（GB）= 1024 MB</p>\n<p>因此，如果要查找大于 10MB 的文件，可以使用 -size +10M，如果要查找大于 100MB 的文件，可以使用 -size +100M。在本脚本中，修改方式就是10M就改为FILEGIG=10M，限制100M，就改为FILEGIG=100M</p>\n<h2 id=\"autolink-sh\"><a href=\"http://autolink.sh\">autolink.sh</a></h2>\n<p>qBittorrent 下载完成时自动硬链接下载完的种子，适用于新下载完成的种子文件。以前下载完成的文件建议使用<code>link.sh</code>脚本的方法。注意：脚本会判断是否进行硬链接的分类，分类详情见脚本内容。</p>\n<ul>\n<li>修改脚本目标目录将你的目录填在<code>your_path</code>的等号后。</li>\n<li>设置下载完成后自动运行在qt的web界面g，点击工具-&gt;选项-&gt;下载，勾选“Torrent 完成时运行外部程序”，填入<code>/path/to/autolink.sh &quot;%N&quot; &quot;%D&quot; &quot;%L&quot;</code>注意：填入autolink.sh的绝对位置，同时autolink与dirlink须在同一目录</li>\n</ul>\n<p>这个脚本使用，需要手动修改脚本中的分类，下面这一行！</p>\n<figure><div class=\"code-area\"><pre class=\"line-numbers language-bash\" data-language=\"bash\" data-start=\"1\"><code class=\"language-bash\">if [[ &quot;$torrent_category&quot; &#x3D;&#x3D; *&quot;movies&quot;* || &quot;$torrent_category&quot; &#x3D;&#x3D; *&quot;series&quot;* || &quot;$torrent_category&quot; &#x3D;&#x3D; *&quot;documents&quot;* || &quot;$torrent_category&quot; &#x3D;&#x3D; *&quot;operas&quot;* ]]</code></pre></div></figure>\n<p>$torrent_category 是qBittorrent分类名称，也是目录名称！</p>\n<h2 id=\"注意事项\">注意事项</h2>\n<ul>\n<li>注意Linux权限，如果运行出错，请检查所使用的的用户和用户组权限。目的目录是否可写！</li>\n</ul>\n<h2 id=\"使用声明\">使用声明</h2>\n<p>数据无价，小心操作。本脚本（除autolink.sh外）没有rm删除，只有mkdir和cp， 最多搞乱文件系统。但要注意不要把目的地目录设置到系统目录去了。一切后果自负</p>\n<h2 id=\"感觉对你有帮助，来个star吧\">感觉对你有帮助，来个star吧</h2>\n<h2 id=\"Contributing\">Contributing</h2>\n<ol>\n<li>Fork it ( <a href=\"https://github.com/appotry/PTtool/fork\">https://github.com/appotry/PTtool/fork</a> )</li>\n<li>Create your feature branch (<code>git checkout -b my-new-feature</code>)</li>\n<li>Commit your changes (<code>git commit -am 'Add some feature'</code>)</li>\n<li>Push to the branch (<code>git push origin my-new-feature</code>)</li>\n<li>Create a new Pull Request</li>\n</ol>\n<link rel=\"stylesheet\" href=\"https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css\"><script src=\"https://fastly.jsdelivr.net/npm/d3@7\"></script><script src=\"https://fastly.jsdelivr.net/npm/markmap-view@0.18.10\"></script><script src=\"https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10\"></script>\n<link rel=\"stylesheet\" href=\"/css/markmap.css\">\n\n<script src=\"/js/markmap.js\"></script>\n",
            "tags": [
                "linux",
                "hardlink",
                "bt",
                "pt"
            ]
        }
    ]
}